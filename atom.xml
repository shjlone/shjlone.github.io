<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shjlone&#39;s Blog</title>
  
  <subtitle>Hello World</subtitle>
  <link href="http://shjlone.github.io/atom.xml" rel="self"/>
  
  <link href="http://shjlone.github.io/"/>
  <updated>2021-07-22T08:10:13.225Z</updated>
  <id>http://shjlone.github.io/</id>
  
  <author>
    <name>shjlone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android系统架构</title>
    <link href="http://shjlone.github.io/wiki/Android/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>http://shjlone.github.io/wiki/Android/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</id>
    <published>2021-07-22T03:50:33.107Z</published>
    <updated>2021-07-22T08:10:13.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./android-stack_2x%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h3><p>Linux Kernel：Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。</p><h3 id="硬件抽象层"><a href="#硬件抽象层" class="headerlink" title="硬件抽象层"></a>硬件抽象层</h3><p>Hardware Abstraction Layer：对Linux内核驱动程序的封装，向上提供接口，向下屏蔽了具体的实现细节。硬件抽象层是位于操作系统内核与硬件电路之间的接口层，<br>其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。<br>从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。</p><h3 id="系统运行层"><a href="#系统运行层" class="headerlink" title="系统运行层"></a>系统运行层</h3><p>Native C/C++ Libraries：系统运行层分为C/C++运行时库和Android运行时环境。</p><p>Android运行时环境在4.4以前使用的是Dalvik，之后使用ART。从5.0开始，正式废弃了Dalvik。</p><h4 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h4><p><strong>什么是Dalvik？</strong></p><ul><li>Dalvik是用于Android平台的Java虚拟机</li><li>Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一</li><li>它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行</li><li>dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统</li><li>Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行</li><li>独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭</li></ul><p><strong>特点</strong></p><ul><li>Dalvik是依靠一个Just-In-Time(JIT编译)编译器去解释字节码</li><li>Dalvik虚拟机下运行Java时，要将字节码通过即时编译器（just in time ，JIT）转换为机器码（机器码才是能真正运行的），这会拖慢应用的运行效率</li><li>应用安装时，执行dexopt指令，将dex文件优化为odex文件</li><li>应用运行时，会将二进制翻译成机器码流程</li></ul><h4 id="Android-Runtime"><a href="#Android-Runtime" class="headerlink" title="Android Runtime"></a>Android Runtime</h4><p><strong>Android Runtime特点</strong></p><ul><li>应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用，这个过程叫做预编译（AOT,Ahead-Of-Time）</li><li>在移除解释代码这一过程后，应用程序执行将更有效率，启动更快</li><li>系统性能的显著提升</li><li>垃圾回收方面的优化</li></ul><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><p>Application Framework：应用框架层，提供了应用开发的核心功能。在实际开发中会使用里面的API。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Activity Manager(活动管理器)</td><td>管理各个应用程序生命周期以及通常的导航回退功能</td></tr><tr><td>Location Manager(位置管理器)</td><td>提供地理位置以及定位功能服务</td></tr><tr><td>Package Manager(包管理器)</td><td>管理所有安装在Android系统中的应用程序</td></tr><tr><td>Notification Manager(通知管理器)</td><td>使得应用程序可以在状态栏中显示自定义的提示信息</td></tr><tr><td>Resource Manager（资源管理器）</td><td>提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等</td></tr><tr><td>Telephony Manager(电话管理器)</td><td>管理所有的移动设备功能</td></tr><tr><td>Window Manager（窗口管理器）</td><td>管理所有开启的窗口程序</td></tr><tr><td>Content Providers（内容提供器）</td><td>使得不同应用程序之间可以共享数据</td></tr><tr><td>View System（视图系统）</td><td>构建应用程序的基本组件</td></tr></tbody></table><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>System Apps：这里存放的是Android自带的一些App，比如：电话、短信、图库、拍摄等。</p><h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><p>可以从 <a href="https://cs.android.com/android/platform/superproject">这里</a> 在线阅读源码，也可以从 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a> 下载源码。</p><p>以下是Android9的源码目录结构：</p><ul><li>art：全新的ART运行环境    <ul><li>dalvlkvm：dalvik 运行时代码</li><li>dex2oat：</li><li>dexdump：</li><li>dexlayout：</li><li>disassembler：</li><li>openjdk|vm：</li><li>openjdk|jvmti：</li><li>runtime：</li><li>simulator：模拟器</li><li>tools：<ul><li>ahat：Android堆栈分析工具</li><li>amm：Actionable Memory Metric</li></ul></li></ul></li><li>bionic：google自己开发的内核库，比GNU的内核更适合移动设备<ul><li>apex：</li><li>libc：对系统调用的封装<ul><li>arch-arm：</li><li>arch-arm64：</li><li>arch-common：</li><li>arch-x86：</li><li>arch-x86_64：</li><li>stdio：标准IO</li><li>tools：一些python工具脚本</li></ul></li><li>libdl：   用于动态库的装载</li><li>libm：数学库<ul><li>upstream-freebsd：很多来自FreeBSD的函数库</li></ul></li><li>libstdc++：标准的C++的功能库</li><li>linker：链接模块 </li><li>tools：</li></ul></li><li>bootable：启动引导相关代码<ul><li>recovery：这个目录用于创建恢复程序</li></ul></li><li>build：存放系统编译规则及generic等基础开发包配置<ul><li>bazel：</li><li>blueprint：</li><li>make：<ul><li>common：</li><li>core：构建系统的核心目录<ul><li>clang：</li><li>combo：编译、编译设置</li><li>tasks：</li></ul></li><li>envsetup.sh</li><li>target：<ul><li>board：构建目标设备的配置</li><li>product： 哪些apps需要编译</li></ul></li><li>tools：编译过程中需要用到的工具<ul><li>acp：</li><li>aplcheck：</li><li>atree：</li><li>check_prereq：</li><li>drolddoc：</li><li>rbb2565：</li><li>zipalign：</li></ul></li></ul></li><li>pesto：</li><li>soong：</li></ul></li><li>compatibility</li><li>cts：Android兼容性测试套件标准</li><li>dalvik：dalvik虚拟机<ul><li>dexdump：</li><li>dexgen：</li><li>dexlist：</li><li>dx：</li><li>opcode-gen：</li></ul></li><li>developers：开发者目录  <ul><li>build：</li><li>demos：</li><li>docs：</li><li>samples：</li></ul></li><li>development：应用程序开发相关<ul><li>apps：包含没有部署到系统到应用<ul><li>BluetoothDebug：</li><li>SdkSetup：</li></ul></li><li>build：<ul><li>tools：构建过程中需要用到的一些工具</li></ul></li><li>cmds：包含monkey tool</li><li>python-packages：</li><li>host：<ul><li>windows：包含Windows版USB驱动</li></ul></li><li>ide：包含对IDE一些配置信息<ul><li>clion</li><li>eclipse</li><li>intellij</li></ul></li><li>sdk：</li><li>scripts：</li><li>tools：<ul><li>apkcheck：APK检查工具</li><li>axl：TCP、HTTP测试</li><li>elftree：</li><li>idegen：</li><li>emulator：</li><li>bugreport：</li><li>ndk：</li><li>ota_analysis：</li><li>otagui：</li><li>winscope：</li><li>monkey：模拟用户点击的测试工具</li></ul></li><li>vendor_snapshot：</li><li>vndk：</li></ul></li><li>device：设备相关配置<ul><li>amlogic：</li><li>common：</li><li>generic：包含不同设备的配置信息<ul><li>arm64：</li><li>art：</li><li>goldfish：</li><li>goldfish-opengl：</li><li>x86：</li></ul></li><li>google：</li><li>google_car：</li><li>linaro：</li><li>mediatek：</li><li>ti：</li></ul></li><li>external：开源模组相关文件，可以理解成第三方库的依赖<ul><li>ImageMagick：</li><li>FXdiv：</li><li>OpenCL-CTS：</li><li>aac：</li><li>adhd：</li><li>adt-infra：</li><li>android-clat：</li><li>androidplot：</li><li>angle：</li><li>antlr：<a href="http://www.antlr.org/">http://www.antlr.org</a></li><li>apache-commons-bcel：</li><li>apache-commons-compress：</li><li>apache-commons-math：</li><li>apache-harmony：</li><li>apache-http：</li><li>apache-xml：</li><li>auto：</li><li>clang：</li><li>bsdiff：</li><li>chromium-libpac：</li><li>chromium-trace：</li><li>chromium-webview：</li><li>cpuinfo：</li><li>curl：</li><li>dagger2：</li><li>dexmaker：</li><li>exoplayer：</li><li>libogg：</li><li>libopus：</li><li>libcap：</li><li>libpng：</li><li>lzma：</li><li>skia：<a href="http://code.google.com/p/skia/">http://code.google.com/p/skia/</a></li><li>v8：Javascript引擎</li><li>webp：<a href="http://code.google.com/speed/webp">http://code.google.com/speed/webp</a></li><li>webrtc：<a href="http://www.webrtc.org/">http://www.webrtc.org</a></li></ul></li><li>frameworks：应用程序框架，Android系统核心部分，由Java和C++编写<ul><li>av：<ul><li>camera：</li><li>media：C实现系统媒体库</li></ul></li><li>base：<ul><li>api：</li><li>boot：</li><li>cmds：重要命令<ul><li>am：</li><li>app_process：</li><li>pm：包管理工具</li></ul></li><li>config：</li><li>data：包含字体文件、音频文件、视频文件等</li><li>location：</li><li>media：多媒体相关库<ul><li>java：</li><li>jni：<ul><li>audioeffect：</li><li>soundpool： </li></ul></li><li>mca：</li><li>native：</li></ul></li><li>multidex：</li><li>native：本地库</li><li>opengl：2D/3D 图形API</li><li>sax：XML解析器</li><li>wifi：wifi无线网络</li><li>packages：<ul><li>BackupRestoreConfirmation：</li><li>DefaultContainerService：</li><li>SystemUI：</li><li>Shell：</li><li>VpnDialogs：</li></ul></li></ul></li><li>compile：</li><li>ex：</li><li>hardware：</li><li>layoutlib：</li><li>libs：</li><li>native：<ul><li>opengl：第三方图形渲染库</li><li>services：<ul><li>audiomanager：</li><li>batteryservice：</li><li>displayservice： </li><li>gpuservice： </li><li>inputflinger：</li><li>surfaceflinger：图形显示库，主要负责图形的渲染、叠加和绘制等功能</li><li>sensorservice：</li><li>vr：</li></ul></li></ul></li></ul></li><li>hardware：主要是硬件抽象层的代码<ul><li>broadcom：</li><li>google：</li><li>libhardware：</li><li>libhardware_legacy：</li><li>nxp：</li><li>samsung：</li><li>st：</li></ul></li><li>kernel：</li><li>libcore：核心库相关文件<ul><li>api：</li><li>dalvik：</li><li>dom：</li><li>json：</li><li>xml：</li></ul></li><li>libnativehelper：动态库，实现JNI库的基础</li><li>packages：自带Apps应用程序包<ul><li>apps：系统App<ul><li>Bluetooth：</li><li>Calendar：</li><li>Camera2：</li><li>Dialer：</li><li>Launcher3：</li></ul></li><li>inputmethods：输入法目录</li><li>modules：<ul><li>ArtPrebuilt:</li><li>DnsResolver: DNS解析</li><li>Permission: 权限</li><li>adb：adb工具</li></ul></li><li>providers：内容提供者目录<ul><li>CalendarProvider:</li><li>DownloadProvider:</li><li>MediaProvider:</li><li>TelephonyProvider:</li></ul></li><li>screensavers：屏幕保护</li><li>services：通信服务<ul><li>AlternativeNetworkAccess：</li><li>Telephony</li></ul></li><li>wallpapers：墙纸</li></ul></li><li>pdk：Plug Development Kit 的缩写，本地开发套件</li><li>platform_testing：平台测试</li><li>prebuilts：x86和arm架构下预编译的一些资源<ul><li>bazel：</li><li>clang：</li><li>devtools：</li><li>gcc：</li><li>go：</li><li>gradle-plugin：</li><li>jdk：</li><li>python：</li><li>mlsc：</li><li>ndk：</li><li>runtime：</li><li>tools：<ul><li>common：</li><li>darwln-x86：</li><li>linux-x86：</li><li>linux-x86_64：</li></ul></li></ul></li><li>sdk：sdk和模拟器<ul><li>annotations：</li><li>apkbuilder：这个废弃了，推荐直接使用com.android.sdklib.build.ApkBuilder</li><li>find_java：</li><li>find_java2：</li><li>sdklauncher：</li><li>hierarchyviewer：视图查看器</li></ul></li><li>system：底层文件系统库、应用和组件<ul><li>apex：</li><li>bpf：</li><li>core：<ul><li>debuggerd：</li><li>logcat：</li><li>toolbox：</li><li>watchdogd：</li></ul></li><li>extras：<ul><li>ANRdaemon：</li><li>app-launcher：</li><li>su：</li><li>sound：播放wav文件工具</li><li>toolchain-extras：</li></ul></li></ul></li><li>test：</li><li>toolchain：工具链文件</li><li>tools：工具文件</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://elinux.org/Master-android">https://elinux.org/Master-android</a></li><li><a href="https://juejin.cn/post/6844903958918463495">Android 虚拟机Art和Dalvik的区别</a></li><li><a href="https://source.android.com/devices/tech/dalvik?hl=zh-cn">https://source.android.com/devices/tech/dalvik?hl=zh-cn</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">Android 镜像使用帮助</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;./android-stack_2x%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;系统架构&quot;&gt;&lt;a href=&quot;#系统架构&quot; class=&quot;headerlink&quot; title=&quot;系统架构&quot;&gt;</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之DiffUtil</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BDiffUtil/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BDiffUtil/</id>
    <published>2021-07-21T08:27:06.467Z</published>
    <updated>2021-07-22T03:01:56.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用DiffUtil的原因是替代notifyDataSetChanged，提升性能。</p><p>DiffUtil使用的是Eugene Myers的差别算法，这个算法本身不能检查到元素的移动，也就是移动只能被算作先删除、再增加，而DiffUtil是在算法的结果后再<br>进行一次移动检查。假设在不检测元素移动的情况下，算法的时间复杂度为O(N + D2)，而检测元素移动则复杂度为O(N2)。所以，如果集合本身就已经排好序，<br>可以不进行移动的检测提升效率。</p><p>ListAdapter和AsyncListDiffer中有使用。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List newList)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    MyDiffCallback callback = <span class="keyword">new</span> MyDiffCallback(oldList, newList);</span><br><span class="line">    DiffUtil.DiffResult result = DiffUtil.calculateDiff(callback);</span><br><span class="line"></span><br><span class="line">    oldList.clear();</span><br><span class="line">    oldList.addAll(newList);</span><br><span class="line">    result.dispatchUpdatesTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用的步骤：</p><ol><li>实现DiffUtil.Callback</li><li>调用calculateDiff计算不同点</li><li>dispatchUpdatesTo刷新数据</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiffResult <span class="title">calculateDiff</span><span class="params">(<span class="meta">@NonNull</span> Callback cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculateDiff(cb, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 旧数据集的长度</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOldListSize</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新数据集的长度</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNewListSize</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否是同一个item</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areItemsTheSame</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果item相同，此方法用于判断是否同一个Item的内容也相同</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areContentsTheSame</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果item相同，内容不同，用 payLoad 记录这个ViewHolder中具体需要更新那个View</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getChangePayload</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffResult</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据diff 数据结果，选择刷新方式</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchUpdatesTo</span><span class="params">(<span class="meta">@NonNull</span> ListUpdateCallback updateCallback)</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>过程如下：</p><ol><li>实现DiffUtil.Callback接口</li><li>新老数据集通过DiffUtil.calculateDiff计算得到DiffUtil.DiffResult </li><li>DiffUtil.DiffResult::dispatchUpdatesTo刷新数据</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.ysy950803.top/2020/01/12/RecyclerView%E4%B8%ADDiffUtil%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">RecyclerView中DiffUtil的一些注意事项</a></li><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil">https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil</a></li><li><a href="https://github.com/mrmike/DiffUtil-sample">https://github.com/mrmike/DiffUtil-sample</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;使用DiffUtil的原因是替代notifyDataSetChanged，提升性能。&lt;/p&gt;
&lt;p&gt;DiffUtil使用的是Eugene M</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
    <category term="RecyclerView" scheme="http://shjlone.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>样式和主题</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/%E6%A0%B7%E5%BC%8F%E5%92%8C%E4%B8%BB%E9%A2%98/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/%E6%A0%B7%E5%BC%8F%E5%92%8C%E4%B8%BB%E9%A2%98/</id>
    <published>2021-07-20T02:49:33.814Z</published>
    <updated>2021-07-20T11:53:59.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>样式</code>是一个属性集合，用于指定单个 View 的外观。样式可以指定字体颜色、字号、背景颜色等属性。</p><p><code>主题背景</code>是应用于整个应用、Activity 或视图层次结构，而非仅仅应用于单个视图的属性集合。当您应用主题背景时，应用或 Activity 中的每个视图都会<br>应用其支持的每个主题背景属性。主题还可以将样式应用于非视图元素，例如状态栏和窗口背景。主题可以理解成样式的集合。</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="定义样式"><a href="#定义样式" class="headerlink" title="定义样式"></a>定义样式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encodeing=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;style name=<span class="string">&quot;BaseToolBarLine&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:layout_width&quot;</span>&gt;match_parent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:layout_height&quot;</span>&gt;1px&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:background&quot;</span>&gt;<span class="meta">@color</span>/base_toolbar_line_color&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;style name=<span class="string">&quot;CodeFontRed&quot;</span> parent=<span class="string">&quot;CodeFont&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:textColor&quot;</span>&gt;#FF0000&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;!-- 样式是可以继承的 --&gt;</span><br><span class="line">    &lt;style name=<span class="string">&quot;CodeFont.Red&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:textColor&quot;</span>&gt;#FF0000&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure><p><strong>在布局文件中使用样式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=<span class="string">&quot;@style/BaseToolBarLine&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>如果有多个module，需要注意样式的继承，以免出现，子module修改了某个同名的style，造成父module中的样式被修改。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Android的主题发展历史</p><ol><li><p>在Android3.0之前，Android的界面不论是从系统还是空间的主题都是按钮为白色，点击事件为黄色。现在看来很简陋</p></li><li><p>Holo主题：Android3.0 （API11）开始，Google推出了Holo主题（就是我们印象中的黑底白字蓝主色的主题）。在4.0google又发布了应用设计规范Android Design。<br>有了设计规范的指导，就有了更多的应用采用Holo主题。所以我们可以简单认为Android Design就是Holo主题。但是这种主题是适合移动设备，其他平台略显突兀。</p></li><li><p>在4.0之前Android可以说是没有设计可言的，在4.0之后推出了Android Design，从此Android在设计上有了很大的改善，而在程序实现上相应的就是Holo风格，<br>所以你看到有类似 Theme.Holo.Light、 Theme.Holo.Light.DarkActionBar 就是4.0的设计风格，但是为了让4.0之前的版本也能有这种风格怎么办呢？<br>这个时候就不得不引用v7包了，所以对应的就有 Theme.AppCompat.Light、Theme.AppCompat.Light.DarkActionBar，如果你的程序最小支持的版本是<br>API14（即Android 4.0），那么可以不用考虑v7的兼容</p></li><li><p>Material 主题：从Android5.0（API21）开始，Google又推出了材料设计语言Material Design，又叫Google Design。MD崇尚的就是图层扁平化，<br>所有图层像纸或者卡片一样重叠在一起，所以Android5.0就有了RecyclerView和CardView。图层之间有间隔，所以Android5.0中有了translation和elevation<br>两个属性。同时也规范了Android的运动元素，界面上的每个元素不是无故产生的，同时每个图层的产生和消失都有方向的约定，从哪里来就往哪里去，<br>这也是为什么Android 5.0中会有Ripple，Circular Receal，Activity Transition</p></li><li><p>Android在5.0版本推出了Material Design的概念，这是Android设计上又一大突破。对应的程序实现上就有Theme.Material.Light、<br>Theme.Material.Light.DarkActionBar等，但是这种风格只能应用在在5.0版本的手机，如果在5.0之前应用Material Design该怎么办呢？<br>同样的引用appcompat-v7包，这个时候的Theme.AppCompat.Light、Theme.AppCompat.Light.DarkActionBar就是相对应兼容的Material Design的Theme。</p></li></ol><p>主题也跟样式一样是可以继承的，主题的根在themes.xml文件中。定义了<code>&lt;style name=&quot;Theme&quot;&gt;&lt;/style&gt;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 黑色背景--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.Black&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowBackground&quot;</span>&gt;</span>@color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorBackground&quot;</span>&gt;</span>@color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 没有标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.Black.NoTitleBar&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--兼容主题的根主题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.AppCompat&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.AppCompat&quot;</span>/&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.AppCompat.Dialog&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.AppCompat.Dialog&quot;</span>/&gt;</span><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="comment">&lt;!-- 没有actionbar --&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="xml">    <span class="comment">&lt;!-- 这里是AppCompat定义的属性，另外还有android:windowNoTitle属性 --&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowActionBar&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="xml"></span></span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; </span><br><span class="line">&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;  Dialog的windowFrame框为无</span><br><span class="line">&lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt; 是否浮现在activity之上</span><br><span class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;false&lt;/item&gt; 是否半透明</span><br><span class="line">&lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; 是否显示title</span><br><span class="line">&lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/dia_bg&lt;/item&gt; 设置背景</span><br><span class="line">&lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;  背景是否变暗</span><br><span class="line">&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/AnimBottom&lt;/item&gt;  窗口的动画设置</span><br><span class="line">&lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;  这个drawable会覆盖在content区域的上面</span><br><span class="line">&lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;  Dialog弹窗漂浮</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.android.com/guide/topics/ui/look-and-feel/themes?hl=zh-cn">样式和主题背景</a></li><li><a href="https://blog.csdn.net/u010356768/article/details/83651127">Android中主题知识</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;样式&lt;/code&gt;是一个属性集合，用于指定单个 View 的外观。样式可以指定字体颜色、字号、背景颜色等属性。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="基础" scheme="http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之ItemAnimator</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BItemAnimator/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BItemAnimator/</id>
    <published>2021-07-16T09:09:13.556Z</published>
    <updated>2021-07-20T06:53:02.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ItemAnimator用于对每一个元素进行动画控制，Android中默认的实现为DefaultItemAnimator。在DefaultItemAnimator的删除动画中，会对被删除的<br>子视图执行透明度1-0的动画，动画结束后，会删除子视图和回收ViewHolder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">recyclerView.setItemAnimator(<span class="keyword">new</span> DefaultItemAnimator());<span class="comment">//默认实现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemAnimator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示ViewHolder已经更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_CHANGED = ViewHolder.FLAG_UPDATE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示ViewHolder已经被移除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_REMOVED = ViewHolder.FLAG_REMOVED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//notifyDataSetChanged已经被调用，ViewHolder已经失效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_INVALIDATED = ViewHolder.FLAG_INVALID;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ViewHolder已经移动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_MOVED = ViewHolder.FLAG_MOVED;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ItemAnimatorListener mListener = <span class="keyword">null</span>;<span class="comment">//回调监听器</span></span><br><span class="line">    <span class="comment">//监听器列表</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ItemAnimatorFinishedListener&gt; mFinishedListeners =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;ItemAnimatorFinishedListener&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Item移除回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateRemove</span><span class="params">(RecyclerView.ViewHolder holder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Item添加回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAdd</span><span class="params">(RecyclerView.ViewHolder holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于控制添加，移动更新时，其它Item的动画执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateMove</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> fromX, <span class="keyword">int</span> fromY, <span class="keyword">int</span> toX, <span class="keyword">int</span> toY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Item更新回调，在显式调用notifyItemChanged()或notifyDataSetChanged()时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateChange</span><span class="params">(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, <span class="keyword">int</span> fromLeft, <span class="keyword">int</span> fromTop, <span class="keyword">int</span> toLeft, <span class="keyword">int</span> toTop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正控制执行动画的地方</span></span><br><span class="line">    <span class="comment">// RecyclerView动画的执行方式并不是立即执行，而是每帧执行一次，比如两帧之间添加了多个Item，则会将这些将要执行的动画Pending住，</span></span><br><span class="line">    <span class="comment">// 保存在成员变量中，等到下一帧一起执行。该方法执行的前提是前面animateXxx()返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runPendingAnimations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//停止某个Item的动画</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">(RecyclerView.ViewHolder item)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//停止所有动画</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endAnimations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否有Item在运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当ViewHolder出现在屏幕上时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder viewHolder,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> ItemHolderInfo preLayoutInfo, <span class="meta">@NonNull</span> ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line">                </span><br><span class="line">    <span class="comment">//当ViewHolder消失在屏幕上时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animateDisappearance</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder viewHolder,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> ItemHolderInfo preLayoutInfo, <span class="meta">@Nullable</span> ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在没调用notifyItemChanged()和notifyDataSetChanged()的情况下布局发生改变时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">animatePersistence</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder viewHolder,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> ItemHolderInfo preLayoutInfo, <span class="meta">@NonNull</span> ItemHolderInfo postLayoutInfo)</span></span>;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DefaultItemAnimator"><a href="#DefaultItemAnimator" class="headerlink" title="DefaultItemAnimator"></a>DefaultItemAnimator</h2><p>这是RecyclerView的默认实现，删除动画中，会对被删除的子视图执行透明度1-0的动画，动画结束后，会删除子视图和回收ViewHolder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultItemAnimator</span> <span class="keyword">extends</span> <span class="title">SimpleItemAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingRemovals = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放下一帧要执行的一系列add动画</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingAdditions = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放正在执行的一批add动画</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;MoveInfo&gt; mPendingMoves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ChangeInfo&gt; mPendingChanges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ArrayList&lt;RecyclerView.ViewHolder&gt;&gt; mAdditionsList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放当前正在执行的add动画</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;MoveInfo&gt;&gt; mMovesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;ArrayList&lt;ChangeInfo&gt;&gt; mChangesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;RecyclerView.ViewHolder&gt; mAddAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;RecyclerView.ViewHolder&gt; mMoveAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;RecyclerView.ViewHolder&gt; mRemoveAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;RecyclerView.ViewHolder&gt; mChangeAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加动画</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAdd</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重置动画，设置默认差值器</span></span><br><span class="line">        resetAnimation(holder);</span><br><span class="line">        <span class="comment">//设置默认状态，透明度为0</span></span><br><span class="line">        holder.itemView.setAlpha(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//添加到待执行列表中</span></span><br><span class="line">        mPendingAdditions.add(holder);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fromX、fromY表示起始值</span></span><br><span class="line">    <span class="comment">//toX、toY表示目标值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateMove</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder, <span class="keyword">int</span> fromX, <span class="keyword">int</span> fromY,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> toX, <span class="keyword">int</span> toY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> View view = holder.itemView;</span><br><span class="line">        <span class="comment">//计算出未执行的值</span></span><br><span class="line">        fromX += (<span class="keyword">int</span>) holder.itemView.getTranslationX();</span><br><span class="line">        fromY += (<span class="keyword">int</span>) holder.itemView.getTranslationY();</span><br><span class="line">        resetAnimation(holder);</span><br><span class="line">        <span class="keyword">int</span> deltaX = toX - fromX;</span><br><span class="line">        <span class="keyword">int</span> deltaY = toY - fromY;</span><br><span class="line">        <span class="keyword">if</span> (deltaX == <span class="number">0</span> &amp;&amp; deltaY == <span class="number">0</span>) &#123;</span><br><span class="line">            dispatchMoveFinished(holder);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把Item位移到未操作前的现位置</span></span><br><span class="line">        <span class="keyword">if</span> (deltaX != <span class="number">0</span>) &#123;</span><br><span class="line">            view.setTranslationX(-deltaX);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deltaY != <span class="number">0</span>) &#123;</span><br><span class="line">            view.setTranslationY(-deltaY);</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingMoves.add(<span class="keyword">new</span> MoveInfo(holder, fromX, fromY, toX, toY));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runPendingAnimations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removalsPending = !mPendingRemovals.isEmpty();<span class="comment">//判断移除队列是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span> movesPending = !mPendingMoves.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> changesPending = !mPendingChanges.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> additionsPending = !mPendingAdditions.isEmpty();</span><br><span class="line">        <span class="comment">//如果都为空，则执行返回</span></span><br><span class="line">        <span class="keyword">if</span> (!removalsPending &amp;&amp; !movesPending &amp;&amp; !additionsPending &amp;&amp; !changesPending) &#123;</span><br><span class="line">            <span class="comment">// nothing to animate</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First, remove stuff</span></span><br><span class="line">        <span class="comment">// 先执行移除队列</span></span><br><span class="line">        <span class="keyword">for</span> (RecyclerView.ViewHolder holder : mPendingRemovals) &#123;</span><br><span class="line">            animateRemoveImpl(holder);</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingRemovals.clear();</span><br><span class="line">        <span class="comment">// Next, move stuff</span></span><br><span class="line">        <span class="comment">// 执行移动队列</span></span><br><span class="line">        <span class="keyword">if</span> (movesPending) &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;MoveInfo&gt; moves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            moves.addAll(mPendingMoves);</span><br><span class="line">            mMovesList.add(moves);</span><br><span class="line">            mPendingMoves.clear();</span><br><span class="line">            Runnable mover = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (MoveInfo moveInfo : moves) &#123;</span><br><span class="line">                        animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY,</span><br><span class="line">                                moveInfo.toX, moveInfo.toY);</span><br><span class="line">                    &#125;</span><br><span class="line">                    moves.clear();</span><br><span class="line">                    mMovesList.remove(moves);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//是否需要删除动画</span></span><br><span class="line">            <span class="keyword">if</span> (removalsPending) &#123;</span><br><span class="line">                View view = moves.get(<span class="number">0</span>).holder.itemView;</span><br><span class="line">                ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());<span class="comment">//等待删除动画结束</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mover.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, change stuff, to run in parallel with move animations</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (changesPending) &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ChangeInfo&gt; changes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            changes.addAll(mPendingChanges);</span><br><span class="line">            mChangesList.add(changes);</span><br><span class="line">            mPendingChanges.clear();</span><br><span class="line">            Runnable changer = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (ChangeInfo change : changes) &#123;</span><br><span class="line">                        animateChangeImpl(change);</span><br><span class="line">                    &#125;</span><br><span class="line">                    changes.clear();</span><br><span class="line">                    mChangesList.remove(changes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (removalsPending) &#123;</span><br><span class="line">                RecyclerView.ViewHolder holder = changes.get(<span class="number">0</span>).oldHolder;</span><br><span class="line">                ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                changer.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, add stuff</span></span><br><span class="line">        <span class="comment">// 添加动画</span></span><br><span class="line">        <span class="keyword">if</span> (additionsPending) &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;RecyclerView.ViewHolder&gt; additions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            additions.addAll(mPendingAdditions);</span><br><span class="line">            mAdditionsList.add(additions);</span><br><span class="line">            mPendingAdditions.clear();</span><br><span class="line">            Runnable adder = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (RecyclerView.ViewHolder holder : additions) &#123;</span><br><span class="line">                        animateAddImpl(holder);</span><br><span class="line">                    &#125;</span><br><span class="line">                    additions.clear();</span><br><span class="line">                    mAdditionsList.remove(additions);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (removalsPending || movesPending || changesPending) &#123;</span><br><span class="line">                <span class="keyword">long</span> removeDuration = removalsPending ? getRemoveDuration() : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">long</span> moveDuration = movesPending ? getMoveDuration() : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">long</span> changeDuration = changesPending ? getChangeDuration() : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">long</span> totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</span><br><span class="line">                View view = additions.get(<span class="number">0</span>).itemView;</span><br><span class="line">                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                adder.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateRemove</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//清除、移除Item</span></span><br><span class="line">        resetAnimation(holder);</span><br><span class="line">        <span class="comment">//将ViewHolder添加到待移除队列</span></span><br><span class="line">        mPendingRemovals.add(holder);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码流程"><a href="#源码流程" class="headerlink" title="源码流程"></a>源码流程</h2><p><img src="./itemanimtor_liucheng.png"></p><h2 id="自定义ItemAnimator"><a href="#自定义ItemAnimator" class="headerlink" title="自定义ItemAnimator"></a>自定义ItemAnimator</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/7171ea362513">https://www.jianshu.com/p/7171ea362513</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;ItemAnimator用于对每一个元素进行动画控制，Android中默认的实现为DefaultItemAnimator。在</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
    <category term="RecyclerView" scheme="http://shjlone.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之SnapHelper</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BSnapHelper/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BSnapHelper/</id>
    <published>2021-07-16T06:31:42.216Z</published>
    <updated>2021-07-16T08:37:02.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>SnapHelper用于辅助RecyclerView在滚动结束时将Item对齐到某个位置。能让RecyclerView实现类似ViewPager等功能。</p><p>RecyclerView描述滚动状态的几个属性：</p><ul><li><code>SCROLL_STATE_IDLE</code>：滚动闲置状态，此时并没有手指滑动或者动画执行</li><li><code>SCROLL_STATE_DRAGGING</code>：滚动拖拽状态，由于用户触摸屏幕产生</li><li><code>SCROLL_STATE_SETTLING</code>：自动滚动状态，此时没有手指触摸，一般是由动画执行滚动到最终位置，包括smoothScrollTo等方法的调用</li></ul><p>当手指在屏幕上滑动RecyclerView然后松手，RecyclerView中的内容会顺着惯性继续往手指滑动的方向继续滚动直到停止，这个过程叫做<code>Fling</code>。</p><h2 id="Fling"><a href="#Fling" class="headerlink" title="Fling"></a>Fling</h2><p>当触发MotionEvent.ACTION_UP时，RecyclerView会进行fling判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Cannot fling without a LayoutManager set. &quot;</span></span><br><span class="line">                + <span class="string">&quot;Call setLayoutManager with a non-null argument.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayoutFrozen) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollHorizontal = mLayout.canScrollHorizontally();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollVertical = mLayout.canScrollVertically();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canScrollHorizontal || Math.abs(velocityX) &lt; mMinFlingVelocity) &#123;</span><br><span class="line">        velocityX = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!canScrollVertical || Math.abs(velocityY) &lt; mMinFlingVelocity) &#123;</span><br><span class="line">        velocityY = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (velocityX == <span class="number">0</span> &amp;&amp; velocityY == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If we don&#x27;t have any velocity, return false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理嵌套滚动PreFling</span></span><br><span class="line">    <span class="keyword">if</span> (!dispatchNestedPreFling(velocityX, velocityY)) &#123;</span><br><span class="line">        <span class="keyword">final</span> View firstChild = mLayout.getChildAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> View lastChild = mLayout.getChildAt(mLayout.getChildCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> consumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (velocityY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            consumed = getChildAdapterPosition(firstChild) &gt; <span class="number">0</span></span><br><span class="line">                    || firstChild.getTop() &lt; getPaddingTop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (velocityY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            consumed = getChildAdapterPosition(lastChild) &lt; mAdapter.getItemCount() - <span class="number">1</span></span><br><span class="line">                    || lastChild.getBottom() &gt; getHeight() - getPaddingBottom();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatchNestedFling(velocityX, velocityY, consumed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过setOnFlingListener设置mOnFlingListener，由用户来判断是否属性自己定义fling行为</span></span><br><span class="line">        <span class="comment">//默认的实现有LinearSnapHelper、PagerSnapHelper</span></span><br><span class="line">        <span class="keyword">if</span> (mOnFlingListener != <span class="keyword">null</span> &amp;&amp; mOnFlingListener.onFling(velocityX, velocityY)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canScroll = canScrollHorizontal || canScrollVertical;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canScroll) &#123;</span><br><span class="line">            velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity));</span><br><span class="line">            velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity));</span><br><span class="line">            /默认的Fling操作，最终到OverScroller计算滚动相关的值</span><br><span class="line">            mViewFlinger.fling(velocityX, velocityY);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由源码可知，会来到SnapHelper进行判断。</p><h2 id="SnapHelper"><a href="#SnapHelper" class="headerlink" title="SnapHelper"></a>SnapHelper</h2><p>SnapHelper是一个抽象类，具体实现有LinearSnapHelper、PagerSnapHelper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">会计算第二个参数对应的ItemView当前的坐标与需要对齐的坐标之间的距离。该方法返回一个大小为2的int数组，分别对应x轴和y轴方向上的距离。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>[] calculateDistanceToFinalSnap(<span class="meta">@NonNull</span> RecyclerView.LayoutManager layoutManager,</span><br><span class="line">        <span class="meta">@NonNull</span> View targetView);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">会找到当前layoutManager上最接近对齐位置的那个view，该view称为SanpView，对应的position称为SnapPosition。如果返回null，</span></span><br><span class="line"><span class="comment">就表示没有需要对齐的View，也就不会做滚动对齐调整。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">findSnapView</span><span class="params">(RecyclerView.LayoutManager layoutManager)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">会根据触发Fling操作的速率（参数velocityX和参数velocityY）来找到RecyclerView需要滚动到哪个位置，该位置对应的ItemView就是那个需要</span></span><br><span class="line"><span class="comment">进行对齐的列表项。我们把这个位置称为targetSnapPosition，对应的View称为targetSnapView。如果找不到targetSnapPosition，就返回</span></span><br><span class="line"><span class="comment">RecyclerView.NO_POSITION</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">findTargetSnapPosition</span><span class="params">(RecyclerView.LayoutManager layoutManager, <span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过下面的代码，注册到RecyclerView中，可以实现相应的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滚动停止时相应的Item停留中间位置</span></span><br><span class="line"><span class="keyword">new</span> LinearSnapHelper().attachToRecyclerView(mRecyclerView);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似ViewPage效果</span></span><br><span class="line"><span class="keyword">new</span> PagerSnapHelper().attachToRecyclerView(mRecyclerView);</span><br></pre></td></tr></table></figure><p>来看看LinearSnapHelper的源码</p><h3 id="依附RecyclerView流程"><a href="#依附RecyclerView流程" class="headerlink" title="依附RecyclerView流程"></a>依附RecyclerView流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachToRecyclerView</span><span class="params">(<span class="meta">@Nullable</span> RecyclerView recyclerView)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">//如果SnapHelper之前已经附着到此RecyclerView上，不用进行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (mRecyclerView == recyclerView) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// nothing to do</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果SnapHelper之前附着的RecyclerView和现在的不一致，清理掉之前RecyclerView的回调</span></span><br><span class="line">    <span class="keyword">if</span> (mRecyclerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        destroyCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line">    mRecyclerView = recyclerView;</span><br><span class="line">    <span class="keyword">if</span> (mRecyclerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//设置当前RecyclerView对象的回调</span></span><br><span class="line">        setupCallbacks();</span><br><span class="line">        <span class="comment">//创建一个Scroller对象，用于辅助计算fling的总距离</span></span><br><span class="line">        mGravityScroller = <span class="keyword">new</span> Scroller(mRecyclerView.getContext(),</span><br><span class="line">                <span class="keyword">new</span> DecelerateInterpolator());</span><br><span class="line">        <span class="comment">//调用snapToTargetExistingView()方法以实现对SnapView的对齐滚动处理</span></span><br><span class="line">        snapToTargetExistingView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupCallbacks</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRecyclerView.getOnFlingListener() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;An instance of OnFlingListener already set.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册滚动监听器</span></span><br><span class="line">    mRecyclerView.addOnScrollListener(mScrollListener);</span><br><span class="line">    <span class="comment">//注册自己</span></span><br><span class="line">    mRecyclerView.setOnFlingListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Handles the snap on scroll case.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RecyclerView.OnScrollListener mScrollListener =</span><br><span class="line">        <span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">            <span class="keyword">boolean</span> mScrolled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">                <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mScrolled) &#123;</span><br><span class="line">                    mScrolled = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//对targetView进行滚动调整，以确保停止的位置是在对应的坐标上，这就是RecyclerView添加该OnScrollListener的目的</span></span><br><span class="line">                    snapToTargetExistingView();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">                    mScrolled = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snapToTargetExistingView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRecyclerView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出SnapView</span></span><br><span class="line">    View snapView = findSnapView(layoutManager);</span><br><span class="line">    <span class="keyword">if</span> (snapView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算出SnapView需要滚动的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] snapDistance = calculateDistanceToFinalSnap(layoutManager, snapView);</span><br><span class="line">    <span class="comment">//如果需要滚动的距离不是为0，就调用smoothScrollBy（）使RecyclerView滚动相应的距离</span></span><br><span class="line">    <span class="keyword">if</span> (snapDistance[<span class="number">0</span>] != <span class="number">0</span> || snapDistance[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        mRecyclerView.smoothScrollBy(snapDistance[<span class="number">0</span>], snapDistance[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onFling"><a href="#onFling" class="headerlink" title="onFling"></a>onFling</h3><p>在RecyclerView中的fling方法中，如果依附来LinearSnapHelper，会调用LinearSnapHelper的onFling方法进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(<span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY)</span> </span>&#123;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RecyclerView.Adapter adapter = mRecyclerView.getAdapter();</span><br><span class="line">    <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取RecyclerView要进行fling操作需要的最小速率，</span></span><br><span class="line">    <span class="comment">//只有超过该速率，ItemView才会有足够的动力在手指离开屏幕时继续滚动下去</span></span><br><span class="line">    <span class="keyword">int</span> minFlingVelocity = mRecyclerView.getMinFlingVelocity();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//snapFromFling()这个方法，就是通过该方法实现平滑滚动并使得在滚动停止时itemView对齐到目的坐标位置</span></span><br><span class="line">    <span class="keyword">return</span> (Math.abs(velocityY) &gt; minFlingVelocity || Math.abs(velocityX) &gt; minFlingVelocity)</span><br><span class="line">            &amp;&amp; snapFromFling(layoutManager, velocityX, velocityY);</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">snapFromFling</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView.LayoutManager layoutManager, <span class="keyword">int</span> velocityX,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> velocityY)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//layoutManager必须实现ScrollVectorProvider接口才能继续往下操作</span></span><br><span class="line">    <span class="keyword">if</span> (!(layoutManager <span class="keyword">instanceof</span> RecyclerView.SmoothScroller.ScrollVectorProvider)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建SmoothScroller对象，是一个平滑滚动器，用于对ItemView进行平滑滚动操作</span></span><br><span class="line">    <span class="comment">//根据速率计算滑动距离</span></span><br><span class="line">    RecyclerView.SmoothScroller smoothScroller = createScroller(layoutManager);</span><br><span class="line">    <span class="keyword">if</span> (smoothScroller == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过findTargetSnapPosition()方法，以layoutManager和速率作为参数，找到targetSnapPosition</span></span><br><span class="line">    <span class="keyword">int</span> targetPosition = findTargetSnapPosition(layoutManager, velocityX, velocityY);</span><br><span class="line">    <span class="keyword">if</span> (targetPosition == RecyclerView.NO_POSITION) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过setTargetPosition()方法设置滚动器的滚动目标位置</span></span><br><span class="line">    smoothScroller.setTargetPosition(targetPosition);</span><br><span class="line">    <span class="comment">//利用layoutManager启动平滑滚动器，开始滚动到目标位置</span></span><br><span class="line">    layoutManager.startSmoothScroll(smoothScroller);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>使用时使用attachToRecyclerView添加依附</li><li>onFling操作触发的时候首先通过findTargetSnapPosition找到最终需要滚动到的位置，然后启动平滑滚动器滚动到指定位置，</li><li>在指定位置找出来后，系统会回调onTargetFound,然后调用calculateDistanceToFinalSnap方法计算targetView需要减速滚动的距离，然后通过Action<br>更新给滚动器。</li><li>在滚动停止的时候，也就是state变成SCROLL_STATE_IDLE时会调用snapToTargetExistingView，通过findSnapView找到SnapView，然后通过<br>calculateDistanceToFinalSnap计算得到滚动的距离，做最后的对齐调整。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/e54db232df62">https://www.jianshu.com/p/e54db232df62</a></li><li><a href="https://github.com/rubensousa/GravitySnapHelper">https://github.com/rubensousa/GravitySnapHelper</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;SnapHelper用于辅助RecyclerView在滚动结束时将Item对齐到某个位置。能让RecyclerView实现类似ViewPag</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
    <category term="RecyclerView" scheme="http://shjlone.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之缓存策略</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8B%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8B%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</id>
    <published>2021-07-16T03:52:57.582Z</published>
    <updated>2021-07-20T09:33:51.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="Recycler"><a href="#Recycler" class="headerlink" title="Recycler"></a>Recycler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未与RecyclerView分离的ViewHolder列表</span></span><br><span class="line">    <span class="comment">// 如果仍依赖于 RecyclerView （比如已经滑动出可视范围，但还没有被移除掉），但已经被标记移除的 ItemView 集合会被添加到 mAttachedScrap 中 </span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> ArrayList&lt;ViewHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewHolder&gt;</span><br><span class="line">            mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRequestedCacheMax = DEFAULT_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">int</span> mViewCacheMax = DEFAULT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存池，业务场景中可复用的ViewHolder可以存储进来</span></span><br><span class="line">    RecycledViewPool mRecyclerPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ViewCacheExtension mViewCacheExtension;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CACHE_SIZE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将view对应的ViewHolder移动到mCachedViews中；如果View是scrapped状态，会先unscrap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycleView</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> </span>&#123;&#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从mChangedScrap、mAttachedScrap、mCachedViews、ViewCacheExtension、RecycledViewPool中进行匹配；若匹配不了，</span></span><br><span class="line">    <span class="comment">// 最后会直接调用Adapter.createViewHolder方法进行创建</span></span><br><span class="line">    <span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从 attach scrap、hidden children 、 cache中，根据 position 返回 ViewHolder</span></span><br><span class="line">    <span class="function">ViewHolder <span class="title">getScrapOrHiddenOrCachedHolderForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><ul><li><p>mAttachedScrap、mChangedScrap</p><ul><li>mAttachedScrap保存依附于 RecyclerView 的 ViewHolder。包含移出屏幕但未从 RecyclerView 移除的 ViewHolder。</li><li>mChangedScrap 保存数据发生改变的 ViewHolder，即调用 notifyDataSetChanged() 等系列方法后需要更新的 ViewHolder。</li></ul></li><li><p>mCachedViews</p><ul><li>mCachedViews 用于解决滑动抖动的问题，默认容量为2。</li></ul></li><li><p>ViewCacheExtension</p><p>  开发者自定义的缓存</p></li><li><p>RecyclerViewPool</p><p>  缓存池，可以在多个RecyclerView中共享ViewHolder。通过setMaxRecycledViews设置对应type的ViewHolder的缓存池大小</p></li></ul><h3 id="获取VH流程"><a href="#获取VH流程" class="headerlink" title="获取VH流程"></a>获取VH流程</h3><p><img src="./RecyclerView_cache_level.png"></p><h3 id="RecyclerViewPool"><a href="#RecyclerViewPool" class="headerlink" title="RecyclerViewPool"></a>RecyclerViewPool</h3><p><strong>缓存池的用法：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linearLayoutManager = LinearLayoutManager(activity)</span><br><span class="line">linearLayoutManager.recycleChildrenOnDetach = <span class="literal">true</span></span><br><span class="line">recyclerView.layoutManager = linearLayoutManager</span><br><span class="line"><span class="comment">//设置缓存大小</span></span><br><span class="line">recycledViewPool.setMaxRecycledViews(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//共用缓存池</span></span><br><span class="line">recyclerView.setRecycledViewPool(recycledViewPool)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://phantomvk.github.io/2019/02/13/RecyclerView_cache/">https://phantomvk.github.io/2019/02/13/RecyclerView_cache/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h2 id=&quot;Recycler&quot;&gt;&lt;a href=&quot;#Recycler&quot; class=&quot;headerlink&quot; title=&quot;Recycler&quot;</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
    <category term="RecyclerView" scheme="http://shjlone.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之Adapter</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BAdapter/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BAdapter/</id>
    <published>2021-07-16T02:50:12.943Z</published>
    <updated>2021-07-16T09:33:44.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Adapter是RecyclerView的第一个内部类，将RecyclerView和视图关联起来。使用的是很方便的，只要继承它，重写几个方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建视图</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将视图跟当前位置的数据绑定</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回元素的个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//设置类型，用于缓存策略中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>视图模型中，我们只需要改变数据，并发送通知，系统会自动更新UI。</p><p>Adapter内部有一个AdapterDataObservable，继承自Java的Observable，使用观察者模式。RecyclerView中RecyclerViewDataObserver进行监听，<br>最终使用AdapterHelper进行操作。</p><ul><li>notifyItemChanged(int position) 更新列表position位置上的数据可以调用</li><li>notifyItemInserted(int position) 列表position位置添加一条数据时可以调用，伴有动画效果</li><li>notifyItemRemoved(int position) 列表position位置移除一条数据时调用，伴有动画效果</li><li>notifyItemMoved(int fromPosition, int toPosition) 列表fromPosition位置的数据移到toPosition位置时调用，伴有动画效果</li><li>notifyItemRangeChanged(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项进行数据刷新</li><li>notifyItemRangeInserted(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量添加数据时调用，伴有动画效果</li><li>notifyItemRangeRemoved(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量删除数据时调用，伴有动画效果</li><li>notifyDataSetChanged</li></ul><h2 id="ApaterHelper"><a href="#ApaterHelper" class="headerlink" title="ApaterHelper"></a>ApaterHelper</h2><p>管理和执行更新操作的帮助类，RecyclerView将每一次更新操作封装成了一个UpdateOp操作，然后通过AdapterHelper进行管理和执行。</p><p>当RecyclerView初始化时，会创建AdapterHelper，然后通过实现的dispatchUpdate方法，最终调用布局管理器进行元素的操作。</p><p>它内部有一个静态内部类UpdateOp，定义了相应的操作指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterHelper</span> <span class="keyword">implements</span> <span class="title">OpReorderer</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UpdateOp对象的回收和复用</span></span><br><span class="line"><span class="keyword">private</span> Pools.Pool&lt;UpdateOp&gt; mUpdateOpPool = <span class="keyword">new</span> Pools.SimplePool&lt;UpdateOp&gt;(UpdateOp.POOL_SIZE);</span><br><span class="line"><span class="comment">//将要执行的操作列表</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;UpdateOp&gt; mPendingUpdates = <span class="keyword">new</span> ArrayList&lt;UpdateOp&gt;();</span><br><span class="line"><span class="comment">//需要延迟执行的操作列表</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;UpdateOp&gt; mPostponedList = <span class="keyword">new</span> ArrayList&lt;UpdateOp&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//指令操作的记录器</span></span><br><span class="line"><span class="comment">// since move operations breaks continuity, their effects on ADD/RM are hard to handle.</span></span><br><span class="line"><span class="comment">// we push them to the end of the list so that they can be handled easily.</span></span><br><span class="line"><span class="keyword">final</span> OpReorderer mOpReorderer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateOp</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVE = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UPDATE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVE = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="preProcess"><a href="#preProcess" class="headerlink" title="preProcess"></a>preProcess</h3><p>当滑动RecyclerView等原因造成数据改变时，会触发到preProcess方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加到记录器中</span></span><br><span class="line">    mOpReorderer.reorderOps(mPendingUpdates);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mPendingUpdates.size();</span><br><span class="line">    <span class="comment">//将待处理队列中的指令进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        UpdateOp op = mPendingUpdates.get(i);</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.ADD:</span><br><span class="line">            <span class="comment">//通过回调到RecyclerView中，找到对应ViewHolder，修改相应数值，比如mPosition</span></span><br><span class="line">                applyAdd(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.REMOVE:</span><br><span class="line">                applyRemove(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.UPDATE:</span><br><span class="line">                applyUpdate(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.MOVE:</span><br><span class="line">                applyMove(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOnItemProcessedCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mOnItemProcessedCallback.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空列表</span></span><br><span class="line">    mPendingUpdates.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://fsilence.github.io/2020/05/15/RecyclerView-AdapterHelper">https://fsilence.github.io/2020/05/15/RecyclerView-AdapterHelper</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Adapter是RecyclerView的第一个内部类，将RecyclerView和视图关联起来。使用的是很方便的，只要继承它，重写几个方法</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
    <category term="RecyclerView" scheme="http://shjlone.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之ItemDecoration</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BItemDecoration/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BItemDecoration/</id>
    <published>2021-07-16T02:36:47.592Z</published>
    <updated>2021-07-16T02:50:12.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ItemDecoration用于在每个元素之间设置视图，比如分割线。它是一个抽象类，我们在使用过程中，只需要实现相应的方法，就能进行视图的大小设置，内容绘制。</p><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写绘制方法，画自己想要的内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(<span class="meta">@NonNull</span> Canvas c, <span class="meta">@NonNull</span> RecyclerView parent)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法会在onDraw后面执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawOver</span><span class="params">(<span class="meta">@NonNull</span> Canvas c, <span class="meta">@NonNull</span> RecyclerView parent,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">    onDrawOver(c, parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(<span class="meta">@NonNull</span> Rect outRect, <span class="meta">@NonNull</span> View view,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> RecyclerView parent, <span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">    getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),</span><br><span class="line">            parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/6a093bcc6b83">https://www.jianshu.com/p/6a093bcc6b83</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ItemDecoration用于在每个元素之间设置视图，比如分割线。它是一个抽象类，我们在使用过程中，只需要实现相应的方法，就能进行视图的大</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
    <category term="RecyclerView" scheme="http://shjlone.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之绘制流程</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8B%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8B%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</id>
    <published>2021-07-14T09:37:26.285Z</published>
    <updated>2021-07-16T09:40:16.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>先概括下onMeasure的大致流程：</p><ol><li>LayoutManager对象为空,RecyclerView不能显示任何的数据。</li><li>LayoutManager开启了自动测量时，在这种情况下，有可能会测量两次。</li><li>LayoutManager没有开启自动测量的情况，这种情况比较少，因为为了RecyclerView支持warp_content属性，系统提供的LayoutManager都开启自动测量的</li></ol><p>测量的状态保存在State中，有以下几种状态：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>State.STEP_START</td><td>mState.mLayoutStep 的默认值，这种情况下，表示 RecyclerView 还未经历 dispatchLayoutStep1，因为 dispatchLayoutStep1 调用之后mState.mLayoutStep 会变为 State.STEP_LAYOUT。</td></tr><tr><td>State.STEP_LAYOUT</td><td>当 mState.mLayoutStep 为 State.STEP_LAYOUT 时，表示此时处于 layout 阶段，这个阶段会调用 dispatchLayoutStep2 方法 layout RecyclerView 的children。调用 dispatchLayoutStep2 方法之后，此时 mState.mLayoutStep 变为了 State.STEP_ANIMATIONS。</td></tr><tr><td>State.STEP_ANIMATIONS</td><td>当 mState.mLayoutStep为 State.STEP_ANIMATIONS 时，表示 RecyclerView 处于第三个阶段，也就是执行动画的阶段，也就是调用 dispatchLayoutStep3方法。当 dispatchLayoutStep3 方法执行完毕之后，mState.mLayoutStep 又变为了 State.STEP_START。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当布局管理器为空时，进行默认的测量。RecyclerView不能显示任何的数据</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自动测量</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        </span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        <span class="comment">// 开始测量</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        </span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//测量的第二步，更新子布局</span></span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果rclerview没有精确的宽度和高度，并且至少有一个子View</span></span><br><span class="line">        <span class="comment">//子View也没有精确的宽度和高度，我们必须重新测量。</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//是否使用固定尺寸</span></span><br><span class="line">        <span class="keyword">if</span> (mHasFixedSize) &#123;</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">            processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">            setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 处理 Adapter 更新</span></span><br><span class="line"><span class="comment"> * - 决定执行哪一种动画</span></span><br><span class="line"><span class="comment"> * - 保存每个 ItemView 的信息</span></span><br><span class="line"><span class="comment"> * - 有必要的话，会进行预布局，并把相关信息保存下来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    fillRemainingScrollValues(mState);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    </span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    saveFocusInfo();</span><br><span class="line">    mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">    mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否预布局</span></span><br><span class="line">    mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 0: Find out where all non-removed items are, pre-layout</span></span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="comment">//根据当前的显示在界面上的ViewHolder的布局信息创建一个ItemHolderInfo</span></span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录当前的位置信息 Left、Right、Top、Bottom等</span></span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                            ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                            holder.getUnmodifiedPayloads());</span><br><span class="line">            <span class="comment">//把 holder对应的animationInfo保存到 mViewInfoStore中</span></span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">            <span class="keyword">if</span> (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">                    &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">                mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        saveOldPositions();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> didStructureChange = mState.mStructureChanged;</span><br><span class="line">        mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// temporarily disable flag because we are asking for previous layout</span></span><br><span class="line">        <span class="comment">//在layoutmanager中进行测量</span></span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        mState.mStructureChanged = didStructureChange;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mChildHelper.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class="line">            <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class="line">                <span class="keyword">boolean</span> wasHidden = viewHolder</span><br><span class="line">                        .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">                <span class="keyword">if</span> (!wasHidden) &#123;</span><br><span class="line">                    flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class="line">                        mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class="line">                <span class="keyword">if</span> (wasHidden) &#123;</span><br><span class="line">                    recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we don&#x27;t process disappearing list because they may re-appear in post layout pass.</span></span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二步，我们会真正的测量视图。</span></span><br><span class="line"><span class="comment"> * 这一步可能执行多次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    </span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();<span class="comment">//返回元素个数</span></span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> &amp;&amp; mAdapter.canRestoreState()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingSavedState.mLayoutState != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLayout.onRestoreInstanceState(mPendingSavedState.mLayoutState);</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    <span class="comment">// 更改此状态，确保不是会执行上一布局操作</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//LayoutManager中进行子视图测量</span></span><br><span class="line">    <span class="comment">//子视图的测量通用具体的布局管理器实现</span></span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>我们看看LinearLayoutManager是如何测量的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//布局算法</span></span><br><span class="line">    <span class="comment">// 1)通过检查子变量和其他变量，找到一个锚坐标和一个锚物品的位置。</span></span><br><span class="line">    <span class="comment">// 2)开始填充，从底部开始堆叠</span></span><br><span class="line">    <span class="comment">// 3)向底填充，从上往下堆叠</span></span><br><span class="line">    <span class="comment">// 4)从底部滚动以满足堆栈等需求。创建布局状态</span></span><br><span class="line">    <span class="comment">// 解决布局方向</span></span><br><span class="line">    resolveShouldLayoutReverse();</span><br><span class="line">    <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">    <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION</span><br><span class="line">            || mPendingSavedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">        <span class="comment">// calculate anchor position and coordinate</span></span><br><span class="line">        <span class="comment">// 计算锚点位置和坐标</span></span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">        mAnchorInfo.mValid = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">            &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">            || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">            &lt;= mOrientationHelper.getStartAfterPadding())) &#123;</span><br><span class="line">        <span class="comment">// This case relates to when the anchor child is the focused view and due to layout</span></span><br><span class="line">        <span class="comment">// shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows</span></span><br><span class="line">        <span class="comment">// up after tapping an EditText which shrinks RV causing the focused view (The tapped</span></span><br><span class="line">        <span class="comment">// EditText which is the anchor child) to get kicked out of the screen. Will update the</span></span><br><span class="line">        <span class="comment">// anchor coordinate in order to make sure that the focused view is laid out. Otherwise,</span></span><br><span class="line">        <span class="comment">// the available space in layoutState will be calculated as negative preventing the</span></span><br><span class="line">        <span class="comment">// focused view from being laid out in fill.</span></span><br><span class="line">        <span class="comment">// Note that we won&#x27;t update the anchor position between layout passes (refer to</span></span><br><span class="line">        <span class="comment">// TestResizingRelayoutWithAutoMeasure), which happens if we were to call</span></span><br><span class="line">        <span class="comment">// updateAnchorInfoForLayout for an anchor that&#x27;s not the focused view (e.g. a reference</span></span><br><span class="line">        <span class="comment">// child which can change between layout passes).</span></span><br><span class="line">        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtraFillSpace = extraForStart;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></span><br><span class="line"><span class="params"><span class="function">        RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            layoutChunkResult.resetInternal();</span><br><span class="line">            <span class="keyword">if</span> (RecyclerView.VERBOSE_TRACING) &#123;</span><br><span class="line">                TraceCompat.beginSection(<span class="string">&quot;LLM LayoutChunk&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填充item</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);      </span><br><span class="line">            </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 调用layoutState.next(recycler)获取View</span></span><br><span class="line"><span class="comment">2. addView</span></span><br><span class="line"><span class="comment">3. measureChildWithMargins进行子View测量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="params"><span class="function">        LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    </span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                    == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                <span class="comment">//添加item的视图</span></span><br><span class="line">                addView(view);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addView(view, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                addDisappearingView(view);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addDisappearingView(view, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 测量view</span></span><br><span class="line">        measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>流程图如下：</p><p><img src="./measure.png"></p><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个时候测量已经结束</span></span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        <span class="comment">//当还是测量初始状态时，走上面的测量流程</span></span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates()</span><br><span class="line">            || needsRemeasureDueToExactSkip</span><br><span class="line">            || mLayout.getWidth() != getWidth()</span><br><span class="line">            || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span></span><br><span class="line">        <span class="comment">// changed size.</span></span><br><span class="line">        <span class="comment">// 数据更新、改变尺寸后需要重新测量</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        <span class="comment">// 确保跟布局管理器同步</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">布局的最后一步，我们保存关于视图的动画信息，</span></span><br><span class="line"><span class="comment">触发动画并进行必要的清理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复默认值</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="comment">//如果有动画</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 3: Find out where things are now, and process change animations.</span></span><br><span class="line">        <span class="comment">// traverse list in reverse because we may call animateChange in the loop which may</span></span><br><span class="line">        <span class="comment">// remove the target view holder.</span></span><br><span class="line">        <span class="comment">// 遍历子元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mChildHelper.getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 拿到VH</span></span><br><span class="line">            ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPostLayoutInformation(mState, holder);</span><br><span class="line">            ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</span><br><span class="line">            <span class="keyword">if</span> (oldChangeViewHolder != <span class="keyword">null</span> &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="comment">// run a change animation</span></span><br><span class="line">    </span><br><span class="line">                <span class="comment">// If an Item is CHANGED but the updated version is disappearing, it creates</span></span><br><span class="line">                <span class="comment">// a conflicting case.</span></span><br><span class="line">                <span class="comment">// Since a view that is marked as disappearing is likely to be going out of</span></span><br><span class="line">                <span class="comment">// bounds, we run a change animation. Both views will be cleaned automatically</span></span><br><span class="line">                <span class="comment">// once their animations finish.</span></span><br><span class="line">                <span class="comment">// On the other hand, if it is the same view holder instance, we run a</span></span><br><span class="line">                <span class="comment">// disappearing animation instead because we are not going to rebind the updated</span></span><br><span class="line">                <span class="comment">// VH unless it is enforced by the layout manager.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> oldDisappearing = mViewInfoStore.isDisappearing(</span><br><span class="line">                        oldChangeViewHolder);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> newDisappearing = mViewInfoStore.isDisappearing(holder);</span><br><span class="line">                <span class="keyword">if</span> (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class="line">                    <span class="comment">// run disappear animation instead of change</span></span><br><span class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</span><br><span class="line">                            oldChangeViewHolder);</span><br><span class="line">                    <span class="comment">// we add and remove so that any post info is merged.</span></span><br><span class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                    ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);</span><br><span class="line">                    <span class="keyword">if</span> (preInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 添加新的视图</span></span><br><span class="line">                        <span class="comment">// 添加到ChildHelper上</span></span><br><span class="line">                        animateChange(oldChangeViewHolder, holder, preInfo, postInfo,</span><br><span class="line">                                oldDisappearing, newDisappearing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4: Process view info lists and trigger animations</span></span><br><span class="line">        <span class="comment">// 处理列表的视图信息和触发动画</span></span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class="line">    mState.mPreviousLayoutItemCount = mState.mItemCount;</span><br><span class="line">    mDataSetHasChangedAfterLayout = <span class="keyword">false</span>;</span><br><span class="line">    mDispatchItemsChangedEvent = <span class="keyword">false</span>;</span><br><span class="line">    mState.mRunSimpleAnimations = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    mState.mRunPredictiveAnimations = <span class="keyword">false</span>;</span><br><span class="line">    mLayout.mRequestedSimpleAnimations = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecycler.mChangedScrap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRecycler.mChangedScrap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class="line">        <span class="comment">// Initial prefetch has expanded cache, so reset until next prefetch.</span></span><br><span class="line">        <span class="comment">// This prevents initial prefetches from expanding the cache permanently.</span></span><br><span class="line">        mLayout.mPrefetchMaxCountObserved = <span class="number">0</span>;</span><br><span class="line">        mLayout.mPrefetchMaxObservedInInitialPrefetch = <span class="keyword">false</span>;</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回到布局管理器，同步状态</span></span><br><span class="line">    mLayout.onLayoutCompleted(mState);</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    <span class="keyword">if</span> (didChildRangeChange(mMinMaxLayoutPositions[<span class="number">0</span>], mMinMaxLayoutPositions[<span class="number">1</span>])) &#123;</span><br><span class="line">        dispatchOnScrolled(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    recoverFocusFromState();</span><br><span class="line">    resetFocusInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateChange</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder oldHolder, <span class="meta">@NonNull</span> ViewHolder newHolder,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> ItemHolderInfo preInfo, <span class="meta">@NonNull</span> ItemHolderInfo postInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> oldHolderDisappearing, <span class="keyword">boolean</span> newHolderDisappearing)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldHolder != newHolder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newHolderDisappearing) &#123;</span><br><span class="line">            addAnimatingView(newHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        oldHolder.mShadowedHolder = newHolder;</span><br><span class="line">        <span class="comment">// old holder should disappear after animation ends</span></span><br><span class="line">        <span class="comment">//添加视图到管理器</span></span><br><span class="line">        addAnimatingView(oldHolder);</span><br><span class="line">        mRecycler.unscrapView(oldHolder);</span><br><span class="line">        newHolder.setIsRecyclable(<span class="keyword">false</span>);</span><br><span class="line">        newHolder.mShadowingHolder = oldHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动动画</span></span><br><span class="line">    <span class="keyword">if</span> (mItemAnimator.animateChange(oldHolder, newHolder, preInfo, postInfo)) &#123;</span><br><span class="line">        postAnimationRunner();</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要的工作内容如下：</p><ol><li>检查状态，如果是STEP_START，则先测量；</li><li>数据、尺寸发生变化，则走dispatchLayoutStep2；</li><li>处理需要播放动画的数据</li><li>状态同步给布局管理器</li></ol><h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="comment">// 遍历隔间装饰列表，进行绘制。</span></span><br><span class="line">    <span class="comment">// 子视图在自己的onDraw中绘制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;绘制流程&quot;&gt;&lt;a href=&quot;#绘制流程&quot; class=&quot;headerlink&quot; title=&quot;绘制流程&quot;&gt;&lt;/a&gt;绘制流程&lt;/h2&gt;&lt;h3 id=&quot;onMeasure&quot;&gt;&lt;a href=&quot;#onMeasure&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
    <category term="RecyclerView" scheme="http://shjlone.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>自定义View之Paint</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BPaint/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BPaint/</id>
    <published>2021-07-14T03:08:46.576Z</published>
    <updated>2021-07-14T03:49:43.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="颜色设置"><a href="#颜色设置" class="headerlink" title="颜色设置"></a>颜色设置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">setColor(<span class="keyword">int</span> color)</span><br><span class="line"></span><br><span class="line">paint.setColor(Color.parseColor(<span class="string">&quot;#009688&quot;</span>));</span><br><span class="line">canvas.drawRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">230</span>, <span class="number">180</span>, paint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setARGB(<span class="keyword">int</span> a, <span class="keyword">int</span> r, <span class="keyword">int</span> g, <span class="keyword">int</span> b)</span><br><span class="line"></span><br><span class="line">paint.setARGB(<span class="number">100</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, paint);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Shader设置"><a href="#Shader设置" class="headerlink" title="Shader设置"></a>Shader设置</h3><p>在 Android 的绘制里使用 Shader ，并不直接用 Shader 这个类，而是用它的几个子类。具体来讲有：</p><ul><li>LinearGradient：线性渐变</li><li>RadialGradient：辐射渐变</li><li>SweepGradient：扫描渐变</li><li>BitmapShader</li><li>ComposeShader：混合着色器</li></ul><p>在设置了 Shader 的情况下， Paint.setColor/ARGB() 所设置的颜色就不再起作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shader shader = <span class="keyword">new</span> LinearGradient(<span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, Color.parseColor(<span class="string">&quot;#E91E63&quot;</span>),</span><br><span class="line">        Color.parseColor(<span class="string">&quot;#2196F3&quot;</span>), Shader.TileMode.CLAMP);</span><br><span class="line">paint.setShader(shader);</span><br><span class="line">...</span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.batman);</span><br><span class="line">Shader shader = <span class="keyword">new</span> BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class="line">paint.setShader(shader);</span><br><span class="line">...</span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个 Shader：头像的 Bitmap</span></span><br><span class="line">Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.batman);</span><br><span class="line">Shader shader1 = <span class="keyword">new</span> BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 Shader：从上到下的线性渐变（由透明到黑色）</span></span><br><span class="line">Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.batman_logo);</span><br><span class="line">Shader shader2 = <span class="keyword">new</span> BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComposeShader：结合两个 Shader</span></span><br><span class="line">Shader shader = <span class="keyword">new</span> ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER);</span><br><span class="line">paint.setShader(shader);</span><br><span class="line">...</span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>, paint);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PorterDuff.Mode 是用来指定两个图像共同绘制时的颜色策略的。它是一个 enum，不同的 Mode 可以指定不同的策略。参考：</p><p><a href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html">https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html</a></p><h3 id="颜色滤镜"><a href="#颜色滤镜" class="headerlink" title="颜色滤镜"></a>颜色滤镜</h3><ul><li>ColorFilter<ul><li>LightingColorFilter</li><li>PorterDuffColorFilter</li><li>ColorMatrixColorFilter</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">setColorFilter(ColorFilter colorFilter)</span><br><span class="line"></span><br><span class="line">ColorFilter lightingColorFilter = <span class="keyword">new</span> LightingColorFilter(<span class="number">0x00ffff</span>, <span class="number">0x000000</span>);</span><br><span class="line">paint.setColorFilter(lightingColorFilter);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="setXfermode"><a href="#setXfermode" class="headerlink" title="setXfermode"></a>setXfermode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置抗锯齿"><a href="#设置抗锯齿" class="headerlink" title="设置抗锯齿"></a>设置抗锯齿</h3><p>抗锯齿默认是关闭的，如果需要抗锯齿，需要显式地打开。另外，除了 setAntiAlias(aa) 方法，打开抗锯齿还有一个更方便的方式：构造方法。<br>创建 Paint 对象的时候，构造方法的参数里加一个 ANTI_ALIAS_FLAG 的 flag，就可以在初始化的时候就开启抗锯齿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">setAntiAlias (<span class="keyword">boolean</span> aa)</span><br><span class="line"></span><br><span class="line">Paint paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="setStyle"><a href="#setStyle" class="headerlink" title="setStyle"></a>setStyle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.FILL); <span class="comment">// FILL 模式，填充</span></span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.STROKE); <span class="comment">// STROKE 模式，画线</span></span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线条形状"><a href="#线条形状" class="headerlink" title="线条形状"></a>线条形状</h3><ul><li>setStrokeWidth(float width)</li><li>setStrokeCap(Paint.Cap cap)</li><li>setStrokeJoin(Paint.Join join)</li><li>setStrokeMiter(float miter)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">paint.setStrokeWidth(<span class="number">1</span>);</span><br><span class="line">canvas.drawCircle(<span class="number">150</span>, <span class="number">125</span>, <span class="number">100</span>, paint);</span><br><span class="line">paint.setStrokeWidth(<span class="number">5</span>);</span><br><span class="line">canvas.drawCircle(<span class="number">400</span>, <span class="number">125</span>, <span class="number">100</span>, paint);</span><br><span class="line">paint.setStrokeWidth(<span class="number">40</span>);</span><br><span class="line">canvas.drawCircle(<span class="number">650</span>, <span class="number">125</span>, <span class="number">100</span>, paint);</span><br></pre></td></tr></table></figure><h3 id="setStrokeCap"><a href="#setStrokeCap" class="headerlink" title="setStrokeCap"></a>setStrokeCap</h3><p>线头形状有三种：</p><ul><li>BUTT 平头（默认）</li><li>ROUND 圆头</li><li>SQUARE 方头。</li></ul><p><img src="./1.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="setStrokeJoin"><a href="#setStrokeJoin" class="headerlink" title="setStrokeJoin"></a>setStrokeJoin</h3><ul><li>MITER 尖角</li><li>BEVEL 平角</li><li>ROUND 圆角。</li></ul><p><img src="./2.jpg"></p><h3 id="setStrokeMiter"><a href="#setStrokeMiter" class="headerlink" title="setStrokeMiter"></a>setStrokeMiter</h3><p>这个方法是对于 setStrokeJoin() 的一个补充，它用于设置 MITER 型拐角的延长线的最大值。</p><h3 id="色彩优化"><a href="#色彩优化" class="headerlink" title="色彩优化"></a>色彩优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//设置图像的抖动</span></span><br><span class="line">setDither(<span class="keyword">boolean</span> dither)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置是否使用双线性过滤来绘制 Bitmap </span></span><br><span class="line">setFilterBitmap(<span class="keyword">boolean</span> filter)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="setPathEffect"><a href="#setPathEffect" class="headerlink" title="setPathEffect"></a>setPathEffect</h3><p>使用 PathEffect 来给图形的轮廓设置效果。对 Canvas 所有的图形绘制有效，也就是 drawLine() drawCircle() drawPath() 这些方法。</p><h3 id="CornerPathEffect"><a href="#CornerPathEffect" class="headerlink" title="CornerPathEffect"></a>CornerPathEffect</h3><p>把所有拐角变成圆角</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PathEffect pathEffect = <span class="keyword">new</span> CornerPathEffect(<span class="number">20</span>);</span><br><span class="line">paint.setPathEffect(pathEffect);</span><br><span class="line">...</span><br><span class="line">canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><h3 id="DiscretePathEffect"><a href="#DiscretePathEffect" class="headerlink" title="DiscretePathEffect"></a>DiscretePathEffect</h3><p>把线条进行随机的偏离，让轮廓变得乱七八糟。乱七八糟的方式和程度由参数决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PathEffect pathEffect = <span class="keyword">new</span> DiscretePathEffect(<span class="number">20</span>, <span class="number">5</span>);</span><br><span class="line">paint.setPathEffect(pathEffect);</span><br><span class="line">...</span><br><span class="line">canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><h3 id="绘制虚线"><a href="#绘制虚线" class="headerlink" title="绘制虚线"></a>绘制虚线</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用虚线来绘制线条。</span></span><br><span class="line">PathEffect pathEffect = <span class="keyword">new</span> DashPathEffect(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">10</span>&#125;, <span class="number">0</span>);</span><br><span class="line">paint.setPathEffect(pathEffect);</span><br><span class="line">...</span><br><span class="line">canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Path dashPath = ...; <span class="comment">// 使用一个三角形来做 dash</span></span><br><span class="line">PathEffect pathEffect = <span class="keyword">new</span> PathDashPathEffect(dashPath, <span class="number">40</span>, <span class="number">0</span>,</span><br><span class="line">        PathDashPathEffectStyle.TRANSLATE);</span><br><span class="line">paint.setPathEffect(pathEffect);</span><br><span class="line">...</span><br><span class="line">canvas.drawPath(path, paint);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SumPathEffect"><a href="#SumPathEffect" class="headerlink" title="SumPathEffect"></a>SumPathEffect</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PathEffect dashEffect = <span class="keyword">new</span> DashPathEffect(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">20</span>, <span class="number">10</span>&#125;, <span class="number">0</span>);</span><br><span class="line">PathEffect discreteEffect = <span class="keyword">new</span> DiscretePathEffect(<span class="number">20</span>, <span class="number">5</span>); </span><br><span class="line">pathEffect = <span class="keyword">new</span> SumPathEffect(dashEffect, discreteEffect);</span><br><span class="line">...</span><br><span class="line">canvas.drawPath(path, paint);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ComposePathEffect"><a href="#ComposePathEffect" class="headerlink" title="ComposePathEffect"></a>ComposePathEffect</h3><h3 id="setShadowLayer"><a href="#setShadowLayer" class="headerlink" title="setShadowLayer"></a>setShadowLayer</h3><p>在之后的绘制内容下面加一层阴影</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setShadowLayer(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, Color.RED);</span><br><span class="line">...</span><br><span class="line">canvas.drawText(text, <span class="number">80</span>, <span class="number">300</span>, paint);</span><br></pre></td></tr></table></figure><h3 id="setMaskFilter"><a href="#setMaskFilter" class="headerlink" title="setMaskFilter"></a>setMaskFilter</h3><p>为之后的绘制设置 MaskFilter。上一个方法 setShadowLayer() 是设置的在绘制层下方的附加效果；而这个 MaskFilter 和它相反，设置的是在绘制层上方的附加效果。</p><p>MaskFilter 有两种： BlurMaskFilter 和 EmbossMaskFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">50</span>, BlurMaskFilter.Blur.NORMAL));</span><br><span class="line">...</span><br><span class="line">canvas.drawBitmap(bitmap, <span class="number">100</span>, <span class="number">100</span>, paint);</span><br></pre></td></tr></table></figure><h3 id="文字相关"><a href="#文字相关" class="headerlink" title="文字相关"></a>文字相关</h3><h4 id="setTextSize"><a href="#setTextSize" class="headerlink" title="setTextSize"></a>setTextSize</h4><p>设置字体大小</p><h4 id="setTypeface"><a href="#setTypeface" class="headerlink" title="setTypeface"></a>setTypeface</h4><p>设置字体</p><h4 id="setFakeBoldText"><a href="#setFakeBoldText" class="headerlink" title="setFakeBoldText"></a>setFakeBoldText</h4><p>是否使用伪粗体</p><h4 id="setStrikeThruText"><a href="#setStrikeThruText" class="headerlink" title="setStrikeThruText"></a>setStrikeThruText</h4><p>是否加删除线</p><h4 id="setUnderlineText"><a href="#setUnderlineText" class="headerlink" title="setUnderlineText"></a>setUnderlineText</h4><p>是否加下划线</p><h4 id="setTextSkewX"><a href="#setTextSkewX" class="headerlink" title="setTextSkewX"></a>setTextSkewX</h4><p>设置文字横向错切角度</p><h4 id="setTextScaleX"><a href="#setTextScaleX" class="headerlink" title="setTextScaleX"></a>setTextScaleX</h4><p>设置文字横向放缩</p><h4 id="setLetterSpacing"><a href="#setLetterSpacing" class="headerlink" title="setLetterSpacing"></a>setLetterSpacing</h4><p>设置字符间距</p><h4 id="setFontFeatureSettings"><a href="#setFontFeatureSettings" class="headerlink" title="setFontFeatureSettings"></a>setFontFeatureSettings</h4><p>用 CSS 的 font-feature-settings 的方式来设置文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">paint.setFontFeatureSettings(<span class="string">&quot;smcp&quot;</span>); <span class="comment">// 设置 &quot;small caps&quot;</span></span><br><span class="line">canvas.drawText(<span class="string">&quot;Hello HenCoder&quot;</span>, <span class="number">100</span>, <span class="number">150</span>, paint);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="setTextAlign"><a href="#setTextAlign" class="headerlink" title="setTextAlign"></a>setTextAlign</h4><p>设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。</p><h4 id="setTextLocale"><a href="#setTextLocale" class="headerlink" title="setTextLocale"></a>setTextLocale</h4><p>设置绘制所使用的 Locale</p><h4 id="setHinting"><a href="#setHinting" class="headerlink" title="setHinting"></a>setHinting</h4><p>设置是否启用字体的 hinting （字体微调）</p><h4 id="getFontSpacing"><a href="#getFontSpacing" class="headerlink" title="getFontSpacing"></a>getFontSpacing</h4><p>获取推荐的行距</p><h4 id="getTextBounds"><a href="#getTextBounds" class="headerlink" title="getTextBounds"></a>getTextBounds</h4><p>获取文字的显示范围</p><h4 id="measureText"><a href="#measureText" class="headerlink" title="measureText"></a>measureText</h4><p>测量文字的宽度并返回</p><h4 id="getTextWidths"><a href="#getTextWidths" class="headerlink" title="getTextWidths"></a>getTextWidths</h4><p>getTextWidths(String text, float[] widths)</p><p>获取字符串中每个字符的宽度，并把结果填入参数 widths</p><h4 id="breakText"><a href="#breakText" class="headerlink" title="breakText"></a>breakText</h4><p>也是用来测量文字宽度的。但和 measureText() 的区别是， breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字。</p><h3 id="光标相关"><a href="#光标相关" class="headerlink" title="光标相关"></a>光标相关</h3><h4 id="getRunAdvance"><a href="#getRunAdvance" class="headerlink" title="getRunAdvance"></a>getRunAdvance</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">start end 是文字的起始和结束坐标；contextStart contextEnd 是上下文的起始和结束坐标；isRtl 是文字的方向；offset 是字数的偏移，即计算第几个字符处的光标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getRunAdvance(CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> contextStart, <span class="keyword">int</span> contextEnd, <span class="keyword">boolean</span> isRtl, <span class="keyword">int</span> offset)</span><br></pre></td></tr></table></figure><h4 id="getOffsetForAdvance"><a href="#getOffsetForAdvance" class="headerlink" title="getOffsetForAdvance"></a>getOffsetForAdvance</h4><p>给出一个位置的像素值，计算出文字中最接近这个位置的字符偏移量（即第几个字符最接近这个坐标）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">text 是要测量的文字；</span></span><br><span class="line"><span class="comment">start end 是文字的起始和结束坐标；</span></span><br><span class="line"><span class="comment">contextStart contextEnd 是上下文的起始和结束坐标；</span></span><br><span class="line"><span class="comment">isRtl 是文字方向；</span></span><br><span class="line"><span class="comment">advance 是给出的位置的像素值。填入参数，对应的字符偏移量将作为返回值返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getOffsetForAdvance(CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> contextStart, <span class="keyword">int</span> contextEnd, <span class="keyword">boolean</span> isRtl, <span class="keyword">float</span> advance)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://rengwuxian.com/ui-1-2/">https://rengwuxian.com/ui-1-2/</a></li><li><a href="https://rengwuxian.com/ui-1-3/">https://rengwuxian.com/ui-1-3/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;h3 id=&quot;颜色设置&quot;&gt;&lt;a href=&quot;#颜色设置&quot; class=&quot;headerlink&quot; title=&quot;颜色设置&quot;&gt;&lt;/a&gt;颜色设</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%88%86%E7%B1%BB/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%88%86%E7%B1%BB/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2021-07-13T12:54:32.918Z</published>
    <updated>2021-07-14T02:33:01.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p>开始的时候，为了实现一个服务器可以支持多个客户端连接，人们想出了fork/thread等办法，当一个连接来到的时候，就fork/thread一个进程/线程去接收并且处理请求。</p><p>到了80年代，计算机网络开始成型，越来越多的用户进行网络连接，但是之前的fork/thread模型在高并发场景快不行了。1983年，发明了select。</p><p>对应的编程模型就是：一个连接来了，就必须遍历所有已经注册的文件描述符，来找到那个需要处理信息的文件描述符，如果已经注册了几万个文件描述符，那会因为遍历这些<br>已经注册的文件描述符，导致cpu爆炸。</p><p>到2002年，epoll出现了，于Linux 2.5.44首度登场。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h3><p>操作系统的核心是内核，为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分。</p><p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节<br>（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><ul><li>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li><li>异步：异步就是发一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时可以处理其他的请求，被调用者通常依靠事件、<br>回调等机制来通知调用者其返回结果。</li></ul><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><ul><li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li>非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他的事情。</li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>File descriptor：表述指向文件的引用的抽象化概念。在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。<br>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><p>在实际编程中，不管是进行文件操作还是Socket编程，都是操作文件描述符。</p><h3 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h3><p>缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，<br>即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，<br>对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;</li><li>每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li><li>对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发）</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>它没有最大连接数的限制，但是同样有缺点：</p><ul><li>每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li><li>对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上<br>是<code>事件驱动（每个事件关联上fd）</code>的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/T-hP3wt4whtvVh1H1LBU3w">五种IO模型</a></li><li><a href="https://juejin.cn/post/6882984260672847879">彻底理解 IO 多路复用实现机制</a></li><li><a href="https://zh.wikipedia.org/wiki/Epoll">https://zh.wikipedia.org/wiki/Epoll</a></li><li><a href="https://baike.baidu.com/item/poll/3643578">https://baike.baidu.com/item/poll/3643578</a></li><li><a href="https://mp.weixin.qq.com/s/Ok7SIROXu1THUbWsFu-UYw">https://mp.weixin.qq.com/s/Ok7SIROXu1THUbWsFu-UYw</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;发展史&quot;&gt;&lt;a href=&quot;#发展史&quot; class=&quot;headerlink&quot; title=&quot;发展史&quot;&gt;&lt;/a&gt;发展史&lt;/h2&gt;&lt;p&gt;开始的时候，为了实现一个服务器可以支持多个客户端连接，人们想出了fork/thread等办法，当一个连接来到的时候，就fork/th</summary>
      
    
    
    
    <category term="操作系统" scheme="http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="未分类" scheme="http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="操作系统" scheme="http://shjlone.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="http://shjlone.github.io/wiki/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/HTTPS/"/>
    <id>http://shjlone.github.io/wiki/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/HTTPS/</id>
    <published>2021-07-12T03:53:35.199Z</published>
    <updated>2021-07-12T03:58:06.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="./https_1.png"></p><ol><li>Client发起一个HTTPS(比如 <a href="https://juejin.im/user">https://juejin.im/user</a> )的请求，根据RFC2818的规定，Client知道需要连接Server的443(默认)端口。</li><li>Server把事先配置好的公钥证书(public key certificate)返回给客户端。</li><li>Client验证公钥证书:比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，<br>直到验证到根证书(操作系统内置的Root证书或者Client内置的Root证书)。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li><li>Server使用自己的私钥(private key)解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li><li>Server使用对称密钥加密“明文内容A”，发送给Client。</li><li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li><li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥 解密密文，得到“明文内容B”。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工作流程&quot;&gt;&lt;a href=&quot;#工作流程&quot; class=&quot;headerlink&quot; title=&quot;工作流程&quot;&gt;&lt;/a&gt;工作流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;./https_1.png&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Client发起一个HTTPS(比如 &lt;a h</summary>
      
    
    
    
    <category term="网络编程" scheme="http://shjlone.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="服务端" scheme="http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>EventBus</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/EventBus/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/EventBus/</id>
    <published>2021-07-12T03:04:25.970Z</published>
    <updated>2021-07-12T03:06:28.952Z</updated>
    
    <content type="html"><![CDATA[<p>事件总线匡救啊，降低了代码的耦合性。</p><p><img src="./eventbus_1.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事件总线匡救啊，降低了代码的耦合性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./eventbus_1.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>复杂度定义</title>
    <link href="http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89/"/>
    <id>http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89/</id>
    <published>2021-07-12T02:47:27.953Z</published>
    <updated>2021-07-12T02:57:24.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变 化情况并确定T(n)的数量级。这里用”O”来表示数量级，<br>给出算法的时间复杂度。</p><blockquote><p>T(n)=O(f(n));</p></blockquote><p>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。</p><p>时间复杂度的分析方法:</p><ol><li>时间复杂度就是函数中基本操作所执行的次数</li><li>一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数</li><li>忽略掉常数项</li><li>关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数</li><li>计算时间复杂度是估算随着n的增长函数执行次数的增长趋势</li><li>递归算法的时间复杂度为:递归总次数 x 每次递归中基本操作所执行的次数</li></ol><p>常用的时间复杂度有以下七种，算法时间复杂度依次增加:</p><ul><li>O(1)常数型</li><li>O(log2 n)对数型</li><li>O(n) 线性型</li><li>O(n log2 n)二维型</li><li>O(n^2)平方型</li><li>O(n^3)立方型</li><li>O(2^n)指数型</li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级。</p><blockquote><p>S(n)=O(f(n)) </p></blockquote><p>若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1);</p><p>递归算法的空间复杂度:递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N).</p><h2 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h2><p>算法效率分析分为两种:第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度， 而空间效率被称作空间复杂度。时间复杂度主要衡量的是一个算法的运行速度，<br>而空间复杂度主 要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，<br>计算机的存储容量已经达到了很高的程度。 所以我们如今已经不需要再特别关注一个算法的空间复杂度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h2&gt;&lt;p&gt;一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变 化情况并确定T(n</summary>
      
    
    
    
    <category term="算法" scheme="http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PackageManagerService工作原理</title>
    <link href="http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/PackageManagerService%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/PackageManagerService%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-12T02:02:10.613Z</published>
    <updated>2021-07-12T02:02:21.226Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="进阶知识" scheme="http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>保活策略</title>
    <link href="http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E4%BF%9D%E6%B4%BB%E7%AD%96%E7%95%A5/"/>
    <id>http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E4%BF%9D%E6%B4%BB%E7%AD%96%E7%95%A5/</id>
    <published>2021-07-09T10:02:03.471Z</published>
    <updated>2021-07-16T03:55:28.956Z</updated>
    
    <content type="html"><![CDATA[<p>一个像素的Activity</p><p>前台service</p><p>进程间唤醒</p><p>JobSheduler</p><p>1559</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个像素的Activity&lt;/p&gt;
&lt;p&gt;前台service&lt;/p&gt;
&lt;p&gt;进程间唤醒&lt;/p&gt;
&lt;p&gt;JobSheduler&lt;/p&gt;
&lt;p&gt;1559&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="进阶知识" scheme="http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题收集</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/</id>
    <published>2021-07-09T09:55:45.628Z</published>
    <updated>2021-07-09T09:56:00.485Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Moosphan/Android-Daily-Interview">https://github.com/Moosphan/Android-Daily-Interview</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Moosphan/Android-Daily-Interview&quot;&gt;https://github.com/Moosphan/Android-Daily-Interview&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="未分类" scheme="http://shjlone.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>多渠道打包</title>
    <link href="http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    <id>http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/</id>
    <published>2021-07-09T09:27:28.413Z</published>
    <updated>2021-07-09T09:27:38.011Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="进阶知识" scheme="http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>代码混淆</title>
    <link href="http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</id>
    <published>2021-07-09T09:19:57.516Z</published>
    <updated>2021-07-09T09:20:08.903Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="进阶知识" scheme="http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AIDL</title>
    <link href="http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/AIDL/"/>
    <id>http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/AIDL/</id>
    <published>2021-07-09T07:32:41.727Z</published>
    <updated>2021-07-09T08:52:41.507Z</updated>
    
    <content type="html"><![CDATA[<p>Binder是一个工作在Linux层面的驱动，这 一段驱动运行在内核态。Binder本身又是一种架构，这种架构提供了服务端、Binder驱动和客户端三个模块。</p><p><img src="./aidl_1.png"></p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>Binder服务端实际上就是一个Binder类的对象，当我们创建一个Binder对象的时候，Binder内部就 会启动一个隐藏线程，该线程的主要作用就是接收Binder驱动发送<br>来的消息，那么Binder驱动为 什么会给Binder服务端的线程发送消息呢?原因很简单，我们在客户端调用服务端的时候并不能直接调用服务端相应的类和方法，<br>只能通过Binder驱动来调用。当服务端的隐藏线程收到Binder 驱动发来的消息之后，就会回调服务端的onTransact方法，我们来看看这个方法的方法头:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> code 指定客户端要调 用服务端的哪一个方法</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> data 客户端传来的参数</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> reply    表示服务端返回的参数</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> flags    表示客户端的调用是否有返回值，0表示服务端执行完成之后有返回值，1表示服务 端执行完后没有返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class MyAddBinder extends Binder </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> ADD:</span><br><span class="line">                data.enforceInterface(<span class="string">&quot;MyAddBinder&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> a = data.readInt();</span><br><span class="line">                <span class="keyword">int</span> b = data.readInt();</span><br><span class="line">                <span class="keyword">int</span> add = add(a, b);</span><br><span class="line">                reply.writeInt(add);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAddBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h2><p>Binder驱动是Binder服务端和Binder客户端之间连接的一个桥梁，当一个服务端Binder被创建出来的时候，系统同时会在Binder驱动中创建另外一个Binder对象，<br>当客户端想要访问远程的Binder服务端的时候，都是通过这个Binder对象来完成的。那么Binder驱动中的这个对象要怎么样获取呢?其实很简单，<br>这个BInder对象就是我们用绑定的方式启动一个Service服务时，在绑定成功时所获取的那个IBinder对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = bindService(intent, <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//这个service就是Binder驱动中创建的Binder对象</span></span><br><span class="line">               mRemote = service;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;, Service.BIND_AUTO_CREATE);                </span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>在客户端获取Binder驱动中的Binder对象，然后调用该对象中的 transact方法进行数据传递。客户端在向服务端发送消息的时候是以线程间通信的模式来进行的，<br>而且调用服务端代码是同步进行的，也就是说线程会阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//向服务端发送的数据</span></span><br><span class="line">Parcel data = Parcel.obtain();</span><br><span class="line"><span class="comment">//接收服务端返回的数据</span></span><br><span class="line">Parcel reply = Parcel.obtain();</span><br><span class="line">data.writeInterfaceToken(<span class="string">&quot;MyAddBinder&quot;</span>);</span><br><span class="line">data.writeInt(<span class="number">10</span>);</span><br><span class="line">data.writeInt(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mRemote.transact(code, data, reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> i = reply.readInt();</span><br><span class="line">    Log.d(<span class="string">&quot;google.sang&quot;</span>, <span class="string">&quot;add: &quot;</span> + i);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Binder是一个工作在Linux层面的驱动，这 一段驱动运行在内核态。Binder本身又是一种架构，这种架构提供了服务端、Binder驱动和客户端三个模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./aidl_1.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务端&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="进阶知识" scheme="http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
