{"meta":{"title":"Shjlone's Blog","subtitle":"Hello World","description":"Hello World","author":"shjlone","url":"http://shjlone.github.io"},"pages":[{"title":"","date":"2021-06-25T10:23:50.961Z","updated":"2021-06-25T10:23:50.961Z","comments":false,"path":"/404.html","permalink":"http://shjlone.github.io/404.html","excerpt":"","text":"Error 404 Not Found 您所访问的地址无法找到或者已经被删除了， 如果您是从搜索结果点击进来看到的 404，可以先尝试使用页面 右上方的搜索文章。 来都来了，就先逛逛嘛~~ 您可以访问 本站主页 ，或者联系我，吐槽下问题的详细情况， 也可以通过页面上方的 分类 或 标签 来查看本站已有的一些 tags。","raw":null,"content":null},{"title":"About","date":"2016-10-24T02:24:00.000Z","updated":"2021-06-10T13:08:10.262Z","comments":true,"path":"about/index.html","permalink":"http://shjlone.github.io/about/index.html","excerpt":"","text":"介绍一个一直以来比较菜的程序员!什么都懂一点，但貌似没一样精通的！o(╯□╰)o 关注IT技术，分享学到的知识，分享生活的乐趣。 此博客内容因博主见识、表达措辞、查阅资料有限、资料时效性变化等因素，内容不能保证完全正确或适合读者使用！！！ 此博客乃学习笔记，主要目的是方便自己检阅、巩固学习时的知识整理，其中错漏残缺不可避免，如果读者有任何新发现烦请留言，互勉学习而进步。 关于程序员的自我修养要想成为一名还行的程序员，需要学的东西真的不少。技术更新迭代的速度非常之快，怎么才能不在信息浪潮中落伍，我觉得还是要注重基础，下盘劳了，学什么都不费劲。而基础有哪些呢？ 计算机组成原理 操作系统原理 数据结构 算法 设计模式 网络原理 底层原理性的东西的变化速度是远远慢于应用层的技术迭代的，而应用层的技术很多都是依赖于这些底层技术的。所以，大家还是把这些东西都牢记于心吧！ 关于此博客的搭建我对自己写博客的需求： 使用方便，查阅方便； 容易构建、发布、分享； 博客展示能支持树状结构，方便知识体系的归类； 文章支持显示目录； 支持评论、统计等功能 最终选择使用hexo构建，主题来源于https://github.com/zthxxx/hexo-theme-Wikitten。这套主题基本满足了我的需求，在此感谢作者。 一些小东西 ActionScript3版本的Flappy Bird Alfred股票小助手 ： 用于快速查询实时股价 精选的Alfred的workflow Java设计模式代码整理 你可以在这里找到我： 豆瓣 Github 知乎 stackoverflow 力扣","raw":null,"content":null},{"title":"Categories","date":"2021-05-29T06:50:55.135Z","updated":"2021-05-29T06:50:55.135Z","comments":true,"path":"categories/index.html","permalink":"http://shjlone.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"Tags","date":"2021-05-29T06:50:55.136Z","updated":"2021-05-29T06:50:55.136Z","comments":true,"path":"tags/index.html","permalink":"http://shjlone.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Android系统架构","slug":"Android/Android系统架构","date":"2021-07-22T03:50:33.107Z","updated":"2021-07-22T08:10:13.225Z","comments":true,"path":"wiki/Android/Android系统架构/","link":"","permalink":"http://shjlone.github.io/wiki/Android/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","excerpt":"","text":"系统架构Linux内核层Linux Kernel：Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。 硬件抽象层Hardware Abstraction Layer：对Linux内核驱动程序的封装，向上提供接口，向下屏蔽了具体的实现细节。硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。 系统运行层Native C/C++ Libraries：系统运行层分为C/C++运行时库和Android运行时环境。 Android运行时环境在4.4以前使用的是Dalvik，之后使用ART。从5.0开始，正式废弃了Dalvik。 Dalvik什么是Dalvik？ Dalvik是用于Android平台的Java虚拟机 Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一 它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行 dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统 Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行 独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭 特点 Dalvik是依靠一个Just-In-Time(JIT编译)编译器去解释字节码 Dalvik虚拟机下运行Java时，要将字节码通过即时编译器（just in time ，JIT）转换为机器码（机器码才是能真正运行的），这会拖慢应用的运行效率 应用安装时，执行dexopt指令，将dex文件优化为odex文件 应用运行时，会将二进制翻译成机器码流程 Android RuntimeAndroid Runtime特点 应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用，这个过程叫做预编译（AOT,Ahead-Of-Time） 在移除解释代码这一过程后，应用程序执行将更有效率，启动更快 系统性能的显著提升 垃圾回收方面的优化 应用框架层Application Framework：应用框架层，提供了应用开发的核心功能。在实际开发中会使用里面的API。 名称 描述 Activity Manager(活动管理器) 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager(位置管理器) 提供地理位置以及定位功能服务 Package Manager(包管理器) 管理所有安装在Android系统中的应用程序 Notification Manager(通知管理器) 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager（资源管理器） 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager(电话管理器) 管理所有的移动设备功能 Window Manager（窗口管理器） 管理所有开启的窗口程序 Content Providers（内容提供器） 使得不同应用程序之间可以共享数据 View System（视图系统） 构建应用程序的基本组件 应用层System Apps：这里存放的是Android自带的一些App，比如：电话、短信、图库、拍摄等。 源码目录可以从 这里 在线阅读源码，也可以从 https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 下载源码。 以下是Android9的源码目录结构： art：全新的ART运行环境 dalvlkvm：dalvik 运行时代码 dex2oat： dexdump： dexlayout： disassembler： openjdk|vm： openjdk|jvmti： runtime： simulator：模拟器 tools： ahat：Android堆栈分析工具 amm：Actionable Memory Metric bionic：google自己开发的内核库，比GNU的内核更适合移动设备 apex： libc：对系统调用的封装 arch-arm： arch-arm64： arch-common： arch-x86： arch-x86_64： stdio：标准IO tools：一些python工具脚本 libdl： 用于动态库的装载 libm：数学库 upstream-freebsd：很多来自FreeBSD的函数库 libstdc++：标准的C++的功能库 linker：链接模块 tools： bootable：启动引导相关代码 recovery：这个目录用于创建恢复程序 build：存放系统编译规则及generic等基础开发包配置 bazel： blueprint： make： common： core：构建系统的核心目录 clang： combo：编译、编译设置 tasks： envsetup.sh target： board：构建目标设备的配置 product： 哪些apps需要编译 tools：编译过程中需要用到的工具 acp： aplcheck： atree： check_prereq： drolddoc： rbb2565： zipalign： pesto： soong： compatibility cts：Android兼容性测试套件标准 dalvik：dalvik虚拟机 dexdump： dexgen： dexlist： dx： opcode-gen： developers：开发者目录 build： demos： docs： samples： development：应用程序开发相关 apps：包含没有部署到系统到应用 BluetoothDebug： SdkSetup： build： tools：构建过程中需要用到的一些工具 cmds：包含monkey tool python-packages： host： windows：包含Windows版USB驱动 ide：包含对IDE一些配置信息 clion eclipse intellij sdk： scripts： tools： apkcheck：APK检查工具 axl：TCP、HTTP测试 elftree： idegen： emulator： bugreport： ndk： ota_analysis： otagui： winscope： monkey：模拟用户点击的测试工具 vendor_snapshot： vndk： device：设备相关配置 amlogic： common： generic：包含不同设备的配置信息 arm64： art： goldfish： goldfish-opengl： x86： google： google_car： linaro： mediatek： ti： external：开源模组相关文件，可以理解成第三方库的依赖 ImageMagick： FXdiv： OpenCL-CTS： aac： adhd： adt-infra： android-clat： androidplot： angle： antlr：http://www.antlr.org apache-commons-bcel： apache-commons-compress： apache-commons-math： apache-harmony： apache-http： apache-xml： auto： clang： bsdiff： chromium-libpac： chromium-trace： chromium-webview： cpuinfo： curl： dagger2： dexmaker： exoplayer： libogg： libopus： libcap： libpng： lzma： skia：http://code.google.com/p/skia/ v8：Javascript引擎 webp：http://code.google.com/speed/webp webrtc：http://www.webrtc.org frameworks：应用程序框架，Android系统核心部分，由Java和C++编写 av： camera： media：C实现系统媒体库 base： api： boot： cmds：重要命令 am： app_process： pm：包管理工具 config： data：包含字体文件、音频文件、视频文件等 location： media：多媒体相关库 java： jni： audioeffect： soundpool： mca： native： multidex： native：本地库 opengl：2D/3D 图形API sax：XML解析器 wifi：wifi无线网络 packages： BackupRestoreConfirmation： DefaultContainerService： SystemUI： Shell： VpnDialogs： compile： ex： hardware： layoutlib： libs： native： opengl：第三方图形渲染库 services： audiomanager： batteryservice： displayservice： gpuservice： inputflinger： surfaceflinger：图形显示库，主要负责图形的渲染、叠加和绘制等功能 sensorservice： vr： hardware：主要是硬件抽象层的代码 broadcom： google： libhardware： libhardware_legacy： nxp： samsung： st： kernel： libcore：核心库相关文件 api： dalvik： dom： json： xml： libnativehelper：动态库，实现JNI库的基础 packages：自带Apps应用程序包 apps：系统App Bluetooth： Calendar： Camera2： Dialer： Launcher3： inputmethods：输入法目录 modules： ArtPrebuilt: DnsResolver: DNS解析 Permission: 权限 adb：adb工具 providers：内容提供者目录 CalendarProvider: DownloadProvider: MediaProvider: TelephonyProvider: screensavers：屏幕保护 services：通信服务 AlternativeNetworkAccess： Telephony wallpapers：墙纸 pdk：Plug Development Kit 的缩写，本地开发套件 platform_testing：平台测试 prebuilts：x86和arm架构下预编译的一些资源 bazel： clang： devtools： gcc： go： gradle-plugin： jdk： python： mlsc： ndk： runtime： tools： common： darwln-x86： linux-x86： linux-x86_64： sdk：sdk和模拟器 annotations： apkbuilder：这个废弃了，推荐直接使用com.android.sdklib.build.ApkBuilder find_java： find_java2： sdklauncher： hierarchyviewer：视图查看器 system：底层文件系统库、应用和组件 apex： bpf： core： debuggerd： logcat： toolbox： watchdogd： extras： ANRdaemon： app-launcher： su： sound：播放wav文件工具 toolchain-extras： test： toolchain：工具链文件 tools：工具文件 参考 https://elinux.org/Master-android Android 虚拟机Art和Dalvik的区别 https://source.android.com/devices/tech/dalvik?hl=zh-cn Android 镜像使用帮助","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"RecyclerView之DiffUtil","slug":"Android/UI/RecyclerView之DiffUtil","date":"2021-07-21T08:27:06.467Z","updated":"2021-07-22T03:01:56.944Z","comments":true,"path":"wiki/Android/UI/RecyclerView之DiffUtil/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BDiffUtil/","excerpt":"","text":"概述使用DiffUtil的原因是替代notifyDataSetChanged，提升性能。 DiffUtil使用的是Eugene Myers的差别算法，这个算法本身不能检查到元素的移动，也就是移动只能被算作先删除、再增加，而DiffUtil是在算法的结果后再进行一次移动检查。假设在不检测元素移动的情况下，算法的时间复杂度为O(N + D2)，而检测元素移动则复杂度为O(N2)。所以，如果集合本身就已经排好序，可以不进行移动的检测提升效率。 ListAdapter和AsyncListDiffer中有使用。 使用123456789101112public void swap(List newList) &#123; MyDiffCallback callback = new MyDiffCallback(oldList, newList); DiffUtil.DiffResult result = DiffUtil.calculateDiff(callback); oldList.clear(); oldList.addAll(newList); result.dispatchUpdatesTo(this);&#125; 使用的步骤： 实现DiffUtil.Callback 调用calculateDiff计算不同点 dispatchUpdatesTo刷新数据 源码分析1234567891011121314151617181920212223242526272829303132333435363738public class DiffUtil &#123; // public static DiffResult calculateDiff(@NonNull Callback cb) &#123; return calculateDiff(cb, true); &#125; public abstract static class Callback &#123; // 旧数据集的长度 public abstract int getOldListSize(); // 新数据集的长度 public abstract int getNewListSize(); // 判断是否是同一个item public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition); // 如果item相同，此方法用于判断是否同一个Item的内容也相同 public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition); // 如果item相同，内容不同，用 payLoad 记录这个ViewHolder中具体需要更新那个View public Object getChangePayload(int oldItemPosition, int newItemPosition) &#123; return null; &#125; &#125; public static class DiffResult &#123; // 根据diff 数据结果，选择刷新方式 public void dispatchUpdatesTo(@NonNull ListUpdateCallback updateCallback) &#123;&#125; &#125;&#125; 过程如下： 实现DiffUtil.Callback接口 新老数据集通过DiffUtil.calculateDiff计算得到DiffUtil.DiffResult DiffUtil.DiffResult::dispatchUpdatesTo刷新数据 参考 RecyclerView中DiffUtil的一些注意事项 https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil https://github.com/mrmike/DiffUtil-sample","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"样式和主题","slug":"Android/基础/样式和主题","date":"2021-07-20T02:49:33.814Z","updated":"2021-07-20T11:53:59.748Z","comments":true,"path":"wiki/Android/基础/样式和主题/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/%E6%A0%B7%E5%BC%8F%E5%92%8C%E4%B8%BB%E9%A2%98/","excerpt":"","text":"概述样式是一个属性集合，用于指定单个 View 的外观。样式可以指定字体颜色、字号、背景颜色等属性。 主题背景是应用于整个应用、Activity 或视图层次结构，而非仅仅应用于单个视图的属性集合。当您应用主题背景时，应用或 Activity 中的每个视图都会应用其支持的每个主题背景属性。主题还可以将样式应用于非视图元素，例如状态栏和窗口背景。主题可以理解成样式的集合。 样式定义样式1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encodeing=&quot;utf-8&quot;?&gt;&lt;resource&gt; &lt;style name=&quot;BaseToolBarLine&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;match_parent&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;1px&lt;/item&gt; &lt;item name=&quot;android:background&quot;&gt;@color/base_toolbar_line_color&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;CodeFontRed&quot; parent=&quot;CodeFont&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt; &lt;/style&gt; &lt;!-- 样式是可以继承的 --&gt; &lt;style name=&quot;CodeFont.Red&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt; &lt;/style&gt;&lt;/resource&gt; 在布局文件中使用样式 1&lt;View style=&quot;@style/BaseToolBarLine&quot; /&gt; 如果有多个module，需要注意样式的继承，以免出现，子module修改了某个同名的style，造成父module中的样式被修改。 主题Android的主题发展历史 在Android3.0之前，Android的界面不论是从系统还是空间的主题都是按钮为白色，点击事件为黄色。现在看来很简陋 Holo主题：Android3.0 （API11）开始，Google推出了Holo主题（就是我们印象中的黑底白字蓝主色的主题）。在4.0google又发布了应用设计规范Android Design。有了设计规范的指导，就有了更多的应用采用Holo主题。所以我们可以简单认为Android Design就是Holo主题。但是这种主题是适合移动设备，其他平台略显突兀。 在4.0之前Android可以说是没有设计可言的，在4.0之后推出了Android Design，从此Android在设计上有了很大的改善，而在程序实现上相应的就是Holo风格，所以你看到有类似 Theme.Holo.Light、 Theme.Holo.Light.DarkActionBar 就是4.0的设计风格，但是为了让4.0之前的版本也能有这种风格怎么办呢？这个时候就不得不引用v7包了，所以对应的就有 Theme.AppCompat.Light、Theme.AppCompat.Light.DarkActionBar，如果你的程序最小支持的版本是API14（即Android 4.0），那么可以不用考虑v7的兼容 Material 主题：从Android5.0（API21）开始，Google又推出了材料设计语言Material Design，又叫Google Design。MD崇尚的就是图层扁平化，所有图层像纸或者卡片一样重叠在一起，所以Android5.0就有了RecyclerView和CardView。图层之间有间隔，所以Android5.0中有了translation和elevation两个属性。同时也规范了Android的运动元素，界面上的每个元素不是无故产生的，同时每个图层的产生和消失都有方向的约定，从哪里来就往哪里去，这也是为什么Android 5.0中会有Ripple，Circular Receal，Activity Transition Android在5.0版本推出了Material Design的概念，这是Android设计上又一大突破。对应的程序实现上就有Theme.Material.Light、Theme.Material.Light.DarkActionBar等，但是这种风格只能应用在在5.0版本的手机，如果在5.0之前应用Material Design该怎么办呢？同样的引用appcompat-v7包，这个时候的Theme.AppCompat.Light、Theme.AppCompat.Light.DarkActionBar就是相对应兼容的Material Design的Theme。 主题也跟样式一样是可以继承的，主题的根在themes.xml文件中。定义了&lt;style name=&quot;Theme&quot;&gt;&lt;/style&gt;。 1234567891011121314151617181920&lt;style name=&quot;Theme&quot;&gt;&lt;/style&gt;&lt;!-- 黑色背景--&gt;&lt;style name=&quot;Theme.Black&quot;&gt; &lt;item name=&quot;windowBackground&quot;&gt;@color/black&lt;/item&gt; &lt;item name=&quot;colorBackground&quot;&gt;@color/black&lt;/item&gt;&lt;/style&gt;&lt;!-- 没有标题 --&gt;&lt;style name=&quot;Theme.Black.NoTitleBar&quot;&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt;&lt;!--兼容主题的根主题 --&gt;&lt;style name=&quot;Theme.AppCompat&quot; parent=&quot;Base.Theme.AppCompat&quot;/&gt;&lt;style name=&quot;Theme.AppCompat.Dialog&quot; parent=&quot;Base.Theme.AppCompat.Dialog&quot;/&gt;&lt;!-- 没有actionbar --&gt;&lt;style name=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- 这里是AppCompat定义的属性，另外还有android:windowNoTitle属性 --&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 常用属性12345678910111213&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt; Dialog的windowFrame框为无&lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt; 是否浮现在activity之上&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;false&lt;/item&gt; 是否半透明&lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; 是否显示title&lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/dia_bg&lt;/item&gt; 设置背景&lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt; 背景是否变暗&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/AnimBottom&lt;/item&gt; 窗口的动画设置&lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; 这个drawable会覆盖在content区域的上面&lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt; Dialog弹窗漂浮 参考 样式和主题背景 Android中主题知识","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"RecyclerView之ItemAnimator","slug":"Android/UI/RecyclerView之ItemAnimator","date":"2021-07-16T09:09:13.556Z","updated":"2021-07-20T06:53:02.411Z","comments":true,"path":"wiki/Android/UI/RecyclerView之ItemAnimator/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BItemAnimator/","excerpt":"","text":"基本用法ItemAnimator用于对每一个元素进行动画控制，Android中默认的实现为DefaultItemAnimator。在DefaultItemAnimator的删除动画中，会对被删除的子视图执行透明度1-0的动画，动画结束后，会删除子视图和回收ViewHolder。 123recyclerView.setItemAnimator(new DefaultItemAnimator());//默认实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public abstract static class ItemAnimator &#123; //表示ViewHolder已经更新 public static final int FLAG_CHANGED = ViewHolder.FLAG_UPDATE; //表示ViewHolder已经被移除 public static final int FLAG_REMOVED = ViewHolder.FLAG_REMOVED; //notifyDataSetChanged已经被调用，ViewHolder已经失效 public static final int FLAG_INVALIDATED = ViewHolder.FLAG_INVALID; //ViewHolder已经移动 public static final int FLAG_MOVED = ViewHolder.FLAG_MOVED; private ItemAnimatorListener mListener = null;//回调监听器 //监听器列表 private ArrayList&lt;ItemAnimatorFinishedListener&gt; mFinishedListeners = new ArrayList&lt;ItemAnimatorFinishedListener&gt;(); //Item移除回调 public boolean animateRemove(RecyclerView.ViewHolder holder) &#123; return false; &#125; //Item添加回调 public boolean animateAdd(RecyclerView.ViewHolder holder) &#123; return false; &#125; //用于控制添加，移动更新时，其它Item的动画执行 public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123; return false; &#125; //Item更新回调，在显式调用notifyItemChanged()或notifyDataSetChanged()时被调用 public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) &#123; return false; &#125; // 真正控制执行动画的地方 // RecyclerView动画的执行方式并不是立即执行，而是每帧执行一次，比如两帧之间添加了多个Item，则会将这些将要执行的动画Pending住， // 保存在成员变量中，等到下一帧一起执行。该方法执行的前提是前面animateXxx()返回true。 public void runPendingAnimations() &#123; &#125; //停止某个Item的动画 public void endAnimation(RecyclerView.ViewHolder item) &#123; &#125; //停止所有动画 public void endAnimations() &#123; &#125; //是否有Item在运行 public boolean isRunning() &#123; return false; &#125; //当ViewHolder出现在屏幕上时被调用 public abstract boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo); //当ViewHolder消失在屏幕上时被调用 public abstract boolean animateDisappearance(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @Nullable ItemHolderInfo postLayoutInfo); //在没调用notifyItemChanged()和notifyDataSetChanged()的情况下布局发生改变时被调用 public abstract boolean animatePersistence(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo); &#125; DefaultItemAnimator这是RecyclerView的默认实现，删除动画中，会对被删除的子视图执行透明度1-0的动画，动画结束后，会删除子视图和回收ViewHolder。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164public class DefaultItemAnimator extends SimpleItemAnimator &#123; private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingRemovals = new ArrayList&lt;&gt;();//存放下一帧要执行的一系列add动画 private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingAdditions = new ArrayList&lt;&gt;();//存放正在执行的一批add动画 private ArrayList&lt;MoveInfo&gt; mPendingMoves = new ArrayList&lt;&gt;(); private ArrayList&lt;ChangeInfo&gt; mPendingChanges = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&lt;RecyclerView.ViewHolder&gt;&gt; mAdditionsList = new ArrayList&lt;&gt;();//存放当前正在执行的add动画 ArrayList&lt;ArrayList&lt;MoveInfo&gt;&gt; mMovesList = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&lt;ChangeInfo&gt;&gt; mChangesList = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mAddAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mMoveAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mRemoveAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mChangeAnimations = new ArrayList&lt;&gt;(); // 添加动画 @Override public boolean animateAdd(final RecyclerView.ViewHolder holder) &#123; //重置动画，设置默认差值器 resetAnimation(holder); //设置默认状态，透明度为0 holder.itemView.setAlpha(0); //添加到待执行列表中 mPendingAdditions.add(holder); return true; &#125; //fromX、fromY表示起始值 //toX、toY表示目标值 @Override public boolean animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123; final View view = holder.itemView; //计算出未执行的值 fromX += (int) holder.itemView.getTranslationX(); fromY += (int) holder.itemView.getTranslationY(); resetAnimation(holder); int deltaX = toX - fromX; int deltaY = toY - fromY; if (deltaX == 0 &amp;&amp; deltaY == 0) &#123; dispatchMoveFinished(holder); return false; &#125; //把Item位移到未操作前的现位置 if (deltaX != 0) &#123; view.setTranslationX(-deltaX); &#125; if (deltaY != 0) &#123; view.setTranslationY(-deltaY); &#125; mPendingMoves.add(new MoveInfo(holder, fromX, fromY, toX, toY)); return true; &#125; @Override public void runPendingAnimations() &#123; boolean removalsPending = !mPendingRemovals.isEmpty();//判断移除队列是否为空 boolean movesPending = !mPendingMoves.isEmpty(); boolean changesPending = !mPendingChanges.isEmpty(); boolean additionsPending = !mPendingAdditions.isEmpty(); //如果都为空，则执行返回 if (!removalsPending &amp;&amp; !movesPending &amp;&amp; !additionsPending &amp;&amp; !changesPending) &#123; // nothing to animate return; &#125; // First, remove stuff // 先执行移除队列 for (RecyclerView.ViewHolder holder : mPendingRemovals) &#123; animateRemoveImpl(holder); &#125; mPendingRemovals.clear(); // Next, move stuff // 执行移动队列 if (movesPending) &#123; final ArrayList&lt;MoveInfo&gt; moves = new ArrayList&lt;&gt;(); moves.addAll(mPendingMoves); mMovesList.add(moves); mPendingMoves.clear(); Runnable mover = new Runnable() &#123; @Override public void run() &#123; for (MoveInfo moveInfo : moves) &#123; animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY, moveInfo.toX, moveInfo.toY); &#125; moves.clear(); mMovesList.remove(moves); &#125; &#125;; //是否需要删除动画 if (removalsPending) &#123; View view = moves.get(0).holder.itemView; ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());//等待删除动画结束 &#125; else &#123; mover.run(); &#125; &#125; // Next, change stuff, to run in parallel with move animations // if (changesPending) &#123; final ArrayList&lt;ChangeInfo&gt; changes = new ArrayList&lt;&gt;(); changes.addAll(mPendingChanges); mChangesList.add(changes); mPendingChanges.clear(); Runnable changer = new Runnable() &#123; @Override public void run() &#123; for (ChangeInfo change : changes) &#123; animateChangeImpl(change); &#125; changes.clear(); mChangesList.remove(changes); &#125; &#125;; if (removalsPending) &#123; RecyclerView.ViewHolder holder = changes.get(0).oldHolder; ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration()); &#125; else &#123; changer.run(); &#125; &#125; // Next, add stuff // 添加动画 if (additionsPending) &#123; final ArrayList&lt;RecyclerView.ViewHolder&gt; additions = new ArrayList&lt;&gt;(); additions.addAll(mPendingAdditions); mAdditionsList.add(additions); mPendingAdditions.clear(); Runnable adder = new Runnable() &#123; @Override public void run() &#123; for (RecyclerView.ViewHolder holder : additions) &#123; animateAddImpl(holder); &#125; additions.clear(); mAdditionsList.remove(additions); &#125; &#125;; if (removalsPending || movesPending || changesPending) &#123; long removeDuration = removalsPending ? getRemoveDuration() : 0; long moveDuration = movesPending ? getMoveDuration() : 0; long changeDuration = changesPending ? getChangeDuration() : 0; long totalDelay = removeDuration + Math.max(moveDuration, changeDuration); View view = additions.get(0).itemView; ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); &#125; else &#123; adder.run(); &#125; &#125; &#125; @Override public boolean animateRemove(final RecyclerView.ViewHolder holder) &#123; //清除、移除Item resetAnimation(holder); //将ViewHolder添加到待移除队列 mPendingRemovals.add(holder); return true; &#125;&#125; 源码流程 自定义ItemAnimator参考 https://www.jianshu.com/p/7171ea362513","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"RecyclerView之SnapHelper","slug":"Android/UI/RecyclerView之SnapHelper","date":"2021-07-16T06:31:42.216Z","updated":"2021-07-16T08:37:02.982Z","comments":true,"path":"wiki/Android/UI/RecyclerView之SnapHelper/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BSnapHelper/","excerpt":"","text":"概要SnapHelper用于辅助RecyclerView在滚动结束时将Item对齐到某个位置。能让RecyclerView实现类似ViewPager等功能。 RecyclerView描述滚动状态的几个属性： SCROLL_STATE_IDLE：滚动闲置状态，此时并没有手指滑动或者动画执行 SCROLL_STATE_DRAGGING：滚动拖拽状态，由于用户触摸屏幕产生 SCROLL_STATE_SETTLING：自动滚动状态，此时没有手指触摸，一般是由动画执行滚动到最终位置，包括smoothScrollTo等方法的调用 当手指在屏幕上滑动RecyclerView然后松手，RecyclerView中的内容会顺着惯性继续往手指滑动的方向继续滚动直到停止，这个过程叫做Fling。 Fling当触发MotionEvent.ACTION_UP时，RecyclerView会进行fling判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public boolean fling(int velocityX, int velocityY) &#123; if (mLayout == null) &#123; Log.e(TAG, &quot;Cannot fling without a LayoutManager set. &quot; + &quot;Call setLayoutManager with a non-null argument.&quot;); return false; &#125; if (mLayoutFrozen) &#123; return false; &#125; final boolean canScrollHorizontal = mLayout.canScrollHorizontally(); final boolean canScrollVertical = mLayout.canScrollVertically(); if (!canScrollHorizontal || Math.abs(velocityX) &lt; mMinFlingVelocity) &#123; velocityX = 0; &#125; if (!canScrollVertical || Math.abs(velocityY) &lt; mMinFlingVelocity) &#123; velocityY = 0; &#125; if (velocityX == 0 &amp;&amp; velocityY == 0) &#123; // If we don&#x27;t have any velocity, return false return false; &#125; //处理嵌套滚动PreFling if (!dispatchNestedPreFling(velocityX, velocityY)) &#123; final View firstChild = mLayout.getChildAt(0); final View lastChild = mLayout.getChildAt(mLayout.getChildCount() - 1); boolean consumed = false; if (velocityY &lt; 0) &#123; consumed = getChildAdapterPosition(firstChild) &gt; 0 || firstChild.getTop() &lt; getPaddingTop(); &#125; if (velocityY &gt; 0) &#123; consumed = getChildAdapterPosition(lastChild) &lt; mAdapter.getItemCount() - 1 || lastChild.getBottom() &gt; getHeight() - getPaddingBottom(); &#125; dispatchNestedFling(velocityX, velocityY, consumed); //通过setOnFlingListener设置mOnFlingListener，由用户来判断是否属性自己定义fling行为 //默认的实现有LinearSnapHelper、PagerSnapHelper if (mOnFlingListener != null &amp;&amp; mOnFlingListener.onFling(velocityX, velocityY)) &#123; return true; &#125; final boolean canScroll = canScrollHorizontal || canScrollVertical; if (canScroll) &#123; velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity)); velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity)); /默认的Fling操作，最终到OverScroller计算滚动相关的值 mViewFlinger.fling(velocityX, velocityY); return true; &#125; &#125; return false;&#125; 由源码可知，会来到SnapHelper进行判断。 SnapHelperSnapHelper是一个抽象类，具体实现有LinearSnapHelper、PagerSnapHelper。 123456789101112131415161718192021222324/**会计算第二个参数对应的ItemView当前的坐标与需要对齐的坐标之间的距离。该方法返回一个大小为2的int数组，分别对应x轴和y轴方向上的距离。*/public abstract int[] calculateDistanceToFinalSnap(@NonNull RecyclerView.LayoutManager layoutManager, @NonNull View targetView);/**会找到当前layoutManager上最接近对齐位置的那个view，该view称为SanpView，对应的position称为SnapPosition。如果返回null，就表示没有需要对齐的View，也就不会做滚动对齐调整。*/public abstract View findSnapView(RecyclerView.LayoutManager layoutManager);/**会根据触发Fling操作的速率（参数velocityX和参数velocityY）来找到RecyclerView需要滚动到哪个位置，该位置对应的ItemView就是那个需要进行对齐的列表项。我们把这个位置称为targetSnapPosition，对应的View称为targetSnapView。如果找不到targetSnapPosition，就返回RecyclerView.NO_POSITION*/public abstract int findTargetSnapPosition(RecyclerView.LayoutManager layoutManager, int velocityX, int velocityY); 通过下面的代码，注册到RecyclerView中，可以实现相应的效果。 12345//滚动停止时相应的Item停留中间位置new LinearSnapHelper().attachToRecyclerView(mRecyclerView);//类似ViewPage效果new PagerSnapHelper().attachToRecyclerView(mRecyclerView); 来看看LinearSnapHelper的源码 依附RecyclerView流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public void attachToRecyclerView(@Nullable RecyclerView recyclerView) throws IllegalStateException &#123; //如果SnapHelper之前已经附着到此RecyclerView上，不用进行任何操作 if (mRecyclerView == recyclerView) &#123; return; // nothing to do &#125; //如果SnapHelper之前附着的RecyclerView和现在的不一致，清理掉之前RecyclerView的回调 if (mRecyclerView != null) &#123; destroyCallbacks(); &#125; mRecyclerView = recyclerView; if (mRecyclerView != null) &#123; //设置当前RecyclerView对象的回调 setupCallbacks(); //创建一个Scroller对象，用于辅助计算fling的总距离 mGravityScroller = new Scroller(mRecyclerView.getContext(), new DecelerateInterpolator()); //调用snapToTargetExistingView()方法以实现对SnapView的对齐滚动处理 snapToTargetExistingView(); &#125;&#125;private void setupCallbacks() throws IllegalStateException &#123; if (mRecyclerView.getOnFlingListener() != null) &#123; throw new IllegalStateException(&quot;An instance of OnFlingListener already set.&quot;); &#125; //注册滚动监听器 mRecyclerView.addOnScrollListener(mScrollListener); //注册自己 mRecyclerView.setOnFlingListener(this);&#125;// Handles the snap on scroll case.private final RecyclerView.OnScrollListener mScrollListener = new RecyclerView.OnScrollListener() &#123; boolean mScrolled = false; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mScrolled) &#123; mScrolled = false; //对targetView进行滚动调整，以确保停止的位置是在对应的坐标上，这就是RecyclerView添加该OnScrollListener的目的 snapToTargetExistingView(); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; if (dx != 0 || dy != 0) &#123; mScrolled = true; &#125; &#125; &#125;;void snapToTargetExistingView() &#123; if (mRecyclerView == null) &#123; return; &#125; RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager == null) &#123; return; &#125; //找出SnapView View snapView = findSnapView(layoutManager); if (snapView == null) &#123; return; &#125; //计算出SnapView需要滚动的距离 int[] snapDistance = calculateDistanceToFinalSnap(layoutManager, snapView); //如果需要滚动的距离不是为0，就调用smoothScrollBy（）使RecyclerView滚动相应的距离 if (snapDistance[0] != 0 || snapDistance[1] != 0) &#123; mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]); &#125;&#125; onFling在RecyclerView中的fling方法中，如果依附来LinearSnapHelper，会调用LinearSnapHelper的onFling方法进行判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean onFling(int velocityX, int velocityY) &#123; RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager == null) &#123; return false; &#125; RecyclerView.Adapter adapter = mRecyclerView.getAdapter(); if (adapter == null) &#123; return false; &#125; //获取RecyclerView要进行fling操作需要的最小速率， //只有超过该速率，ItemView才会有足够的动力在手指离开屏幕时继续滚动下去 int minFlingVelocity = mRecyclerView.getMinFlingVelocity(); //snapFromFling()这个方法，就是通过该方法实现平滑滚动并使得在滚动停止时itemView对齐到目的坐标位置 return (Math.abs(velocityY) &gt; minFlingVelocity || Math.abs(velocityX) &gt; minFlingVelocity) &amp;&amp; snapFromFling(layoutManager, velocityX, velocityY); &#125;private boolean snapFromFling(@NonNull RecyclerView.LayoutManager layoutManager, int velocityX, int velocityY) &#123; //layoutManager必须实现ScrollVectorProvider接口才能继续往下操作 if (!(layoutManager instanceof RecyclerView.SmoothScroller.ScrollVectorProvider)) &#123; return false; &#125; //创建SmoothScroller对象，是一个平滑滚动器，用于对ItemView进行平滑滚动操作 //根据速率计算滑动距离 RecyclerView.SmoothScroller smoothScroller = createScroller(layoutManager); if (smoothScroller == null) &#123; return false; &#125; //通过findTargetSnapPosition()方法，以layoutManager和速率作为参数，找到targetSnapPosition int targetPosition = findTargetSnapPosition(layoutManager, velocityX, velocityY); if (targetPosition == RecyclerView.NO_POSITION) &#123; return false; &#125; //通过setTargetPosition()方法设置滚动器的滚动目标位置 smoothScroller.setTargetPosition(targetPosition); //利用layoutManager启动平滑滚动器，开始滚动到目标位置 layoutManager.startSmoothScroll(smoothScroller); return true;&#125; 总结 使用时使用attachToRecyclerView添加依附 onFling操作触发的时候首先通过findTargetSnapPosition找到最终需要滚动到的位置，然后启动平滑滚动器滚动到指定位置， 在指定位置找出来后，系统会回调onTargetFound,然后调用calculateDistanceToFinalSnap方法计算targetView需要减速滚动的距离，然后通过Action更新给滚动器。 在滚动停止的时候，也就是state变成SCROLL_STATE_IDLE时会调用snapToTargetExistingView，通过findSnapView找到SnapView，然后通过calculateDistanceToFinalSnap计算得到滚动的距离，做最后的对齐调整。 参考 https://www.jianshu.com/p/e54db232df62 https://github.com/rubensousa/GravitySnapHelper","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"RecyclerView之缓存策略","slug":"Android/UI/RecyclerView之缓存策略","date":"2021-07-16T03:52:57.582Z","updated":"2021-07-20T09:33:51.440Z","comments":true,"path":"wiki/Android/UI/RecyclerView之缓存策略/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8B%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/","excerpt":"","text":"概述Recycler12345678910111213141516171819202122232425262728293031323334353637383940public final class Recycler &#123; // 未与RecyclerView分离的ViewHolder列表 // 如果仍依赖于 RecyclerView （比如已经滑动出可视范围，但还没有被移除掉），但已经被标记移除的 ItemView 集合会被添加到 mAttachedScrap 中 final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; // 缓存池，业务场景中可复用的ViewHolder可以存储进来 RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2; // 将view对应的ViewHolder移动到mCachedViews中；如果View是scrapped状态，会先unscrap public void recycleView(@NonNull View view) &#123;&#125; // 从mChangedScrap、mAttachedScrap、mCachedViews、ViewCacheExtension、RecycledViewPool中进行匹配；若匹配不了， // 最后会直接调用Adapter.createViewHolder方法进行创建 ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; &#125; //从 attach scrap、hidden children 、 cache中，根据 position 返回 ViewHolder ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123; &#125;&#125; 缓存类型 mAttachedScrap、mChangedScrap mAttachedScrap保存依附于 RecyclerView 的 ViewHolder。包含移出屏幕但未从 RecyclerView 移除的 ViewHolder。 mChangedScrap 保存数据发生改变的 ViewHolder，即调用 notifyDataSetChanged() 等系列方法后需要更新的 ViewHolder。 mCachedViews mCachedViews 用于解决滑动抖动的问题，默认容量为2。 ViewCacheExtension 开发者自定义的缓存 RecyclerViewPool 缓存池，可以在多个RecyclerView中共享ViewHolder。通过setMaxRecycledViews设置对应type的ViewHolder的缓存池大小 获取VH流程 RecyclerViewPool缓存池的用法： 1234567var linearLayoutManager = LinearLayoutManager(activity)linearLayoutManager.recycleChildrenOnDetach = truerecyclerView.layoutManager = linearLayoutManager//设置缓存大小recycledViewPool.setMaxRecycledViews(0, 10)//共用缓存池recyclerView.setRecycledViewPool(recycledViewPool) 参考 https://phantomvk.github.io/2019/02/13/RecyclerView_cache/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"RecyclerView之Adapter","slug":"Android/UI/RecyclerView之Adapter","date":"2021-07-16T02:50:12.943Z","updated":"2021-07-16T09:33:44.287Z","comments":true,"path":"wiki/Android/UI/RecyclerView之Adapter/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BAdapter/","excerpt":"","text":"概述Adapter是RecyclerView的第一个内部类，将RecyclerView和视图关联起来。使用的是很方便的，只要继承它，重写几个方法即可。 123456789101112131415//创建视图public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)//将视图跟当前位置的数据绑定public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)//返回元素的个数public int getItemCount()//设置类型，用于缓存策略中public int getItemViewType(int position) &#123; return 0;&#125; Adapter视图模型中，我们只需要改变数据，并发送通知，系统会自动更新UI。 Adapter内部有一个AdapterDataObservable，继承自Java的Observable，使用观察者模式。RecyclerView中RecyclerViewDataObserver进行监听，最终使用AdapterHelper进行操作。 notifyItemChanged(int position) 更新列表position位置上的数据可以调用 notifyItemInserted(int position) 列表position位置添加一条数据时可以调用，伴有动画效果 notifyItemRemoved(int position) 列表position位置移除一条数据时调用，伴有动画效果 notifyItemMoved(int fromPosition, int toPosition) 列表fromPosition位置的数据移到toPosition位置时调用，伴有动画效果 notifyItemRangeChanged(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项进行数据刷新 notifyItemRangeInserted(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量添加数据时调用，伴有动画效果 notifyItemRangeRemoved(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量删除数据时调用，伴有动画效果 notifyDataSetChanged ApaterHelper管理和执行更新操作的帮助类，RecyclerView将每一次更新操作封装成了一个UpdateOp操作，然后通过AdapterHelper进行管理和执行。 当RecyclerView初始化时，会创建AdapterHelper，然后通过实现的dispatchUpdate方法，最终调用布局管理器进行元素的操作。 它内部有一个静态内部类UpdateOp，定义了相应的操作指令： 12345678910111213141516171819202122232425262728293031final class AdapterHelper implements OpReorderer.Callback &#123;//UpdateOp对象的回收和复用private Pools.Pool&lt;UpdateOp&gt; mUpdateOpPool = new Pools.SimplePool&lt;UpdateOp&gt;(UpdateOp.POOL_SIZE);//将要执行的操作列表final ArrayList&lt;UpdateOp&gt; mPendingUpdates = new ArrayList&lt;UpdateOp&gt;();//需要延迟执行的操作列表final ArrayList&lt;UpdateOp&gt; mPostponedList = new ArrayList&lt;UpdateOp&gt;();//指令操作的记录器// since move operations breaks continuity, their effects on ADD/RM are hard to handle.// we push them to the end of the list so that they can be handled easily.final OpReorderer mOpReorderer; static final class UpdateOp &#123; static final int ADD = 1; static final int REMOVE = 1 &lt;&lt; 1; static final int UPDATE = 1 &lt;&lt; 2; static final int MOVE = 1 &lt;&lt; 3; static final int POOL_SIZE = 30; ... &#125;&#125; preProcess当滑动RecyclerView等原因造成数据改变时，会触发到preProcess方法 12345678910111213141516171819202122232425262728293031void preProcess() &#123; //添加到记录器中 mOpReorderer.reorderOps(mPendingUpdates); final int count = mPendingUpdates.size(); //将待处理队列中的指令进行处理 for (int i = 0; i &lt; count; i++) &#123; UpdateOp op = mPendingUpdates.get(i); switch (op.cmd) &#123; case UpdateOp.ADD: //通过回调到RecyclerView中，找到对应ViewHolder，修改相应数值，比如mPosition applyAdd(op); break; case UpdateOp.REMOVE: applyRemove(op); break; case UpdateOp.UPDATE: applyUpdate(op); break; case UpdateOp.MOVE: applyMove(op); break; &#125; if (mOnItemProcessedCallback != null) &#123; mOnItemProcessedCallback.run(); &#125; &#125; //清空列表 mPendingUpdates.clear();&#125; 参考 https://fsilence.github.io/2020/05/15/RecyclerView-AdapterHelper","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"RecyclerView之ItemDecoration","slug":"Android/UI/RecyclerView之ItemDecoration","date":"2021-07-16T02:36:47.592Z","updated":"2021-07-16T02:50:12.943Z","comments":true,"path":"wiki/Android/UI/RecyclerView之ItemDecoration/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8BItemDecoration/","excerpt":"","text":"概述ItemDecoration用于在每个元素之间设置视图，比如分割线。它是一个抽象类，我们在使用过程中，只需要实现相应的方法，就能进行视图的大小设置，内容绘制。 方法介绍12345678910111213141516171819//重写绘制方法，画自己想要的内容public void onDraw(@NonNull Canvas c, @NonNull RecyclerView parent) &#123;&#125;//这个方法会在onDraw后面执行public void onDrawOver(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull State state) &#123; onDrawOver(c, parent);&#125;//指定尺寸public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent);&#125; 参考 https://www.jianshu.com/p/6a093bcc6b83","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"RecyclerView之绘制流程","slug":"Android/UI/RecyclerView之绘制流程","date":"2021-07-14T09:37:26.285Z","updated":"2021-07-16T09:40:16.623Z","comments":true,"path":"wiki/Android/UI/RecyclerView之绘制流程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8B%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/","excerpt":"","text":"绘制流程onMeasure先概括下onMeasure的大致流程： LayoutManager对象为空,RecyclerView不能显示任何的数据。 LayoutManager开启了自动测量时，在这种情况下，有可能会测量两次。 LayoutManager没有开启自动测量的情况，这种情况比较少，因为为了RecyclerView支持warp_content属性，系统提供的LayoutManager都开启自动测量的 测量的状态保存在State中，有以下几种状态： 值 描述 State.STEP_START mState.mLayoutStep 的默认值，这种情况下，表示 RecyclerView 还未经历 dispatchLayoutStep1，因为 dispatchLayoutStep1 调用之后mState.mLayoutStep 会变为 State.STEP_LAYOUT。 State.STEP_LAYOUT 当 mState.mLayoutStep 为 State.STEP_LAYOUT 时，表示此时处于 layout 阶段，这个阶段会调用 dispatchLayoutStep2 方法 layout RecyclerView 的children。调用 dispatchLayoutStep2 方法之后，此时 mState.mLayoutStep 变为了 State.STEP_ANIMATIONS。 State.STEP_ANIMATIONS 当 mState.mLayoutStep为 State.STEP_ANIMATIONS 时，表示 RecyclerView 处于第三个阶段，也就是执行动画的阶段，也就是调用 dispatchLayoutStep3方法。当 dispatchLayoutStep3 方法执行完毕之后，mState.mLayoutStep 又变为了 State.STEP_START。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179@Overrideprotected void onMeasure(int widthSpec, int heightSpec) &#123; //当布局管理器为空时，进行默认的测量。RecyclerView不能显示任何的数据 if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec); return; &#125; //自动测量 if (mLayout.isAutoMeasureEnabled()) &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); // 开始测量 if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); &#125; mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; //测量的第二步，更新子布局 dispatchLayoutStep2(); //如果rclerview没有精确的宽度和高度，并且至少有一个子View //子View也没有精确的宽度和高度，我们必须重新测量。 if (mLayout.shouldMeasureTwice()) &#123; mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); &#125; &#125; else &#123; //是否使用固定尺寸 if (mHasFixedSize) &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); return; &#125; // if (mAdapterUpdateDuringMeasure) &#123; processAdapterUpdatesAndSetAnimationFlags(); &#125; else if (mState.mRunPredictiveAnimations) &#123; setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); return; &#125; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); &#125; &#125;/** * - 处理 Adapter 更新 * - 决定执行哪一种动画 * - 保存每个 ItemView 的信息 * - 有必要的话，会进行预布局，并把相关信息保存下来 */private void dispatchLayoutStep1() &#123; mState.assertLayoutStep(State.STEP_START); fillRemainingScrollValues(mState); mState.mIsMeasuring = false; startInterceptRequestLayout(); mViewInfoStore.clear(); onEnterLayoutOrScroll(); processAdapterUpdatesAndSetAnimationFlags(); saveFocusInfo(); mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged; mItemsAddedOrRemoved = mItemsChanged = false; // 是否预布局 mState.mInPreLayout = mState.mRunPredictiveAnimations; mState.mItemCount = mAdapter.getItemCount(); findMinMaxChildLayoutPositions(mMinMaxLayoutPositions); if (mState.mRunSimpleAnimations) &#123; // Step 0: Find out where all non-removed items are, pre-layout int count = mChildHelper.getChildCount(); for (int i = 0; i &lt; count; ++i) &#123; //根据当前的显示在界面上的ViewHolder的布局信息创建一个ItemHolderInfo final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123; continue; &#125; // 记录当前的位置信息 Left、Right、Top、Bottom等 final ItemHolderInfo animationInfo = mItemAnimator .recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads()); //把 holder对应的animationInfo保存到 mViewInfoStore中 mViewInfoStore.addToPreLayout(holder, animationInfo); if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved() &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123; long key = getChangedHolderKey(holder); mViewInfoStore.addToOldChangeHolders(key, holder); &#125; &#125; &#125; if (mState.mRunPredictiveAnimations) &#123; saveOldPositions(); final boolean didStructureChange = mState.mStructureChanged; mState.mStructureChanged = false; // temporarily disable flag because we are asking for previous layout //在layoutmanager中进行测量 mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = didStructureChange; for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123; final View child = mChildHelper.getChildAt(i); final ViewHolder viewHolder = getChildViewHolderInt(child); if (viewHolder.shouldIgnore()) &#123; continue; &#125; if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123; int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder); boolean wasHidden = viewHolder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (!wasHidden) &#123; flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; &#125; final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation( mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads()); if (wasHidden) &#123; recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo); &#125; else &#123; mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo); &#125; &#125; &#125; // we don&#x27;t process disappearing list because they may re-appear in post layout pass. clearOldPositions(); &#125; else &#123; clearOldPositions(); &#125; onExitLayoutOrScroll(); stopInterceptRequestLayout(false); //设置状态 mState.mLayoutStep = State.STEP_LAYOUT;&#125; /** * 第二步，我们会真正的测量视图。 * 这一步可能执行多次 */private void dispatchLayoutStep2() &#123; startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount();//返回元素个数 mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; if (mPendingSavedState != null &amp;&amp; mAdapter.canRestoreState()) &#123; if (mPendingSavedState.mLayoutState != null) &#123; mLayout.onRestoreInstanceState(mPendingSavedState.mLayoutState); &#125; mPendingSavedState = null; &#125; // Step 2: Run layout // 更改此状态，确保不是会执行上一布局操作 mState.mInPreLayout = false; //LayoutManager中进行子视图测量 //子视图的测量通用具体的布局管理器实现 mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = false; // onLayoutChildren may have caused client code to disable item animations; re-check mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; //设置状态 mState.mLayoutStep = State.STEP_ANIMATIONS; onExitLayoutOrScroll(); stopInterceptRequestLayout(false);&#125; 我们看看LinearLayoutManager是如何测量的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //布局算法 // 1)通过检查子变量和其他变量，找到一个锚坐标和一个锚物品的位置。 // 2)开始填充，从底部开始堆叠 // 3)向底填充，从上往下堆叠 // 4)从底部滚动以满足堆栈等需求。创建布局状态 // 解决布局方向 resolveShouldLayoutReverse(); final View focused = getFocusedChild(); if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION || mPendingSavedState != null) &#123; mAnchorInfo.reset(); mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; // calculate anchor position and coordinate // 计算锚点位置和坐标 updateAnchorInfoForLayout(recycler, state, mAnchorInfo); mAnchorInfo.mValid = true; &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused) &gt;= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(focused) &lt;= mOrientationHelper.getStartAfterPadding())) &#123; // This case relates to when the anchor child is the focused view and due to layout // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows // up after tapping an EditText which shrinks RV causing the focused view (The tapped // EditText which is the anchor child) to get kicked out of the screen. Will update the // anchor coordinate in order to make sure that the focused view is laid out. Otherwise, // the available space in layoutState will be calculated as negative preventing the // focused view from being laid out in fill. // Note that we won&#x27;t update the anchor position between layout passes (refer to // TestResizingRelayoutWithAutoMeasure), which happens if we were to call // updateAnchorInfoForLayout for an anchor that&#x27;s not the focused view (e.g. a reference // child which can change between layout passes). mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused)); &#125; if (mAnchorInfo.mLayoutFromEnd) &#123; updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtraFillSpace = extraForStart; fill(recycler, mLayoutState, state, false); &#125; else &#123; fill(recycler, mLayoutState, state, false); &#125; &#125;int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunkResult.resetInternal(); if (RecyclerView.VERBOSE_TRACING) &#123; TraceCompat.beginSection(&quot;LLM LayoutChunk&quot;); &#125; //填充item layoutChunk(recycler, state, layoutState, layoutChunkResult); &#125; &#125;/**1. 调用layoutState.next(recycler)获取View2. addView3. measureChildWithMargins进行子View测量*/void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); LayoutParams params = (LayoutParams) view.getLayoutParams(); if (layoutState.mScrapList == null) &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; //添加item的视图 addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addDisappearingView(view); &#125; else &#123; addDisappearingView(view, 0); &#125; &#125; // 测量view measureChildWithMargins(view, 0, 0); ...&#125; 流程图如下： onLayout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; //这个时候测量已经结束 mState.mIsMeasuring = false; if (mState.mLayoutStep == State.STEP_START) &#123; //当还是测量初始状态时，走上面的测量流程 dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if (mAdapterHelper.hasUpdates() || needsRemeasureDueToExactSkip || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; // First 2 steps are done in onMeasure but looks like we have to run again due to // changed size. // 数据更新、改变尺寸后需要重新测量 mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) // 确保跟布局管理器同步 mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3(); &#125;/**布局的最后一步，我们保存关于视图的动画信息，触发动画并进行必要的清理*/private void dispatchLayoutStep3() &#123; //恢复默认值 mState.mLayoutStep = State.STEP_START; //如果有动画 if (mState.mRunSimpleAnimations) &#123; // Step 3: Find out where things are now, and process change animations. // traverse list in reverse because we may call animateChange in the loop which may // remove the target view holder. // 遍历子元素 for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123; // 拿到VH ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore()) &#123; continue; &#125; long key = getChangedHolderKey(holder); final ItemHolderInfo animationInfo = mItemAnimator .recordPostLayoutInformation(mState, holder); ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key); if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123; // run a change animation // If an Item is CHANGED but the updated version is disappearing, it creates // a conflicting case. // Since a view that is marked as disappearing is likely to be going out of // bounds, we run a change animation. Both views will be cleaned automatically // once their animations finish. // On the other hand, if it is the same view holder instance, we run a // disappearing animation instead because we are not going to rebind the updated // VH unless it is enforced by the layout manager. final boolean oldDisappearing = mViewInfoStore.isDisappearing( oldChangeViewHolder); final boolean newDisappearing = mViewInfoStore.isDisappearing(holder); if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123; // run disappear animation instead of change mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; else &#123; final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout( oldChangeViewHolder); // we add and remove so that any post info is merged. mViewInfoStore.addToPostLayout(holder, animationInfo); ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder); if (preInfo == null) &#123; handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); &#125; else &#123; // 添加新的视图 // 添加到ChildHelper上 animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing); &#125; &#125; &#125; else &#123; mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; &#125; // Step 4: Process view info lists and trigger animations // 处理列表的视图信息和触发动画 mViewInfoStore.process(mViewInfoProcessCallback); &#125; mLayout.removeAndRecycleScrapInt(mRecycler); mState.mPreviousLayoutItemCount = mState.mItemCount; mDataSetHasChangedAfterLayout = false; mDispatchItemsChangedEvent = false; mState.mRunSimpleAnimations = false; mState.mRunPredictiveAnimations = false; mLayout.mRequestedSimpleAnimations = false; if (mRecycler.mChangedScrap != null) &#123; mRecycler.mChangedScrap.clear(); &#125; if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123; // Initial prefetch has expanded cache, so reset until next prefetch. // This prevents initial prefetches from expanding the cache permanently. mLayout.mPrefetchMaxCountObserved = 0; mLayout.mPrefetchMaxObservedInInitialPrefetch = false; mRecycler.updateViewCacheSize(); &#125; //回到布局管理器，同步状态 mLayout.onLayoutCompleted(mState); onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mViewInfoStore.clear(); if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123; dispatchOnScrolled(0, 0); &#125; recoverFocusFromState(); resetFocusInfo();&#125;private void animateChange(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo, boolean oldHolderDisappearing, boolean newHolderDisappearing) &#123; if (oldHolder != newHolder) &#123; if (newHolderDisappearing) &#123; addAnimatingView(newHolder); &#125; oldHolder.mShadowedHolder = newHolder; // old holder should disappear after animation ends //添加视图到管理器 addAnimatingView(oldHolder); mRecycler.unscrapView(oldHolder); newHolder.setIsRecyclable(false); newHolder.mShadowingHolder = oldHolder; &#125; //启动动画 if (mItemAnimator.animateChange(oldHolder, newHolder, preInfo, postInfo)) &#123; postAnimationRunner(); &#125; &#125; 主要的工作内容如下： 检查状态，如果是STEP_START，则先测量； 数据、尺寸发生变化，则走dispatchLayoutStep2； 处理需要播放动画的数据 状态同步给布局管理器 onDraw1234567891011public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); // 遍历隔间装饰列表，进行绘制。 // 子视图在自己的onDraw中绘制 for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"自定义View之Paint","slug":"Android/UI/自定义View之Paint","date":"2021-07-14T03:08:46.576Z","updated":"2021-07-14T03:49:43.860Z","comments":true,"path":"wiki/Android/UI/自定义View之Paint/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BPaint/","excerpt":"","text":"API颜色设置123456789101112setColor(int color)paint.setColor(Color.parseColor(&quot;#009688&quot;));canvas.drawRect(30, 30, 230, 180, paint);setARGB(int a, int r, int g, int b)paint.setARGB(100, 255, 0, 0);canvas.drawRect(0, 0, 200, 200, paint); Shader设置在 Android 的绘制里使用 Shader ，并不直接用 Shader 这个类，而是用它的几个子类。具体来讲有： LinearGradient：线性渐变 RadialGradient：辐射渐变 SweepGradient：扫描渐变 BitmapShader ComposeShader：混合着色器 在设置了 Shader 的情况下， Paint.setColor/ARGB() 所设置的颜色就不再起作用。 1234567891011121314151617181920212223242526272829Shader shader = new LinearGradient(100, 100, 500, 500, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;), Shader.TileMode.CLAMP);paint.setShader(shader);...canvas.drawCircle(300, 300, 200, paint);Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.batman);Shader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);paint.setShader(shader);...canvas.drawCircle(300, 300, 200, paint);// 第一个 Shader：头像的 BitmapBitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.batman);Shader shader1 = new BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);// 第二个 Shader：从上到下的线性渐变（由透明到黑色）Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.batman_logo);Shader shader2 = new BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);// ComposeShader：结合两个 ShaderShader shader = new ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER);paint.setShader(shader);...canvas.drawCircle(300, 300, 300, paint); PorterDuff.Mode 是用来指定两个图像共同绘制时的颜色策略的。它是一个 enum，不同的 Mode 可以指定不同的策略。参考： https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html 颜色滤镜 ColorFilter LightingColorFilter PorterDuffColorFilter ColorMatrixColorFilter 12345678setColorFilter(ColorFilter colorFilter)ColorFilter lightingColorFilter = new LightingColorFilter(0x00ffff, 0x000000);paint.setColorFilter(lightingColorFilter); setXfermode1 设置抗锯齿抗锯齿默认是关闭的，如果需要抗锯齿，需要显式地打开。另外，除了 setAntiAlias(aa) 方法，打开抗锯齿还有一个更方便的方式：构造方法。创建 Paint 对象的时候，构造方法的参数里加一个 ANTI_ALIAS_FLAG 的 flag，就可以在初始化的时候就开启抗锯齿。 12345setAntiAlias (boolean aa)Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); setStyle1234567paint.setStyle(Paint.Style.FILL); // FILL 模式，填充canvas.drawCircle(300, 300, 200, paint);paint.setStyle(Paint.Style.STROKE); // STROKE 模式，画线canvas.drawCircle(300, 300, 200, paint); 线条形状 setStrokeWidth(float width) setStrokeCap(Paint.Cap cap) setStrokeJoin(Paint.Join join) setStrokeMiter(float miter) 1234567paint.setStyle(Paint.Style.STROKE);paint.setStrokeWidth(1);canvas.drawCircle(150, 125, 100, paint);paint.setStrokeWidth(5);canvas.drawCircle(400, 125, 100, paint);paint.setStrokeWidth(40);canvas.drawCircle(650, 125, 100, paint); setStrokeCap线头形状有三种： BUTT 平头（默认） ROUND 圆头 SQUARE 方头。 1 setStrokeJoin MITER 尖角 BEVEL 平角 ROUND 圆角。 setStrokeMiter这个方法是对于 setStrokeJoin() 的一个补充，它用于设置 MITER 型拐角的延长线的最大值。 色彩优化123456789//设置图像的抖动setDither(boolean dither)//设置是否使用双线性过滤来绘制 Bitmap setFilterBitmap(boolean filter) setPathEffect使用 PathEffect 来给图形的轮廓设置效果。对 Canvas 所有的图形绘制有效，也就是 drawLine() drawCircle() drawPath() 这些方法。 CornerPathEffect把所有拐角变成圆角 1234PathEffect pathEffect = new CornerPathEffect(20);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint); DiscretePathEffect把线条进行随机的偏离，让轮廓变得乱七八糟。乱七八糟的方式和程度由参数决定。 12345PathEffect pathEffect = new DiscretePathEffect(20, 5);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint); 绘制虚线123456789101112131415//使用虚线来绘制线条。PathEffect pathEffect = new DashPathEffect(new float[]&#123;20, 10, 5, 10&#125;, 0);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint);Path dashPath = ...; // 使用一个三角形来做 dashPathEffect pathEffect = new PathDashPathEffect(dashPath, 40, 0, PathDashPathEffectStyle.TRANSLATE);paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint); SumPathEffect123456PathEffect dashEffect = new DashPathEffect(new float[]&#123;20, 10&#125;, 0);PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new SumPathEffect(dashEffect, discreteEffect);...canvas.drawPath(path, paint); ComposePathEffectsetShadowLayer在之后的绘制内容下面加一层阴影 123paint.setShadowLayer(10, 0, 0, Color.RED);...canvas.drawText(text, 80, 300, paint); setMaskFilter为之后的绘制设置 MaskFilter。上一个方法 setShadowLayer() 是设置的在绘制层下方的附加效果；而这个 MaskFilter 和它相反，设置的是在绘制层上方的附加效果。 MaskFilter 有两种： BlurMaskFilter 和 EmbossMaskFilter 123paint.setMaskFilter(new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL));...canvas.drawBitmap(bitmap, 100, 100, paint); 文字相关setTextSize设置字体大小 setTypeface设置字体 setFakeBoldText是否使用伪粗体 setStrikeThruText是否加删除线 setUnderlineText是否加下划线 setTextSkewX设置文字横向错切角度 setTextScaleX设置文字横向放缩 setLetterSpacing设置字符间距 setFontFeatureSettings用 CSS 的 font-feature-settings 的方式来设置文字 1234paint.setFontFeatureSettings(&quot;smcp&quot;); // 设置 &quot;small caps&quot;canvas.drawText(&quot;Hello HenCoder&quot;, 100, 150, paint); setTextAlign设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。 setTextLocale设置绘制所使用的 Locale setHinting设置是否启用字体的 hinting （字体微调） getFontSpacing获取推荐的行距 getTextBounds获取文字的显示范围 measureText测量文字的宽度并返回 getTextWidthsgetTextWidths(String text, float[] widths) 获取字符串中每个字符的宽度，并把结果填入参数 widths breakText也是用来测量文字宽度的。但和 measureText() 的区别是， breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字。 光标相关getRunAdvance1234/**start end 是文字的起始和结束坐标；contextStart contextEnd 是上下文的起始和结束坐标；isRtl 是文字的方向；offset 是字数的偏移，即计算第几个字符处的光标。*/getRunAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset) getOffsetForAdvance给出一个位置的像素值，计算出文字中最接近这个位置的字符偏移量（即第几个字符最接近这个坐标）。 123456789/**text 是要测量的文字；start end 是文字的起始和结束坐标；contextStart contextEnd 是上下文的起始和结束坐标；isRtl 是文字方向；advance 是给出的位置的像素值。填入参数，对应的字符偏移量将作为返回值返回。*/getOffsetForAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance) 参考 https://rengwuxian.com/ui-1-2/ https://rengwuxian.com/ui-1-3/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"IO多路复用","slug":"操作系统/未分类/IO多路复用","date":"2021-07-13T12:54:32.918Z","updated":"2021-07-14T02:33:01.953Z","comments":true,"path":"wiki/操作系统/未分类/IO多路复用/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%88%86%E7%B1%BB/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"","text":"发展史开始的时候，为了实现一个服务器可以支持多个客户端连接，人们想出了fork/thread等办法，当一个连接来到的时候，就fork/thread一个进程/线程去接收并且处理请求。 到了80年代，计算机网络开始成型，越来越多的用户进行网络连接，但是之前的fork/thread模型在高并发场景快不行了。1983年，发明了select。 对应的编程模型就是：一个连接来了，就必须遍历所有已经注册的文件描述符，来找到那个需要处理信息的文件描述符，如果已经注册了几万个文件描述符，那会因为遍历这些已经注册的文件描述符，导致cpu爆炸。 到2002年，epoll出现了，于Linux 2.5.44首度登场。 基本概念用户空间/内核空间操作系统的核心是内核，为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分。 针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 同步与异步 同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。 异步：异步就是发一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时可以处理其他的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。 阻塞和非阻塞 阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。 非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他的事情。 进程切换挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 文件描述符File descriptor：表述指向文件的引用的抽象化概念。在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 在实际编程中，不管是进行文件操作还是Socket编程，都是操作文件描述符。 缓存I/O缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 具体实现select它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。 缺点 单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ; 每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大； 对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发） pollpoll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。 缺点它没有最大连接数的限制，但是同样有缺点： 每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大； 对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时） epollepoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)） 参考 五种IO模型 彻底理解 IO 多路复用实现机制 https://zh.wikipedia.org/wiki/Epoll https://baike.baidu.com/item/poll/3643578 https://mp.weixin.qq.com/s/Ok7SIROXu1THUbWsFu-UYw","raw":null,"content":null,"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"未分类","slug":"操作系统/未分类","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://shjlone.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"HTTPS","slug":"网络编程/HTTPS","date":"2021-07-12T03:53:35.199Z","updated":"2021-07-12T03:58:06.716Z","comments":true,"path":"wiki/网络编程/HTTPS/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/HTTPS/","excerpt":"","text":"工作流程 Client发起一个HTTPS(比如 https://juejin.im/user )的请求，根据RFC2818的规定，Client知道需要连接Server的443(默认)端口。 Server把事先配置好的公钥证书(public key certificate)返回给客户端。 Client验证公钥证书:比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书(操作系统内置的Root证书或者Client内置的Root证书)。如果验证通过则继续，不通过则显示警告信息。 Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 Server使用自己的私钥(private key)解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 Server使用对称密钥加密“明文内容A”，发送给Client。 Client使用对称密钥解密响应的密文，得到“明文内容A”。 Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥 解密密文，得到“明文内容B”。 参考","raw":null,"content":null,"categories":[{"name":"网络编程","slug":"网络编程","permalink":"http://shjlone.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"EventBus","slug":"Android/开源库/EventBus","date":"2021-07-12T03:04:25.970Z","updated":"2021-07-12T03:06:28.952Z","comments":true,"path":"wiki/Android/开源库/EventBus/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/EventBus/","excerpt":"","text":"事件总线匡救啊，降低了代码的耦合性。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[]},{"title":"复杂度定义","slug":"算法/复杂度定义","date":"2021-07-12T02:47:27.953Z","updated":"2021-07-12T02:57:24.859Z","comments":true,"path":"wiki/算法/复杂度定义/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89/","excerpt":"","text":"时间复杂度一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变 化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度。 T(n)=O(f(n)); 它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。 时间复杂度的分析方法: 时间复杂度就是函数中基本操作所执行的次数 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数 忽略掉常数项 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势 递归算法的时间复杂度为:递归总次数 x 每次递归中基本操作所执行的次数 常用的时间复杂度有以下七种，算法时间复杂度依次增加: O(1)常数型 O(log2 n)对数型 O(n) 线性型 O(n log2 n)二维型 O(n^2)平方型 O(n^3)立方型 O(2^n)指数型 空间复杂度算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级。 S(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1); 递归算法的空间复杂度:递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N). 算法效率算法效率分析分为两种:第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度， 而空间效率被称作空间复杂度。时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主 要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。 所以我们如今已经不需要再特别关注一个算法的空间复杂度。","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PackageManagerService工作原理","slug":"Android/进阶知识/PackageManagerService工作原理","date":"2021-07-12T02:02:10.613Z","updated":"2021-07-12T02:02:21.226Z","comments":true,"path":"wiki/Android/进阶知识/PackageManagerService工作原理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/PackageManagerService%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"保活策略","slug":"Android/进阶知识/保活策略","date":"2021-07-09T10:02:03.471Z","updated":"2021-07-16T03:55:28.956Z","comments":true,"path":"wiki/Android/进阶知识/保活策略/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E4%BF%9D%E6%B4%BB%E7%AD%96%E7%95%A5/","excerpt":"","text":"一个像素的Activity 前台service 进程间唤醒 JobSheduler 1559","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android面试题收集","slug":"Android/未分类/Android面试题收集","date":"2021-07-09T09:55:45.628Z","updated":"2021-07-09T09:56:00.485Z","comments":true,"path":"wiki/Android/未分类/Android面试题收集/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/","excerpt":"","text":"https://github.com/Moosphan/Android-Daily-Interview","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://shjlone.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"多渠道打包","slug":"Android/进阶知识/多渠道打包","date":"2021-07-09T09:27:28.413Z","updated":"2021-07-09T09:27:38.011Z","comments":true,"path":"wiki/Android/进阶知识/多渠道打包/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"代码混淆","slug":"Android/进阶知识/代码混淆","date":"2021-07-09T09:19:57.516Z","updated":"2021-07-09T09:20:08.903Z","comments":true,"path":"wiki/Android/进阶知识/代码混淆/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"AIDL","slug":"Android/进阶知识/AIDL","date":"2021-07-09T07:32:41.727Z","updated":"2021-07-09T08:52:41.507Z","comments":true,"path":"wiki/Android/进阶知识/AIDL/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/AIDL/","excerpt":"","text":"Binder是一个工作在Linux层面的驱动，这 一段驱动运行在内核态。Binder本身又是一种架构，这种架构提供了服务端、Binder驱动和客户端三个模块。 服务端Binder服务端实际上就是一个Binder类的对象，当我们创建一个Binder对象的时候，Binder内部就 会启动一个隐藏线程，该线程的主要作用就是接收Binder驱动发送来的消息，那么Binder驱动为 什么会给Binder服务端的线程发送消息呢?原因很简单，我们在客户端调用服务端的时候并不能直接调用服务端相应的类和方法，只能通过Binder驱动来调用。当服务端的隐藏线程收到Binder 驱动发来的消息之后，就会回调服务端的onTransact方法，我们来看看这个方法的方法头: 1234567891011121314151617181920212223242526272829303132333435363738/**@param code 指定客户端要调 用服务端的哪一个方法@param data 客户端传来的参数@param reply 表示服务端返回的参数@param flags 表示客户端的调用是否有返回值，0表示服务端执行完成之后有返回值，1表示服务 端执行完后没有返回值。*/protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteExceptionpublic class MyAddBinder extends Binder &#123; private final static int ADD = 1; @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case ADD: data.enforceInterface(&quot;MyAddBinder&quot;); int a = data.readInt(); int b = data.readInt(); int add = add(a, b); reply.writeInt(add); return true; &#125; return super.onTransact(code, data, reply, flags); &#125; public int add(int a, int b) &#123; return a + b; &#125;&#125;public class MyService extends Service &#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; return new MyAddBinder(); &#125;&#125; Binder驱动Binder驱动是Binder服务端和Binder客户端之间连接的一个桥梁，当一个服务端Binder被创建出来的时候，系统同时会在Binder驱动中创建另外一个Binder对象，当客户端想要访问远程的Binder服务端的时候，都是通过这个Binder对象来完成的。那么Binder驱动中的这个对象要怎么样获取呢?其实很简单，这个BInder对象就是我们用绑定的方式启动一个Service服务时，在绑定成功时所获取的那个IBinder对象。 1234567891011boolean b = bindService(intent, new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //这个service就是Binder驱动中创建的Binder对象 mRemote = service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;, Service.BIND_AUTO_CREATE); 客户端在客户端获取Binder驱动中的Binder对象，然后调用该对象中的 transact方法进行数据传递。客户端在向服务端发送消息的时候是以线程间通信的模式来进行的，而且调用服务端代码是同步进行的，也就是说线程会阻塞。 1234567891011121314151617int code = 1;//向服务端发送的数据Parcel data = Parcel.obtain();//接收服务端返回的数据Parcel reply = Parcel.obtain();data.writeInterfaceToken(&quot;MyAddBinder&quot;);data.writeInt(10);data.writeInt(9);try &#123; mRemote.transact(code, data, reply, 0); int i = reply.readInt(); Log.d(&quot;google.sang&quot;, &quot;add: &quot; + i); reply.recycle(); data.recycle();&#125; catch (RemoteException e) &#123; e.printStackTrace();&#125;","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"动态换肤","slug":"Android/进阶知识/动态换肤","date":"2021-07-09T06:32:08.748Z","updated":"2021-07-09T06:32:18.033Z","comments":true,"path":"wiki/Android/进阶知识/动态换肤/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E5%8A%A8%E6%80%81%E6%8D%A2%E8%82%A4/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"MMKV","slug":"Android/开源库/MMKV","date":"2021-07-09T06:05:20.691Z","updated":"2021-07-09T07:36:08.687Z","comments":true,"path":"wiki/Android/开源库/MMKV/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/MMKV/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Small","slug":"Android/开源库/Small","date":"2021-07-09T06:04:32.635Z","updated":"2021-07-09T06:05:20.692Z","comments":true,"path":"wiki/Android/开源库/Small/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Small/","excerpt":"","text":"插件化框架 https://github.com/wequick/Small","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"字符编码","slug":"技术开发/杂项/字符编码","date":"2021-07-08T12:11:23.416Z","updated":"2021-07-08T12:24:24.138Z","comments":true,"path":"wiki/技术开发/杂项/字符编码/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","excerpt":"","text":"ASCII 码计算机内部，所有信息最终都是一个二进制值。每一个二进制位(bit)有 0 和 1 两种 状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000 到 11111111 。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32(二进制 00100000 )，大写的字母 A 是65(二进制 01000001 )。这128个符号(包括32个不能打印出来的控制符号)，只占用了一个字节的后面7位，最前面的一位统一规定为 0 。 UnicodeUnicode 只是一个符号集。Unicode可以容纳100多万个符号。他规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。比如，汉字严的Unicode是十六进制数 4E25 ，转换成二进制数足足有15位( 100111000100101 )，也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 UTF-8UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号， 根据不同的符号而变化字节长度。 UTF-8 的编码规则： 对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号(n&gt;1)，第一个字节的前n位都设为1，第n+1 位设为0，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 严 的 Unicode 是 4E25 (100111000100101 )，根据上表，可以发现 4E25 处在第三行的范围内 ( 0000 0800 - 0000 FFFF)，因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 一个utf8数字占1个字节，一个utf8英文字母占1个字节，少数是汉字每个占用3个字节，多数占用4个字节。 编程转换一般的文件编辑器（比如notepad）中保存时会有编码选项： ANSI：对于英文文件是 ASCII 编码，对于简体中文文件是 GB2312 编码 Unicode：notepad使用的 UCS-2 编码方式，即直接用两个字节存入字符 的 Unicode 码，这个选项用的 little endian 格式（如果一个文本文件的头两个字节是 FE FF ，就表示该文件采用大头方式;如果头两个字节是 FF FE ，就表示该文件采用小头方式。） Unicode big endian UTF-8","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://shjlone.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"HTTP协议","slug":"网络编程/HTTP协议","date":"2021-07-08T11:50:50.337Z","updated":"2021-07-12T05:59:37.416Z","comments":true,"path":"wiki/网络编程/HTTP协议/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTP 协议的请求报文和响应报文的结构基本相同，主要由三大部分组成： 状态行（status line）：描述响应的基本信息，也就是服务器响应的状态； 头部字段集合（header）：使用 key-value 形式更详细地说明报文； 消息正文（entity）：实际响应的数据，它不一定是纯文本，可以是图片、视频等二进制数据。 header参数请求头 Request URL( 请 求 的 地 址 ) Request Method(请求的方式) Status Code(状态码) Accept: /(客户端能接收的资源类型) Accept-Language: en-us( 客 户 端 接 收 的 语 言 类 型 ) Connection: Keep-Alive(维护客户端和服务端的连接关系) Host:localhost:8080(连接的目标主机和端口号) Referer: http://localhost/links.asp(告诉服务器我来自哪里) User-Agent:Mozilla/4.0(客户端版本号的名字) Accept-Encoding:gzip, deflate(客户端能接收的压缩数据的类型) If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT( 缓 存 时 间 ) Cookie(客户端暂存服务端的信息) Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间) 响应 Location:http://www.baidu.com(服务端需要客户端访问的页面路径) Server:apache tomcat(服务端的Web服务端名) Content-Encoding:gzip(服务端能够发送压缩编码类型) Content-Length:80(服务端发送的压缩数据的长度) Content-Language:zh-cn(服务端发送的语言类型) Content-Type:text/html;charset=GB2312(服务端发送的类型及采用的编码方式) Last-Modified:Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间) Refresh:1;url=http://www.it315.org(服务端要求客户端一秒钟后，刷新，然后访问指定的页面 路径) Content-Disposition:attachment;filename=aaa.zip(服务端要求客户端以下载文件的方式打开 该文件) Transfer-Encoding:chunked(分块传递数据到客户端) Set-Cookie:SS=Q0=5Lb_nQ;path=/search(服务端发送到客户端的暂存数据) Expires:-1//3种(服务端禁止客户端缓存页面数据) Cache-Control:no-cache(服务端禁止客户端缓存页面数据) Pragma:no-cache(服务端禁止客户端缓存页面数据) Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系) Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间) Cache-Control：缓存配置 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存 max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据(后面介绍) no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发 状态码1xx1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。 2xx2×× 类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。 “200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果。 “204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。 “206 Partial Content” 一般用于分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-66/888”，意思是此次获取的是总计 888 个字节的前 66 个字节。 3xx3×× 类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括“著名”的 301、302 跳转。 “301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。 “304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。 4xx4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它是具有真正的“错误码”含义的状态码了。 “400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头或者还是其他错误则不会明确指示，因此在Web开发时一般会尽量避免给客户端返回 400，使用其他更有明确含义的状态码。 “403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等。 “404 Not Found”可能是我们最常看到的一个状态码，它一般指资源在本服务器上未找到，所以无法提供给客户端。 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET； 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文； 408 Request Timeout：请求超时，服务器等待了过长的时间； 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态； 413 Request Entity Too Large：请求报文里的 body 太大； 414 Request-URI Too Long：请求行里的 URI 太大； 429 Too Many Requests：客户端发送了太多的请求，触发了服务器的限制； 431 Request Header Fields Too Large：请求头某个字段或总体太大。 5xx5×× 类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。 “500 Internal Server Error” 与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过和 400 的响应相反，开发人员通常不会把服务器内部的出错详细信息返回给访问端。虽然不利于调试，但能够防止黑客的窥探或者分析。 “501 Not Implemented” 表示客户端请求的功能还不支持，类似于“即将开业，敬请期待”的意思。 “502 Bad Gateway” 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。 “503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。 HTTP请求过程参考","raw":null,"content":null,"categories":[{"name":"网络编程","slug":"网络编程","permalink":"http://shjlone.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"虚拟机是如何装载一个类的","slug":"Java/虚拟机/虚拟机是如何装载一个类的","date":"2021-07-08T10:31:59.446Z","updated":"2021-07-08T10:38:50.037Z","comments":true,"path":"wiki/Java/虚拟机/虚拟机是如何装载一个类的/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E8%A3%85%E8%BD%BD%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84/","excerpt":"","text":"Java语言的类型可以分为两大类:基本类型(primitive types)和引用类型(reference types)。 基本类型是由Java虚拟机预先定义好的。 另一个大类引用类型，Java将其细分为四种:类、接口、数组类和泛型参数。由于泛型参数会在 编译过程中被擦除，因此Java虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java虚拟机直接生成的，其他两种则有对应的字节流。 说到字节流，最常见的形式要属由Java编译器生成的class文件。除此之外，我们也可以在程序内 部直接生成，或者从网络中获取(例如网页中内嵌的小程序Java applet)字节流。这些不同形式的字节流，都会被加载到Java虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。 无论是直接生成的数组类，还是加载的类，Java虚拟机都需要对其进行链接和初始化。 加载加载，是指查找字节流，并且据此创建类的过程。对于数组类来说，它并没有对应的字节流，而 是由Java虚拟机直接生成的。对于其他的类来说，Java虚拟机则需要借助类加载器来完成查找字 节流的过程。 java中有很多类加载器，共同的祖师爷，叫启动类加载器(bootstrap class loader)。启动类加载 器是由C++实现的，没有对应的Java对象，因此在Java种只能用null来指代。 除了启动类加载器之外，其他的类加载器都是java.lang.ClassLoader的子类，因此有对应的Java对 象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至Java虚拟机中，方能 执行类加载。 每当一个类加载器接收到加载请求时，它会将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。叫双亲委派模型。 在Java9之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在JRE的lib目录下jar包中的类(以及由虚拟机参数-Xbootclasspath 指定的类)。除了启动类加载器之外，另外两个重要 的类加载器是扩展加载器(extension class loader)和应用类加载器(application class loader)， 均由Java核心类库提供。 扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如放在JRE 的lib/ext目录下jar包中的类(以及由系统变量java.ext.dirs指定的类)。 应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。(这里的应用 程序路径，便是指虚拟机参数 -cp/-classpath、系统变量java.class.path或环境变量CLASSPATH所 指定的路径。)默认情况下，应用程序中包含的类便是由应用类加载器加载的。 Java9引入模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器 (platform class loader)。Java SE中除了少数几个关键模块，比如说java.base是由启动类加载器 加载之外，其他的模块均由平台类加载器所加载。 除了由Java核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载 方式。举例来说，我们可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。 在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节 流，经过不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特 性，来运行同一个类的不同版本 链接链接，是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可以分为验证、准备以及解析三个阶段。 验证阶段的目的，在于确保被加载的类能够满足Java虚拟机的约束条件。通常而言，Java编译器 生成的类文件必然满足Java虚拟机的约束条件。 准备阶段的目的，则是为被加载类的静态字段分配内存。Java代码中对静态字段的具体初始化， 则会在稍后的初始化阶段中进行。除了分配内存外，部分Java虚拟机还会在此阶段构造 其他跟类 层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。 在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java编译器会生成一 个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。 举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收餐宿和类型以及返回值类型的符号引用，来指代所要调用的方法。 解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载的字段或方法，那么解析将触发这个类的加载(但未必触发这个类的链接以及初始化。) Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了:如果某些字节码使用了符号引 用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。 初始化在Java代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块 中对其赋值。 如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会 被Java编译器标记成为常量值(ConstantValue)，其初始化直接由Java虚拟机完成。除此之外的 直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并把它命名 为。 类加载的最后一步时初始化，便是为标记为常量值的字段赋值，以及执行方法的过程。Java虚拟 机会通过加锁来确保类的方法仅被执行一次。 只有当初始化完成之后，类才正式成为可执行的状态。那么，类的初始化何时会被触发呢?JVM 规范枚举了下述多种触发情况: 当虚拟机启动时，初始化用户指定的主类; 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类; 当遇到调用静态方法的指令时，初始化该静态方法所在的类; 当遇到访问静态字段的指令时，初始化该静态字段所在的类; 子类的初始化会触发父类的初始化; 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该 接口的初始化; 使用反射API对某个类进行反射调用时，初始化这个类; 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。 使用卸载","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://shjlone.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://shjlone.github.io/tags/JVM/"}]},{"title":"Class文件","slug":"Java/虚拟机/Class文件","date":"2021-07-08T10:12:30.704Z","updated":"2021-07-08T10:24:02.054Z","comments":true,"path":"wiki/Java/虚拟机/Class文件/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/Class%E6%96%87%E4%BB%B6/","excerpt":"","text":"概述Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class文件之中，中间没有添加任何分隔符。根据Java虚拟机规范的规定，Class文件结构采用一种 类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型:无符号数和表。 无符号数属于基本的数据类型，以u1、u2、u4、u8来表示1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构 成的字符串值。 表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性地以 “_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表， 它由下表所示的数据项构成。 魔数与Class文件的版本每个Class文件的头四个字节称为魔数(Magic Number)，值为0xCAFEBABE。紧跟着魔数的四个字节存储的是Class文件的版本号:第5和第6个字节是次版本号(Minor Version),第7和第8个字节是主版本号(Major Version)。 常量池(constant_pool)由于常量池中的常量数量不固定，所以在常量池的入口需要放置一项u2类型的数据，代表容量池容量计数值(constant_pool_count)，这个容量计数从1而不是0开始。 常量池中主要存放两大类常量:字面量(Literal)和符号引用(Symbolic Reference)。字面量 比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量: 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 JDK1.7中，总共有14种类型的常量，每种常量都是表类型的数据项。这14种表都有一个共同的特 点，就是表开始的第一位是一个u1类型的标志位，代表当前常量属于哪种常量类型。这14种常量类型代表的具体含义见下表: 访问标志(access_flags)常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括:这个Class是接口还是类;是否被定义为public类型;是否定义为abstract类型;如 果是类的话，是否被声明为final等。 类索引(this_class)、父类索引(super_class)与接口索引集合(interfaces)类索引、父类索引和接口索引集合都按顺序排列代访问标志之后，类索引用于确定这个类的全限 定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多继承，因此父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了Object外，所有Java类的父类索引都不为0。 类索引和父类索引均是u2类型的数据，它们各自指向一个类型为CONSTANT_Class_info类型的常 量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTATN_Utf8_info类型 的常量中的全限定名字符串。该查找过程可用下图表示 接口索引集合用来描述这个类实现了哪些接口，它是一组u2类型的数据的集合，集合中的第一项 是接口计数器，表示索引表的容量。如果一个类没有实现任何接口，则该计数器值为0。 字段表集合(fields)方法表集合(methods)属性表集合(attributes)","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://shjlone.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://shjlone.github.io/tags/JVM/"}]},{"title":"ArrayDeque","slug":"Java/集合/ArrayDeque","date":"2021-07-08T06:17:08.273Z","updated":"2021-07-08T06:21:35.772Z","comments":true,"path":"wiki/Java/集合/ArrayDeque/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/ArrayDeque/","excerpt":"","text":"ArrayDeque不是线程安全的。 ArrayDeque不可以存取null元素 当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。 参考 https://blog.jrwang.me/2016/java-collections-deque-arraydeque/","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Android中的集合","slug":"Android/未分类/Android中的集合","date":"2021-07-08T04:11:12.688Z","updated":"2021-07-09T09:45:29.257Z","comments":true,"path":"wiki/Android/未分类/Android中的集合/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/Android%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/","excerpt":"","text":"SparseArraySparseArray由两个数组mKeys和mValues存放数据;其中key的类型为int型，这就显得SparseArray比HashMap更省内存一些。SparseArray存储的元素都是按元素的key值从小到大排列好的。使用二分查找来判断元素的位置，数据量较小时比HashMap更快。 SparseIntArray：当map的结构为Map&lt;Integer,Integer&gt;的时候使用，效率较高。 SparseBooleanArray: 当map的结构为Map&lt;Integer,Boolean&gt;的时候使用，效率较高。 SparseLongArray: 当map的结构为Map&lt;Integer,Long&gt;的时候使用，效率较高。 LongSparseArray: 当map的结构为Map&lt;Long,Value&gt;的时候使用，效率较高。 1234SparseArray&lt;String&gt; sparseArray = new SparseArray&lt;&gt;();sparseArray.put(1,&quot;A&quot;);sparseArray.put(2,&quot;B&quot;);Log.i(TAG, &quot;init: &quot;+sparseArray.toString()); ArrayMapArrayMap是一个键值对映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，区别是ArrayMap的key是hash值。 1234ArrayMap&lt;String ,String&gt; arrayMap = new ArrayMap&lt;&gt;();arrayMap.put(&quot;a&quot;,&quot;A&quot;);arrayMap.put(&quot;b&quot;,&quot;B&quot;);Log.i(TAG, &quot;init: &quot;+arrayMap.toString()); 参考 http://gityuan.com/2019/01/13/arraymap/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://shjlone.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"基础概念","slug":"操作系统/进程/基础概念","date":"2021-07-07T09:41:51.269Z","updated":"2021-07-08T03:48:43.316Z","comments":true,"path":"wiki/操作系统/进程/基础概念/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"","text":"协程：是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用 了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一 个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。 协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。 协程的特点在于是一个线程执行，那和多线程比，协程有何优势? 极高的执行效率:因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显; 不需要多线程的锁机制:因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。","raw":null,"content":null,"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"操作系统/进程","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/"}],"tags":[]},{"title":"Thread","slug":"Java/并发编程/Thread","date":"2021-07-07T08:34:25.355Z","updated":"2021-07-13T12:25:05.240Z","comments":true,"path":"wiki/Java/并发编程/Thread/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Thread/","excerpt":"","text":"Java中的Thread的用法 同步队列与等待队列 同步队列：所有尝试获取该对象Monitor失败的线程，都加入同步队列排队获取锁。调用了start、notify方法后会进入该队列。 等待队列：已经拿到锁的线程在等待其他资源时，主动释放锁，置入该对象等待队列中，等待被唤醒，当调用notify会在等待队列中任意唤醒一个线程，将其置入同步队列的尾部，排队获取锁。调用wait方法时，会进入该队列。 API join主要作用是线程调度，等待该线程完成后，才能继续用下运行。一般用于等待异步线程执行完结果之后才能继续运行的场景。 123Thread t1 = new Thread(new Worker(&quot;thread-1&quot;)); t1.start();t1.join();//要等待t1执行完后，当前线程才会继续往下执行 yield暂停当前正在执行的线程对象，不会释放资源锁，和sleep不同的是yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 notify该方法用来通知那些可能等待该对象的对象锁的其他线程。 wait和sleep区别 区别 wait() sleep() 归属类 Object类实例方法 Thread类静态方法 是否释放锁 释放锁 不会释放锁 线程状态 等待 睡眠 使用时机 只能在同步块(Synchronized)中使用 在任何时候使用 唤醒条件 其他线程调用notify()或notifyAll()方法 超时或调用Interrupt()方法 cpu占用 不占用cpu，程序等待n秒 占用cpu，程序等待n秒 interruptThread类的sleep(),wait()等方法，在接收到interrupt()方法中断时，会抛出异常，同时会将中断标志置为false,如果确实需要中断该线程，则应该在捕捉到异常后，继续调用interrupt()方法进行中断。 123456789101112131415161718192021222324//为什么不在异常时直接中断线程呢?主要是为了防止线程的资源没有得到释放而中断了线程public class UserThread extends Thread &#123; public void run() &#123; while (!isInterrupt()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName + &quot; Exception,interrupt flag is&quot; + isInterrupted()); //释放资源 doRelease(); interrupt(); e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName + &quot; runing&quot;); &#125; System.out.println(Thread.currentThread().getName + &quot; interrupt flag is &quot; + isInterrupted()); &#125; public static void main(String args) &#123; UserThread thread = new UserThread(); thread.start(); Thread.sleep(30); thread.interrupt(); &#125;&#125; 参考 深入理解线程通信","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"ConcurrentHashMap","slug":"Java/集合/ConcurrentHashMap","date":"2021-07-07T08:20:55.996Z","updated":"2021-07-07T08:23:09.072Z","comments":true,"path":"wiki/Java/集合/ConcurrentHashMap/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给 定数量的并发更新。相比于 HashTable 和用同步包装器包装的HashMap(Collections.synchronizedMap(new HashMap()))，ConcurrentHashMap 拥有更高的并发性。 在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发 访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的 了。 在使 用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争: 减小请求 同一个锁的 频率。 减少持有锁的 时间。 ConcurrentHashMap 的高并发性主要来自于三个方面:用分离锁实现多个线程间的更深层次的共 享访问。 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。 使用 分离锁，减小了请求 同一个锁的频率。通过 HashEntery 对象的不变性及对同一个 Volatile 变量的 读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频 率，也可以有效减少持有锁的时间。通过减小请求同一个锁的频率和尽量减少持有锁的时间 ， 使 得 ConcurrentHashMap 的并发性相对于 HashTable 和用同步包装器包装的 HashMap有了质的提高。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"http://shjlone.github.io/tags/Java%E9%9B%86%E5%90%88/"}]},{"title":"NIO","slug":"Java/基础/NIO","date":"2021-07-07T08:04:14.702Z","updated":"2021-07-07T08:04:42.399Z","comments":true,"path":"wiki/Java/基础/NIO/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/NIO/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://shjlone.github.io/tags/IO/"}]},{"title":"LinkedList","slug":"Java/集合/LinkedList","date":"2021-07-05T05:56:03.801Z","updated":"2021-07-05T06:02:04.155Z","comments":true,"path":"wiki/Java/集合/LinkedList/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/LinkedList/","excerpt":"","text":"概述 LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 使用场景 需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 参考 https://www.cnblogs.com/skywang12345/p/3308807.html","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"命令模式","slug":"设计模式/行为型模式/命令模式","date":"2021-07-05T01:44:10.245Z","updated":"2021-07-13T01:44:42.794Z","comments":true,"path":"wiki/设计模式/行为型模式/命令模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义Command Pattern：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式的别名为动作(Action)模式或事务(Transaction)模式。 类图 角色 客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。 命令(Command)角色：声明了一个给所有具体命令类的抽象接口。 具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法，会调用Receiver的action方法。 请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 优缺点优点 命令模式将调用操作的请求对象与执行该操作的接收对象解耦。 具体命令角色可以被不同的请求者角色重用。 使用场景 开源库EventBus中 开源库puremvc中 参考 《Head First设计模式》","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"设计模式/创建型模式/单例模式","date":"2021-07-05T01:44:10.244Z","updated":"2021-07-05T06:23:19.732Z","comments":true,"path":"wiki/设计模式/创建型模式/单例模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式应该是最常见的设计模式了 定义定义：单例对象的类必须保证只有一个实例存在。 为了实现一个健壮的单例，我们应该思考需要做哪些事情？ 不能随意的让用户new出对象，所以构造函数应该是私有的 既然不能直接new，就应该有一个方法专门用来返回实例对象 不能clone 不能被反序列化 多线程使用时，如何保证线程安装 Java的实现方式根据上面的思考，我们可以一步步的来实现单例模式。 懒汉式12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 使用的时候才进行初始化，但此种写法是线程不安全的。那么是否把getInstance方法加一个锁就可以了呢？ 线程安全的懒汉式12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 嗯，这种写法确实安全了，可是效率低，因为有更好的方式啊 饿汉式12345678910111213public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125;public class Singleton &#123; private static Singleton instance = null; static &#123; instance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 为什么叫饿汉呢？因为在类加载的时候对象就被创建了啊！这也是该方式不太好的地方，需要的实例应该要在需要用到的时候才初始化呢!所以应该想想怎样才能延迟加载呢？ 静态内部类实现方式123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。完美！！ 枚举123456789101112131415161718192021222324//方式一public enum Singleton &#123; INSTANCE; public void whoAmI() &#123; System.out.println(this.toString()); &#125; &#125;//方式二public class Singleton &#123; private Singleton()&#123; &#125; public void whoAmI() &#123; System.out.println(this.toString()); &#125; public static enum SingletonEnum &#123; SINGLETON; private Singleton instance = null; private SingletonEnum()&#123; instance = new Singleton(); &#125; public Singleton getInstance()&#123; return instance; &#125; &#125;&#125; Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次 双重检查锁模式12345678910111213141516public class Singleton &#123; private Singleton()&#123;&#125; private volatile static Singleton instance = null; public static Singleton getInstance() &#123; if(instance == null) &#123; synchronized (Singleton.class) &#123; if(instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要这样写呢？ 其实这是懒汉式的升级版。懒汉式中所有线程在访问getInstance都会锁住，但实际情况中，很多时候只是读操作，我们没有必要让每个线程都锁住才调用它。 为什么要加volatile呢？ 因为JVM指令可重排，具体可以看看volatile这篇文档 AtomicReference实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.shjlone.singleton;import java.util.concurrent.atomic.AtomicReference;/** * 使用AtomicReference的单例 */public class AtomicReferenceSingleton &#123; private static final AtomicReference&lt;Object&gt; instance; private AtomicReferenceSingleton() &#123; &#125; static &#123; instance = new AtomicReference&lt;&gt;(); &#125; public static AtomicReferenceSingleton getInstance() &#123; Object value = AtomicReferenceSingleton.instance.get(); if (value == null) &#123; synchronized (AtomicReferenceSingleton.instance) &#123; value = AtomicReferenceSingleton.instance.get(); if (value == null) &#123; final AtomicReferenceSingleton actualValue = new AtomicReferenceSingleton(); value = ((actualValue == null)) ? AtomicReferenceSingleton.instance : actualValue; AtomicReferenceSingleton.instance.set(value); &#125; &#125; &#125; return (AtomicReferenceSingleton)((value == AtomicReferenceSingleton.instance) ? null : value); &#125; public static void main(String[] args) &#123; System.out.println(AtomicReferenceSingleton.getInstance()); System.out.println(AtomicReferenceSingleton.getInstance()); System.out.println(AtomicReferenceSingleton.getInstance()); for(int i=0; i&lt;10; i++) &#123; new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(AtomicReferenceSingleton.getInstance()); &#125; &#125;.start(); &#125; &#125;&#125; 相较于synchronize，CAS的实现性能更高。 Kotlin的实现方式由于kotlin的语言特性，有些写法还是有别于Java的。 饿汉式1object Singleton &#123;&#125; 对！就是这么简单。以上代码转换成Java后，就是在静态代码块中初始化了Singleton。 懒汉式1234567891011121314151617class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null get() &#123; if (field == null) &#123; field = Singleton() &#125; return field &#125; fun get(): Singleton &#123; //这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字 return instance!! &#125; &#125;&#125; 线程安全的懒汉式123456789101112131415class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null get() &#123; if (field == null) field = Singleton() return field &#125; @Synchronized fun instance(): Singleton &#123; return instance!! &#125; &#125;&#125; 双重锁校验12345class Singleton private constructor() &#123; companion object &#123; val instance by lazy &#123; Singleton() &#125; &#125;&#125; 静态内部类的实现123456789101112131415class Singleton private constructor() &#123; companion object &#123; @JvmStatic //方便Java中使用 fun getInstance() &#123; return Holder.instance &#125; &#125; private object Holder &#123; val instance = Singleton() &#125;&#125; 1234enum class Singleton &#123; INSTANCE;&#125; 如何处理反序列化最开始的分析指出，为了不让别人直接new，构造函数需要设置成私有的。除此之外，还可能被反序列化。那么怎么解决这个问题呢？ 1234567public class Singleton implements Serializable &#123; private final static Singleton instance; private Object readResolve() &#123; return instance; &#125;&#125; 这样就行了？可以参考https://www.jianshu.com/p/ea1d9bc40341这篇文章了解原理。 如何防止反射可以在私有构造函数中加一些限制条件，比如判断静态变量是否已经存在了 参考 https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F https://www.jianshu.com/p/ea1d9bc40341 https://blog.csdn.net/c10WTiybQ1Ye3/article/details/108806203 Java设计模式（一）：单例模式，防止反射和反序列化漏洞","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Synchronized与ReentrantLock的区别","slug":"Java/面试题/Synchronized与ReentrantLock的区别","date":"2021-07-05T01:44:10.243Z","updated":"2021-07-05T01:44:10.243Z","comments":true,"path":"wiki/Java/面试题/Synchronized与ReentrantLock的区别/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/Synchronized%E4%B8%8EReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"底层原理区别 底层实现上来说，synchronized 是JVM层面的锁，是Java关键字，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait/notify方法， ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的API层面的锁。 synchronized 的实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁， ReentrantLock实现则是通过利用CAS（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。 是否可手动释放 synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。 是否可中断 synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。 是否公平锁 synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。 锁是否可绑定条件Condition synchronized不能绑定； ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。 锁的对象 synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁； ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"面试题","slug":"Java/面试题","permalink":"http://shjlone.github.io/categories/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java笔试题收集","slug":"Java/面试题/Java笔试题收集","date":"2021-07-05T01:44:10.242Z","updated":"2021-07-08T10:29:40.561Z","comments":true,"path":"wiki/Java/面试题/Java笔试题收集/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E7%AC%94%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/","excerpt":"","text":"TCP、UDP区别 TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） TCP首部开销20字节;UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 三次握手、四次挥手三次握手 第一次握手：客户端想跟服务器进行连接，所以状态变为主动打开，同时发送一个连接请求报文给服务器端SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态就变为SYN_SENT,这个状态等待发送确认。 第二次握手：服务端接收到连接请求报文后，从LISTEN状态变为被动打开状态，然后给客户端返回一个报文。这个报文有两层意思，一是确认报文，二是可以达到告诉客户端，我也打开连接了。发送完毕后，变为SYN_RCVD状态。 第三次握手：客户端得到服务端的确认和知道服务端已经准备好连接后，还会发一个确认报文到服务端，发送完后客户端进入ESTABLISHED状态，当服务端接收后，状态也变为ESTABLISHED。 四次挥手 第一次挥手：从ESTABLISHED变为主动关闭状态，客户端主动发送释放连接请求给服务器端，FIN=1。发送完之后就变为FIN_WAIT_1状态，这个状态可以说是等待确认状态。 第二次挥手：服务器接收到客户端发来的释放连接请求后，状态变为CLOSE_WAIT，然后发送确认报文给客户端，告诉他我接收到了你的请求。为什么变为CLOSE_WAIT，原因是客户端发送的释放连接请求，可能自己这端还有数据没有发送完呢，所以这个时候整个TCP连接的状态就变为了半关闭状态。服务器端还能发送数据，并且客户端也能接收数据，但是客户端不能在发送数据了，只能够发送确认报文。客户端接到服务器的确认报文后，就进入了FIN_WAIT_2状态。也可以说这是等待服务器释放连接状态。 第三次挥手：服务器端所有的数据度发送完了，认为可以关闭连接了，状态变为被动关闭，所以向客户端发送释放连接报文，发完之后自己变为LAST_WAIT状态，也就是等待客户端确认状态。 第四次挥手：客户端接到释放连接报文后，发送一个确认报文，然后自己变为TIME_WAIT,而不是立马关闭，因为客户端发送的确认报文可能会丢失，丢失的话服务器就会重传一个FIN，也就是释放连接报文，这个时候客户端必须还没关闭。 当服务器接受到确认报文后，服务器就进入CLOSE状态，也就是关闭了。但是由于上面说的这个原因，客户端必须等待一定的时间才能够进入CLOSE状态。 volatile执行控制：目的是控制代码执行（顺序）及是否可以并行执行。 内存可见：线程执行结果在内存中对其他线程的可见性。 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化 内存模型 定义 为什么要有内存模型 为什么要重排序，重排序在什么时候排 如何约束重排序规则 happens-before 什么是顺序一致性 CAS 实现的原理，是阻塞还是非阻塞方式？什么时候用，使用时需要考虑的问题 处理器和 Java 分别怎么保证原子操作 保证了原子性就能保证可见性吗？ final 内存语义？什么时候用，使用时需要考虑的问题 volatile 内存语义，什么时候用，用的时候需要考虑什么问题 synchronized 内存语义，什么时候用，和锁比较一下优缺点 synchronized 中涉及的锁升级流程 锁的内存语义，举例说明，加锁失败时候的处理流程 比较下 CAS 、volatile 、synchronized、Lock 区别 原子操作类底层实现机制？自增操作是怎么保证原子性的？ 线程 线程的状态有哪些 如何在 Java 中实现线程？ 如何在 Java 中启动一个线程？ 设计线程中断的意义是什么 Java 中 interrupted 和 isInterrupted 方法的区别？ 如何停止一个线程？ 线程 join 方法干什么用？ 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？ 线程的等待通知机制实现机制？ 为什么应该在循环中检查等待条件? 为什么 wait 和 notify 方法要在同步块中调用？ 为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？ ThreadLocal 是什么，怎么实现的 线程池是什么，提交一个任务进去，处理流程？ Executor 框架介绍 JUC 包中提供了哪些配置好的线程池，差异化是什么 什么是 FutureTask？ 锁 Lock 接口提供了哪些实现类 AQS 是什么，提供了哪些方法 AQS 中独占锁和共享锁的操作流程大体描述一下 重入锁有什么好处，什么时候考虑用 读写锁有什么好处，什么时候考虑用？读锁是什么类型的锁，写锁呢？ 说下读写锁里的锁降级流程，什么时候可以考虑用这个机制 park 方法是怎么实现的 锁的等待通知机制 Condition 是怎么实现的，有了线程的等待通知机制为什么还要设计 Condition？ 死锁怎么产生的，如何避免 说说 Java 中有哪些锁 sleep、wait、park、Condition 都能让线程等待，有什么区别？ 容器与工具 阻塞和非阻塞有什么区别，他们可以用什么方式实现 队列（Queue）提供哪些操作 阻塞队列提供了哪些获取元素的方法，有什么区别？ 阻塞队列有哪些实现？为什么要分有界无界？ CountDownLatch 怎么实现的，什么时候考虑用？ CyclicBarrier 怎么实现的，什么时候考虑用？ Semaphore 怎么实现的，什么时候考虑用？ 如何在两个线程间共享数据？ Exchanger 怎么实现的，什么时候考虑用？ ConcurrentHashMap 实现？ fork/join 框架是什么？ 内存管理 为什么需要 JVM？ 简单描述 JMM 和 JVM 两个概念 JVM 内存管理 永久代、元空间、方法区的关系 类加载过程 双亲委派模式有什么好处 如何覆盖 JDK 提供的组件，比如覆盖 ArrayList 的实现 new 一个对象的过程发生了什么（类加载、变量初始化、内存分配） 对象的死亡过程 JVM 可能会抛出哪些 OOM 垃圾回收算法有哪些？优缺点比较 熟知的垃圾回收器有哪些，简单描述每个应用场景 CMS 和 G1 的垃圾回收步骤是？ G1 相对于 CMS 的优缺点 性能监控与调优 如何监控 GC 常见 OutOfMemoryError 有哪些 常见的 JDK 诊断命令有哪些，应用场景？ CPU 较高，如何定位问题 内存占用较高，如何定位大对象 内存泄漏时，如何实时跟踪内存变化情况 内存泄漏时，如何定位问题代码 大型项目如何进行性能瓶颈调优？虚拟机子系统 字节码是如何在 JVM 中进行流转的（栈帧） 方法调用的底层实现 方法重写和重载的实现过程 invokedynamic 指令实现 如何修改字节码 JIT 参数配置如何影响程序运行？ 虚拟机有哪些性能优化策略 Java基础 1.JAVA 中的几种数据类型是什么，各自占用多少字节。2.String 类能被继承吗，为什么。3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？4. String 属于基础的数据类型吗？5.Java 中操作字符串都有哪些类？它们之间有什么区别？6.Java 中 IO 流分为几种？7.BIO、NIO、AIO 有什么区别？8.用过哪些 Map 类，都有什么区别，HashMap 时线程安全的吗，并发下使用的 Map 是什么，他们的内部原理分别是什么，比如存储方法，hashcode，扩容，默认容量等。9. 如何将字符串反转？10.抽象类必须要有抽象方法吗？11.普通类和抽象类有哪些区别？12.抽象类能使用 final 修饰吗？13.ArrayList 和 LinkedList 有什么区别？14.ConcurrentHashMap的数据结构15.volatile作用16.Atomic类如何保证原子性（CAS操作）17.为什么要使用线程池 JVM 运行时数据区域（内存模型） 垃圾回收机制 垃圾回收算法 Minor GC和Full GC触发条件 GC中Stop the world（STW） 各垃圾回收器的特点及区别 双亲委派模型 JDBC和双亲委派模型关系 JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数 操作系统篇 进程和线程的区别 进程同步的几种方式 线程间同步的方式 什么是缓冲区溢出。有什么危害，其原因是什么 进程中有哪几种状态 分页和分段有什么区别","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"面试题","slug":"Java/面试题","permalink":"http://shjlone.github.io/categories/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Glide","slug":"Android/开源库/Glide","date":"2021-07-05T01:44:10.241Z","updated":"2021-07-12T03:46:49.297Z","comments":true,"path":"wiki/Android/开源库/Glide/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide/","excerpt":"","text":"此篇文章只是用于记录使用Glide时要注意的点和一些使用技巧，如需查看基本使用，请查阅官方文档。也可以看看Glide原理分析。 注意点占位符1234567Glide.with(this) .load(url) .asBitmap() //指定加载的图片是位图，这样底层不会进行图片格式判断，Gif就无法播放，也可以设置asGif()指明是Gif图片 .placeholder(R.drawable.loading)//下载过程中的占位符 .error(R.drawable.error)//下载失败后的显示 .diskCacheStrategy(DiskCacheStrategy.NONE)//磁盘策略，这里不使用缓存 .into(imageView); 缓存等级活动缓存：内存缓存：默认开启，可以通过skipMemoryCache(true)关闭内存缓存。 磁盘缓存：InternalCacheDiskCacheFactory（默认） DiskCacheStrategy.NONE 不缓存文件 DiskCacheStrategy.DATA 对应 Glide 3 中的 DiskCacheStrategy.SOURCE， 只缓存原图 DiskCacheStrategy.RESOURCE 对应 Glide 3 中的 DiskCacheStrategy.RESULT， 只缓存最终加载的图 DiskCacheStrategy.ALL 同时缓存原图和结果图 DiskCacheStrategy.AUTOMATIC:表示让 Glide 根据图片资源智能地选择使用哪一 种缓存策略(默认选项)。 缓存键123//缓存的键包括图片的宽、高、signature等参数EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,resourceClass, transcodeClass, options); submitsubmit()方法其实就是对应的 Glide 3 中的 downloadOnly()方法，和 preload()方法 类似，submit()方法也是可以替换 into()方法的，不过 submit()方法的用法明显要 比 preload()方法复杂不少。这个方法只会下载图片，而不会对图片进行加载。当 图片下载完成之后，我们可以得到图片的存储路径，以便后续进行操作。 重要知识点 通过attach一个Fragment来监听Context的生命周期，合理的管理图片的加载和释放。 Glide默认采用的是RGB-565，相比ARGB-8888内存占用会减小一半。 会根据ImageView的尺寸来缓存图片。 常用配置整合OkHttp3为了提升请求效率，使用更高效的OkHttp3来进行资源的下载。接入方式很简单，直接在gradle中引入 compile “com.github.bumptech.glide:okhttp3-integration:4.11.0” 它会自动添加以下配置 12345678@GlideModulepublic final class OkHttpLibraryGlideModule extends LibraryGlideModule &#123; @Override public void registerComponents(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) &#123; registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory()); &#125;&#125; 注意点 使用时尽量传生命周期所对应的Context（比如Activity、Fragment） 如果使用ApplicationContext，则使用弱引用 参考 https://github.com/bumptech/glide 官方文档","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"jenv","slug":"Java/未分类/jenv","date":"2021-07-05T01:44:10.241Z","updated":"2021-07-05T01:44:10.241Z","comments":true,"path":"wiki/Java/未分类/jenv/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E6%9C%AA%E5%88%86%E7%B1%BB/jenv/","excerpt":"","text":"概述有时候，我们可能需要在电脑中安装多个Java环境，在不同的场景切换版本，我们需要修改JAVA_HOME、PATH等环境变量。每次改起来就很繁琐。我们也可以自己写一个shell命令，来动态切换不同的版本。jenv就是帮我们解决了这个问题。 jenv支持在当前shell、文件夹、全局切换不同的Java版本 安装和配置安装1brew install jenv 配置我们一般先下载对应的JDK/JRE的压缩包，然后即可进行配置。 1234567891011121314151617181920212223242526272829# 添加java版本jenv add /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Homejenv versions # 查看所有版本 system 1.8* 1.8.0.252 (set by /Users/loneqd/.java-version) 1.8.0.51 16.0 16.0.1 openjdk64-1.8.0.252 openjdk64-16.0.1 oracle64-1.8.0.51# 切换当前目录下的jdk版本，如切换当前目录下的版本为1.6jenv local 1.8# 全局切换版本，如下切换为1.7jenv global 1.7# 当前shell中使用某个版本jenv shell 1.6# 查看当前使用版本jenv version 参考 Java8相关环境下载地址 https://www.jenv.be/","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"未分类","slug":"Java/未分类","permalink":"http://shjlone.github.io/categories/Java/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Fragment工作过程","slug":"Android/基础/Fragment工作过程","date":"2021-07-05T01:44:10.240Z","updated":"2021-07-05T01:44:10.240Z","comments":true,"path":"wiki/Android/基础/Fragment工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Fragment%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"常见类的介绍 ActivityThread : 入口类 Instrumentation : ActivityThread 的得力助手，帮助 ActivityThread 触发 Activity 的生命周期 MainActivity : 就是上文提到例子中的 MainActivity 类，继承自 Activity HostCallbacks : Activity 的内部类，继承自 FragmentHostCallback FragmentHostCallback : 持有 Handler、FragmentManagerImpl 等对象的引用，别的对象可以通过持有它的引用间接控制 FragmentManagerImpl 等对象 FragmentController : Activity 通过控制它间接向 FragmentManagerImpl 发出命令 FragmentManagerImpl : 继承自 FragmentManager，用来对 Fragment 进行管理，在 FragmentHostCallback 中被初始化 BackStackRecord : 继承自 FragmentTransation 并实现了 Runnable，每次调用 FragmentManager 对象的 beginTransaction() 方法都会产生一个 BackStackRecord 对象，可以将其理解为对 Fragment 的一系列操作（即事务） Op : 每次对 Fragment 的操作都会产生一个 Op 对象，其表示双向链表的一个结点 启动流程根据Activity工作过程可知，启动一个Activity会来到ActivityThreadp的erformLaunchActivity方法。在这个方法中 12345678910111213141516171819202122232425262728293031323334353637//ActivityThreadprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); .... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; &#125;//ActivitymFragments.attachHost(null /*parent*/);//FragmentControllerpublic void attachHost(Fragment parent) &#123; mHost.mFragmentManager.attachController( mHost, mHost /*container*/, parent);&#125;/FragmentManagerImplpublic void attachController(FragmentHostCallback&lt;?&gt; host, FragmentContainer container, Fragment parent) &#123; if (mHost != null) throw new IllegalStateException(&quot;Already attached&quot;); mHost = host;//FragmentManagerImpl 对象持有了 HostCallbacks 对象的引用 mContainer = container; mParent = parent;&#125; attach的流程： attach---&gt;attachHost---&gt;attachController 然后是callActivityOnCreate： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ActivityThreadprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125;&#125;//Instrumentationpublic void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123; prePerformCreate(activity); activity.performCreate(icicle, persistentState); postPerformCreate(activity);&#125;//Activityfinal void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; dispatchActivityPreCreated(icicle); mCanEnterPictureInPicture = true; restoreHasCurrentPermissionRequest(icicle); if (persistentState != null) &#123; onCreate(icicle, persistentState); &#125; else &#123; onCreate(icicle); &#125; writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;); mActivityTransitionState.readState(icicle); mVisibleFromClient = !mWindow.getWindowStyle().getBoolean( com.android.internal.R.styleable.Window_windowNoDisplay, false); mFragments.dispatchActivityCreated(); mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); dispatchActivityPostCreated(icicle);&#125;//FragmentControllerpublic void dispatchActivityCreated() &#123; mHost.mFragmentManager.dispatchActivityCreated();&#125;/FragmentManagerImplpublic void dispatchActivityCreated() &#123; this.mStateSaved = false; this.mStopped = false; this.dispatchStateChange(2);&#125;/FragmentManagerImplvoid moveToState(int newState, boolean always) &#123;...&#125; callActivityOnCreate的流程： callActivityOnCreate---&gt;callActivityOnCreate---&gt;performCreate---&gt;dispatchActivityCreated---&gt;moveToState Fragment的操作原理Fragment的一般操作如下： 12345fragmentManager = getSupportFragmentManager();transaction = fragmentManager.beginTransaction();transaction.replace(R.id.testFragment, fragment);transaction.addToBackStack(null);transaction.commit(); getSupportFragmentManager方法直接返回FragmentManagerImpl。 beginTransaction方法返回一个BackStackRecord对象，BackStackRecord对象代表一系列对Fragment的操作，即事务。 replacereplace方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//BackStackRecordpublic FragmentTransaction replace(int containerViewId, Fragment fragment, @Nullable String tag) &#123; //判断容器id是否有效 if (containerViewId == 0) &#123; throw new IllegalArgumentException(&quot;Must use non-zero containerViewId&quot;); &#125; doAddOp(containerViewId, fragment, tag, OP_REPLACE); return this;&#125;private void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) &#123; final Class fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123; throw new IllegalStateException(&quot;Fragment &quot; + fragmentClass.getCanonicalName() + &quot; must be a public static class to be properly recreated from&quot; + &quot; instance state.&quot;); &#125; fragment.mFragmentManager = mManager; if (tag != null) &#123; if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException(&quot;Can&#x27;t change tag of fragment &quot; + fragment + &quot;: was &quot; + fragment.mTag + &quot; now &quot; + tag); &#125; fragment.mTag = tag; &#125; if (containerViewId != 0) &#123; if (containerViewId == View.NO_ID) &#123; throw new IllegalArgumentException(&quot;Can&#x27;t add fragment &quot; + fragment + &quot; with tag &quot; + tag + &quot; to container view with no id&quot;); &#125; if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123; throw new IllegalStateException(&quot;Can&#x27;t change container ID of fragment &quot; + fragment + &quot;: was &quot; + fragment.mFragmentId + &quot; now &quot; + containerViewId); &#125; fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; //生成一个节点 addOp(new Op(opcmd, fragment));&#125;void addOp(Op op) &#123; mOps.add(op); op.enterAnim = mEnterAnim; op.exitAnim = mExitAnim; op.popEnterAnim = mPopEnterAnim; op.popExitAnim = mPopExitAnim;&#125; replace主要是生成一个双向链表的节点。 commit最后就是commit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280//BackStackStateint commitInternal(boolean allowStateLoss) &#123; if (mCommitted) throw new IllegalStateException(&quot;commit already called&quot;); if (FragmentManagerImpl.DEBUG) &#123; Log.v(TAG, &quot;Commit: &quot; + this); LogWriter logw = new LogWriter(TAG); PrintWriter pw = new PrintWriter(logw); dump(&quot; &quot;, null, pw, null); pw.close(); &#125; mCommitted = true; if (mAddToBackStack) &#123; mIndex = mManager.allocBackStackIndex(this); &#125; else &#123; mIndex = -1; &#125; mManager.enqueueAction(this, allowStateLoss); return mIndex;&#125;//FragmentManagerpublic void enqueueAction(OpGenerator action, boolean allowStateLoss) &#123; if (!allowStateLoss) &#123; checkStateLoss(); &#125; synchronized (this) &#123; if (mDestroyed || mHost == null) &#123; if (allowStateLoss) &#123; // This FragmentManager isn&#x27;t attached, so drop the entire transaction. return; &#125; throw new IllegalStateException(&quot;Activity has been destroyed&quot;); &#125; if (mPendingActions == null) &#123; mPendingActions = new ArrayList&lt;&gt;(); &#125; mPendingActions.add(action);//保存BackStackState scheduleCommit(); &#125;&#125;void scheduleCommit() &#123; synchronized (this) &#123; boolean postponeReady = mPostponedTransactions != null &amp;&amp; !mPostponedTransactions.isEmpty(); boolean pendingReady = mPendingActions != null &amp;&amp; mPendingActions.size() == 1; if (postponeReady || pendingReady) &#123; mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); &#125; &#125;&#125;Runnable mExecCommit = new Runnable() &#123; @Override public void run() &#123; execPendingActions(); &#125;&#125;;public boolean execPendingActions() &#123; ensureExecReady(true); boolean didSomething = false; while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123; mExecutingActions = true; try &#123; removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop); &#125; finally &#123; cleanupExec(); &#125; didSomething = true; &#125; doPendingDeferredStart(); burpActive(); return didSomething;&#125;private boolean generateOpsForPendingActions(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isPop) &#123; boolean didSomething = false; synchronized (this) &#123; if (mPendingActions == null || mPendingActions.size() == 0) &#123; return false; &#125; final int numActions = mPendingActions.size(); for (int i = 0; i &lt; numActions; i++) &#123; didSomething |= mPendingActions.get(i).generateOps(records, isPop);//添加到回退栈中 &#125; mPendingActions.clear(); mHost.getHandler().removeCallbacks(mExecCommit); &#125; return didSomething;&#125;private void removeRedundantOperationsAndExecute(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop) &#123; ... executePostponedTransaction(records, isRecordPop); ... executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd); ... &#125;private void executeOpsTogether(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop, int startIndex, int endIndex) &#123; ... oldPrimaryNav = record.expandOps(mTmpAddedFragments, oldPrimaryNav);//OP_REPLACE会从这里触发 ... executeOps(records, isRecordPop, startIndex, endIndex);//Run the operations in the BackStackRecords, either to push or pop. ... record.runOnCommitRunnables();//执行回BackStackRecord，调用runOnCommit注册的方法 ...&#125;//BackStackRecordFragment expandOps(ArrayList&lt;Fragment&gt; added, Fragment oldPrimaryNav) &#123; for (int opNum = 0; opNum &lt; mOps.size(); opNum++) &#123; final Op op = mOps.get(opNum); switch (op.cmd) &#123; case OP_ADD: case OP_ATTACH: added.add(op.fragment); break; case OP_REMOVE: case OP_DETACH: &#123; added.remove(op.fragment); if (op.fragment == oldPrimaryNav) &#123; mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, op.fragment)); opNum++; oldPrimaryNav = null; &#125; &#125; break; case OP_REPLACE: &#123;//来到这里 final Fragment f = op.fragment; final int containerId = f.mContainerId; boolean alreadyAdded = false; for (int i = added.size() - 1; i &gt;= 0; i--) &#123; final Fragment old = added.get(i); if (old.mContainerId == containerId) &#123; if (old == f) &#123; alreadyAdded = true; &#125; else &#123; // This is duplicated from above since we only make // a single pass for expanding ops. Unset any outgoing primary nav. if (old == oldPrimaryNav) &#123; mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, old)); opNum++; oldPrimaryNav = null; &#125; final Op removeOp = new Op(OP_REMOVE, old); removeOp.enterAnim = op.enterAnim; removeOp.popEnterAnim = op.popEnterAnim; removeOp.exitAnim = op.exitAnim; removeOp.popExitAnim = op.popExitAnim; mOps.add(opNum, removeOp); added.remove(old); opNum++; &#125; &#125; &#125; if (alreadyAdded) &#123; mOps.remove(opNum); opNum--; &#125; else &#123; op.cmd = OP_ADD; added.add(f); &#125; &#125; break; case OP_SET_PRIMARY_NAV: &#123; // It&#x27;s ok if this is null, that means we will restore to no active // primary navigation fragment on a pop. mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, oldPrimaryNav)); opNum++; // Will be set by the OP_SET_PRIMARY_NAV we inserted before when run oldPrimaryNav = op.fragment; &#125; break; &#125; &#125; return oldPrimaryNav;&#125;void executeOps() &#123; final int numOps = mOps.size(); for (int opNum = 0; opNum &lt; numOps; opNum++) &#123; final Op op = mOps.get(opNum); final Fragment f = op.fragment; if (f != null) &#123; f.setNextTransition(mTransition, mTransitionStyle); &#125; switch (op.cmd) &#123; case OP_ADD: f.setNextAnim(op.enterAnim); mManager.addFragment(f, false); break; case OP_REMOVE: f.setNextAnim(op.exitAnim); mManager.removeFragment(f); break; case OP_HIDE: f.setNextAnim(op.exitAnim); mManager.hideFragment(f); break; case OP_SHOW: f.setNextAnim(op.enterAnim); mManager.showFragment(f); break; case OP_DETACH: f.setNextAnim(op.exitAnim); mManager.detachFragment(f); break; case OP_ATTACH: f.setNextAnim(op.enterAnim); mManager.attachFragment(f); break; case OP_SET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(f); break; case OP_UNSET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(null); break; default: throw new IllegalArgumentException(&quot;Unknown cmd: &quot; + op.cmd); &#125; if (!mReorderingAllowed &amp;&amp; op.cmd != OP_ADD &amp;&amp; f != null) &#123; mManager.moveFragmentToExpectedState(f); &#125; &#125; if (!mReorderingAllowed) &#123; // Added fragments are added at the end to comply with prior behavior. mManager.moveToState(mManager.mCurState, true); &#125;&#125;////FragmentManagerpublic void addFragment(Fragment fragment, boolean moveToStateNow) &#123; if (moveToStateNow) &#123; moveToState(fragment); &#125;&#125; void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123; if (f.mState &lt;= newState) &#123; switch (f.mState) &#123; case Fragment.INITIALIZING: ... case Fragment.CREATED: ... case Fragment.ACTIVITY_CREATED: ... case Fragment.STARTED: ... &#125; &#125; else if (f.mState &gt; newState) &#123; switch (f.mState) &#123; case Fragment.RESUMED: ... case Fragment.STARTED: ... case Fragment.ACTIVITY_CREATED: ... case Fragment.CREATED: ... &#125; &#125; &#125; 这里的流程有点复杂，大致流程如下： commit---&gt;commitInternal---&gt;FragmentManager中到enqueueAction---&gt;scheduleCommit---&gt;execPendingActions---&gt;removeRedundantOperationsAndExecute---&gt;executeOpsTogether---&gt;expandOps 最终会执行mManager.addFragment，然后调用moveToState来执行真正的操作。在这里面会调用Fragment的生命周期方法。 参考 https://www.jianshu.com/p/f2fcc670afd6","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"WindowManager","slug":"Android/基础/WindowManager","date":"2021-07-05T01:44:10.240Z","updated":"2021-07-05T01:44:10.241Z","comments":true,"path":"wiki/Android/基础/WindowManager/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/WindowManager/","excerpt":"","text":"概述Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此Window并不是实际存在的，它是以View的形式存在。 Android系统中Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限在能创建的Window，比如Toast和系统状态栏这些都是系统Window。 Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面。在三类Window中，应用Window的层级范围是199，子Window的层级范围是10001999，系统Window的层级范围是2000~2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR，如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可:mLayoutParams.type = LayoutParams.TYPE_SYSTEM_ERROR;同时声明权限:。因为系统类型的Window是需要检查权限的，如果不在AndroidManifest中使用相应的权限，那么创建Window的时候就会报错， 流程分析WindowManager实现了ViewManager接口，ViewManager接口提供以下三个方法： 123public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view); addView过程WindowManager在Android中的实现类为WindowManagerImpl，WindowManagerImpl内部使用桥接模式封装了WindowManagerGlobal。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(&quot;view must not be null&quot;); &#125; if (display == null) &#123; throw new IllegalArgumentException(&quot;display must not be null&quot;); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there&#x27;s no parent, then hardware acceleration for this view is // set from the application&#x27;s hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false);//判断是否已经添加 if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don&#x27;t wait for MSG_DIE to make it&#x27;s way through root&#x27;s queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView);//PhoneWindow要开始创建 &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; mViews存储的是所有Window所对应的View，mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，mDyingViews则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象。 总结如下： 检查参数是否合法，如果是子Window那么还需要调整一些布局参数 创建ViewRootImpl并将View添加到列表中 通过ViewRootImpl来更新界面并完成Window的添加过程 在setView内部会通过requestLayout来完成异步刷新请求 WindowSession最终来完成Window的添加过程 在Session内部会通过WindowManagerService来实现Window的添加 removeView过程updateView过程Window的创建过程Activity的Window创建过程由Activity工作过程可知，Activity启动时会调用ActivityThread的performLaunchActivity方法来完成整个启动流程。 performLaunchActivity会调用Activity的attach方法。在这个方法里，会创建PhoneWindow对象。 接下来看看setContentView做了哪些事情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//PhoneWindow.javapublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125;private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); ...&#125;protected DecorView generateDecor(int featureId) &#123; // System process doesn&#x27;t have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don&#x27;t cling to the // activity. Context context; if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) &#123; context = getContext(); &#125; else &#123; context = new DecorContext(applicationContext, getContext()); if (mTheme != -1) &#123; context.setTheme(mTheme); &#125; &#125; &#125; else &#123; context = getContext(); &#125; return new DecorView(context, featureId, this, getAttributes());&#125; 大致步骤如下： 如果没有DecorView，那么就创建它 将View添加到DecorView的mContentParent中 回调Activity的onContentChanged方法通知Activity视图已经发生改变 ActivityThread中的handleResumeActivity只通过WindowManager添加视图到DecorView中 参考 《Android开发艺术探索》 https://juejin.cn/post/6844904073586556935 https://blog.csdn.net/hzw19920329/article/details/52423771","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"WorkManager","slug":"Android/Jetpack/WorkManager","date":"2021-07-02T08:02:11.106Z","updated":"2021-07-02T08:06:40.648Z","comments":true,"path":"wiki/Android/Jetpack/WorkManager/","link":"","permalink":"http://shjlone.github.io/wiki/Android/Jetpack/WorkManager/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"http://shjlone.github.io/categories/Android/Jetpack/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"LiveData原理","slug":"Android/Jetpack/LiveData原理","date":"2021-07-02T08:01:57.969Z","updated":"2021-07-02T08:02:11.107Z","comments":true,"path":"wiki/Android/Jetpack/LiveData原理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/Jetpack/LiveData%E5%8E%9F%E7%90%86/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"http://shjlone.github.io/categories/Android/Jetpack/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android中的ClassLoader","slug":"Android/进阶知识/Android中的ClassLoader","date":"2021-07-02T07:48:41.854Z","updated":"2021-07-02T07:52:26.056Z","comments":true,"path":"wiki/Android/进阶知识/Android中的ClassLoader/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/Android%E4%B8%AD%E7%9A%84ClassLoader/","excerpt":"","text":"概述 BootClassLoader:主要用于加载系统的类，包括 java 和 android 系统的 类库，和 JVM 中不同，BootClassLoader 是 ClassLoader 内部类，是由 Java 实现的，它也是所有系统 ClassLoader 的父 ClassLoader PathClassLoader:用于加载 Android 系统类和开发编写应用的类，只能加载已经安装应用的 dex 或 apk 文件，也是 getSystemClassLoader 的返回对象 DexClassLoader:可以用于加载任意路径的 zip,jar 或者 apk 文件，也是进行安卓动态加载的基础 继承关系","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ClassLoader","slug":"Java/进阶/ClassLoader","date":"2021-07-01T13:18:40.853Z","updated":"2021-07-01T13:18:54.378Z","comments":true,"path":"wiki/Java/进阶/ClassLoader/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/ClassLoader/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"双亲委派机制","slug":"Java/进阶/双亲委派机制","date":"2021-07-01T13:18:13.313Z","updated":"2021-07-02T07:46:41.341Z","comments":true,"path":"wiki/Java/进阶/双亲委派机制/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Bootstrap ClassLoader:使用 C++实现，是虚拟机的一部分。它主要负责 加载存放在%JAVAHOME%/lib 目录中的，或者被-Xbootclasspath 指定的类库到虚拟机内存中，Bootstrap ClassLoader 无法被 java 程序直接引用。 Extension ClassLoader:主要负责加载%JAVAHOME%/lib/ext 目录中的， 或者被 java.ext.dirs 系统变量指定路径的所有类。 Application ClassLoader:也被称为系统类加载器(因为其实 getSystemClassLoader 的返回对象)，主要负责加载用户类路径(ClassPath) 下的类库 工作流程讲解12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized(this.getClassLoadingLock(name)) &#123; Class var4 = this.findLoadedClass(name); // 检查需要加载的类是否已经被加载过 if (var4 == null) &#123; long var5 = System.nanoTime(); try &#123; // 若没有加载，则调用父加载器的 loadClass()方法 if (this.parent != null) &#123; var4 = this.parent.loadClass(name, false); &#125; else &#123; var4 = this.findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException name0) &#123; // 若父类加载器加载失败会抛出 ClassNotFoundException， //说明父类加载器无法完成加载请求 &#125; if (var4 == null) &#123; long var7 = System.nanoTime(); // 在父类加载器无法加载时 // 再调用本身的 findClass 方法进行类加载 var4 = this.findClass(name); PerfCounter.getParentDelegationTime().addTime(var7 - var5); PerfCounter.getFindClassTime().addElapsedTimeFrom(var7); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; this.resolveClass(var4); &#125; return var4; &#125;&#125; 若一个类加载器收到了类加载请求： 把该类加载请求委派给父类加载器去完成，而不会自己去加载该类每层的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中 只有当父类加载器反馈自己无法完成该加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会自己去加载","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Dalvik、ART虚拟机","slug":"Android/进阶知识/Dalvik、ART虚拟机","date":"2021-07-01T13:15:51.951Z","updated":"2021-07-02T02:14:11.452Z","comments":true,"path":"wiki/Android/进阶知识/Dalvik、ART虚拟机/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/Dalvik%E3%80%81ART%E8%99%9A%E6%8B%9F%E6%9C%BA/","excerpt":"","text":"概要Dalvik 是 Google 公司自己设计用于 Android 平台的虚拟机。它可以支持已转换为** .dex 格式**的 Java 应用程序的运行，.dex 格式是专为Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统。 Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的 Linux 进程执行。独立的进程可以防止在虚拟机 崩溃的时候所有程序都被关闭。 2014 年 6 月 25 日，Android L 正式亮相于召开的谷歌 I/O 大会，Android L 改 动幅度较大，谷歌将直接删除 Dalvik，代替它的是传闻已久的 ART。 Dalvik与JVM的区别 Dalvik 是基于寄存器的，而 JVM 是基于栈的。 Dalvik 运行 dex 文件，而 JVM 运行 java 字节码 自 Android 2.2 开始，Dalvik 支持 JIT(just-in-time，即时编译技术)。 ART（Android Runtime）ART 的机制与 Dalvik 不同。在 Dalvik 下，应用每次运行的时候，字节码都需要通过即时编译器(just in time ，JIT)转换为机器码，这会拖慢应用的运行效率，而在 ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码， 使其成为真正的本地应用。这个过程叫做预编译(AOT,Ahead-Of-Time)。这样 的话，应用的启动(首次)和执行都会变得更加快速。 优点 系统性能的显著提升。 应用启动更快、运行更快、体验更流畅、触感反馈更及时。 更长的电池续航能力。 支持更低的硬件。 缺点 机器码占用的存储空间更大，字节码变为机器码之后，可能会增加 10%-20% 应用的安装时间会变长。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ThreadPoolExecutor原理分析","slug":"Java/并发编程/ThreadPoolExecutor原理分析","date":"2021-07-01T12:23:15.147Z","updated":"2021-07-01T12:56:06.129Z","comments":true,"path":"wiki/Java/并发编程/ThreadPoolExecutor原理分析/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"线程池状态1234567private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 当创建线程池后，初始时，线程池处于 RUNNING 状态;如果调用了 shutdown()方法，则线程池处于 SHUTDOWN 状态，此时线程池不 能够接受新的任务，它会等待所有任务执行完毕;如果调用了 shutdownNow()方法，则线程池处于 STOP 状态，此时线程池不能 接受新的任务，并且会去尝试终止正在执行的任务;当线程池处于 SHUTDOWN 或 STOP 状态，并且所有工作线程已经销毁，任务缓 存队列已经清空或执行结束后，线程池被设置为 TERMINATED 状态。 任务的执行1234567891011121314private final BlockingQueue&lt;Runnable&gt; workQueue;//任务缓存队列，用来存放等待执行的任务private final ReentrantLock mainLock = new ReentrantLock();//线程池的主要状态锁，对线程池状态(比如线程池大小、runState 等的改变都要使用这个锁)private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();//用来存放工作集private volatile long keepAliveTime;//线程存货时间private volatile boolean allowCoreThreadTimeOut;//是否允许为核心线程设置存活时间private volatile int corePoolSize;//核心池的大小(即线程池中的线程数目大于这 个参数时，提交的任务会被放进任务缓存队列)private volatile int maximumPoolSize;//线程池最大能容忍的线程数public int getPoolSize()&#123;&#125;//获取当前线程池的线程数量private volatile RejectedExecutionHandler handler;//任务拒绝策略private volatile ThreadFactory threadFactory;//线程工厂，用来创建线程private int largestPoolSize;//用来记录线程池中曾经出现过的最大线程数private long completedTaskCount;//用来记录已经执行完毕的任务个数 最核心的任务提交方法是 execute()方法，虽然通 过 submit 也可以提交任务，但是实际上 submit 方法里面最终调用的还是 execute()方法 12345678910111213141516171819public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command);&#125; 分三步： If fewer than corePoolSize threads are running, try tostart a new thread with the given command as its firsttask. The call to addWorker atomically checks runState andworkerCount, and so prevents false alarms that would addthreads when it shouldn’t, by returning false. If a task can be successfully queued, then we still needto double-check whether we should have added a thread(because existing ones died since last checking) or thatthe pool shut down since entry into this method. So werecheck state and if necessary roll back the enqueuing ifstopped, or start a new thread if there are none. If we cannot queue task, then we try to add a newthread. If it fails, we know we are shut down or saturatedand so reject the task. 线程池中的线程初始化addWorker中进行初始化，创建一个Worker，Worker内部从threadFactory中获取Thread。 在Thread的run方法中会调用getTask，来获取任务来执行。 12345678910111213141516171819202122232425262728293031323334353637private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 任务缓存队列及排队策略workQueue的类型为BlockingQueue，通常可以取下面三种类型: ArrayBlockingQueue:基于数组的先进先出队列，此队列创建时必须指定大小; LinkedBlockingQueue:基于链表的先进先出队列，如果创建时没有指定此 队列大小，则默认为 Integer.MAX_VALUE; SynchronousQueue:这个队列比较特殊，它不会保存提交的任务，而是将直 接新建一个线程来执行新来的任务。 任务拒绝策略当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略: ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出 RejectedExecutionException 异常。 ThreadPoolExecutor.DiscardPolicy:也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy:丢弃队列最前面的任务，然后重新尝试执行任务(重复此过程) ThreadPoolExecutor.CallerRunsPolicy:由调用线程处理该任务 线程池的关闭ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown()和 shutdownNow()，其中： shutdown():不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 shutdownNow():立即终止线程池，并尝试打断正在执行的任务，并且清 空任务缓存队列，返回尚未执行的任务 线程池容量的动态调整 setCorePoolSize:设置核心池大小 setMaximumPoolSize:设置线程池最大能创建的线程数目大小","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"如何提升编译速度","slug":"Android/进阶知识/如何提升编译速度","date":"2021-07-01T09:52:29.670Z","updated":"2021-07-01T09:52:39.236Z","comments":true,"path":"wiki/Android/进阶知识/如何提升编译速度/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ASM","slug":"Java/开源库/ASM","date":"2021-07-01T07:42:53.933Z","updated":"2021-07-01T11:56:02.198Z","comments":true,"path":"wiki/Java/开源库/ASM/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%BC%80%E6%BA%90%E5%BA%93/ASM/","excerpt":"","text":"插桩 参考 https://asm.ow2.io/index.html https://github.com/Leifzhang/AndroidAutoTrack","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"开源库","slug":"Java/开源库","permalink":"http://shjlone.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"自定义View之Canvas","slug":"Android/UI/自定义View之Canvas","date":"2021-06-30T05:51:29.770Z","updated":"2021-07-14T03:55:30.420Z","comments":true,"path":"wiki/Android/UI/自定义View之Canvas/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BCanvas/","excerpt":"","text":"API颜色填充1234canvas.drawColor(Color.BLACK);canvas.drawColor(Color.parse(&quot;#88880000&quot;); // 半透明红色canvas.drawRGB(100, 200, 100);canvas.drawARGB(100, 100, 200, 100); 画圆12345678/**前两个参数 centerX centerY 是圆心的坐标，第三个参数 radius 是圆的半径，单位都是像素*/drawCircle(float centerX, float centerY, float radius, Paint paint) canvas.drawCircle(300, 300, 200, paint); 画矩形12345paint.setStyle(Style.FILL);canvas.drawRect(100, 100, 500, 500, paint);paint.setStyle(Style.STROKE);canvas.drawRect(700, 100, 1100, 500, paint); 画点12345678910111213141516171819202122/**x 和 y 是点的坐标*/drawPoint(float x, float y, Paint paint)paint.setStrokeWidth(20);paint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(50, 50, paint);/**pts 这个数组是点的坐标，每两个成一对offset 表示跳过数组的前几个数再开始记坐标；count 表示一共要绘制几个点*/drawPoints(float[] pts, int offset, int count, Paint paint)drawPoints(float[] pts, Paint paint) float points = &#123;0, 0, 50, 50, 50, 100, 100, 50, 100, 100, 150, 50, 150, 100&#125;;// 绘制四个点：(50, 50) (50, 100) (100, 50) (100, 100)canvas.drawPoints(points, 2 /* 跳过两个数，即前两个 0 */, 8 /* 一共绘制 8 个数（4 个点）*/, paint); 画椭圆12345/**left, top, right, bottom 是这个椭圆的左、上、右、下四个边界点的坐标。*/drawOval(float left, float top, float right, float bottom, Paint paint) 画线1234567891011121314151617/**startX, startY, stopX, stopY 分别是线的起点和终点坐标。*/drawLine(float startX, float startY, float stopX, float stopY, Paint paint) canvas.drawLine(200, 200, 800, 500, paint);/**批量画线*/drawLines(float[] pts, int offset, int count, Paint paint) drawLines(float[] pts, Paint paint)float points = &#123;20, 20, 120, 20, 70, 20, 70, 120, 20, 120, 120, 120, 150, 20, 250, 20, 150, 20, 150, 120, 250, 20, 250, 120, 150, 120, 250, 120&#125;;canvas.drawLines(points, paint); 画圆角矩形12345678/**left, top, right, bottom 是四条边的坐标，rx 和 ry 是圆角的横向半径和纵向半径。*/drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)canvas.drawRoundRect(100, 100, 500, 300, 50, 50, paint); 弧形或扇形12345678910111213141516/**drawArc() 是使用一个椭圆来描述弧形的。left, top, right, bottom 描述的是这个弧形所在的椭圆；startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），sweepAngle 是弧形划过的角度；useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。*/drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) paint.setStyle(Paint.Style.FILL); // 填充模式canvas.drawArc(200, 100, 800, 500, -110, 100, true, paint); // 绘制扇形canvas.drawArc(200, 100, 800, 500, 20, 140, false, paint); // 绘制弧形paint.setStyle(Paint.Style.STROKE); // 画线模式canvas.drawArc(200, 100, 800, 500, 180, 60, false, paint); // 绘制不封口的弧形 画自定义图形123456drawPath(Path path, Paint paint) 画 Bitmap123drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 绘制文字 drawText() drawTextRun() drawTextOnPath() 1234drawText(String text, float x, float y, Paint paint)canvas.drawText(text, 200, 100, paint); 范围裁切clipRect1234canvas.save();canvas.clipRect(left, top, right, bottom);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore(); clipPath12345canvas.save();canvas.clipPath(path1);canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 几何变换 使用 Canvas 来做常见的二维变换； 使用 Matrix 来做常见和不常见的二维变换； 使用 Camera 来做三维变换。 Canvas二维变换12345678910111213141516171819202122232425//translate平移canvas.save();canvas.translate(200, 0);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore();//旋转canvas.save();canvas.rotate(45, centerX, centerY);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore();//缩放canvas.save();canvas.scale(1.3f, 1.3f, x + bitmapWidth / 2, y + bitmapHeight / 2);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore();//错切canvas.save();canvas.skew(0, 0.5f);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore(); Matrix二维变换Matrix 做常见变换的方式： 创建 Matrix 对象； 调用 Matrix 的 pre/postTranslate/Rotate/Scale/Skew() 方法来设置几何变换； 使用 Canvas.setMatrix(matrix) 或 Canvas.concat(matrix) 来把几何变换应用到 Canvas。 1234567891011121314Matrix matrix = new Matrix();...matrix.reset();matrix.postTranslate();matrix.postRotate();canvas.save();canvas.concat(matrix);canvas.drawBitmap(bitmap, x, y, paint);canvas.restore(); Camera三维变换123456789canvas.save();camera.save(); // 保存 Camera 的状态camera.rotateX(30); // 旋转 Camera 的三维空间camera.applyToCanvas(canvas); // 把旋转投影到 Canvascamera.restore(); // 恢复 Camera 的状态canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 参考 https://rengwuxian.com/ui-1-1/ https://rengwuxian.com/ui-1-4/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"硬件加速","slug":"Android/进阶知识/硬件加速","date":"2021-06-30T02:44:08.221Z","updated":"2021-07-20T09:44:15.997Z","comments":true,"path":"wiki/Android/进阶知识/硬件加速/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/","excerpt":"","text":"参考 https://www.mtyun.com/library/hardware-accelerate https://rengwuxian.com/ui-1-8/ 理解Android硬件加速原理的小白文","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"屏幕适配","slug":"Android/进阶知识/屏幕适配","date":"2021-06-29T02:34:50.367Z","updated":"2021-07-02T07:33:38.530Z","comments":true,"path":"wiki/Android/进阶知识/屏幕适配/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/","excerpt":"","text":"基本概念屏幕尺寸屏幕尺寸指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米 屏幕分辨率屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点 屏幕像素密度屏幕像素密度是指每英寸上的像素点数 dp、dip、dpi、sp、px dpi：屏幕像素密度 dp/dip：Density Independent Pixels的缩写，即密度无关像素 px：物理像素 sp：scale-independent pixels，文字大小使用像素 公式转换 px = density * dp; density = dpi / 160; px = dp * (dpi / 160); 屏幕尺寸、分辨率、像素密度三者关系 DisplayMetrics中和适配相关的几个变量: DisplayMetrics#density：就是上述的density DisplayMetrics#densityDpi： 就是上述的dpi DisplayMetrics#scaledDensity： 字体的缩放因子，正常情况下和density相等，但是调节系统字体大小后会改变这个值 mdpi、hdpi、xdpi、xxdpi根据不同像素范围来存储的资源文件夹 名称 像素密度范围 代表的分辨率 屏幕密度 换算 比例 mdpi 120dpi~160dpi 320x480 160 hdpi 160dpi~240dpi 480x800 240 1dp=1px 4 xhdpi 240dpi~320dpi 720x1280 320 1dp=2px 8 xxhdpi 320dpi~480dpi 1080x1920 480 1dp=3px 12 xxxhdpi 480dpi~640dpi 适配原理今日头条适配方案12345678910111213141516171819202122232425262728293031DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();if (sNoncompatDensity == 0) &#123; sNoncompatDensity = appDisplayMetrics.density; sNoncompatDensity = appDisplayMetrics.scaledDensity; application.registerComponentCallbacks(new ComponentCallbacks() &#123; public void onConfigurationChanged(Configuration newConfig) &#123; if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) &#123; //系统字体大小发生变化监听 sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity; &#125; &#125; public void onLowMemory() &#123; &#125; &#125;);&#125;float targetDensity = appDisplayMetrics.widthPixels / 360;//360指设计图原始dp值float targetScaleDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity);int targetDensityDpi = (int) (160 * targetDensity);appDisplayMetrics.density = targetDensity;appDisplayMetrics.scaledDensity = targetScaleDensity;appDisplayMetrics.densityDpi = targetDensityDpi;final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();activityDisplayMetrics.density = targetDensity;activityDisplayMetrics.scaledDensity = targetScaleDensity;activityDisplayMetrics.densityDpi = targetDensityDpi; 根据设备的实际宽度与设计图的dp值，算出设备的密度和屏幕像素密度。 smallestWidth根据屏幕的最小宽度去寻找对应的配置文件，设置高宽值。可参考：SmallestWidth 限定符适配方案 总结综合各方面考虑，目前觉得AndroidAutoSize这个库比较适合接入到项目中。 参考 https://developer.android.com/guide/practices/screens_support?hl=zh-cn https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA http://jessyan.me/autosize-introduce/ https://www.jianshu.com/p/5d4504fc599a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"RxAndroid","slug":"Android/开源库/RxAndroid","date":"2021-06-28T06:08:24.279Z","updated":"2021-06-28T06:22:03.455Z","comments":true,"path":"wiki/Android/开源库/RxAndroid/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/RxAndroid/","excerpt":"","text":"Schedulers参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"KOOM","slug":"Android/开源库/KOOM","date":"2021-06-25T06:52:40.869Z","updated":"2021-06-25T10:03:54.616Z","comments":true,"path":"wiki/Android/开源库/KOOM/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/KOOM/","excerpt":"","text":"KOOM ：OOM分析工具 流程初始化后，10秒后启动一个线程，每5秒轮询检测。当满足条件（比如内存不够用），启动一个新的进程，进行内存泄漏分析、裁剪、保存分析信息。内存泄漏的判断是通过读取shark获取的heapGraph，判断Activity、Fragment、Bitmap等是否存在泄漏。 KOOMEnableChecker有一些限制条件，不满足条件的则不能进行监控。 sharkshark-graph：square的开源库。文档地址：https://square.github.io/leakcanary/api/shark/shark/ xhookxhook：爱奇艺的开源库，用于hook动态库。文档地址：https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md Get到的知识点Handler的用法Handler执行一个Runnable方法，可以直接使用以下的方式来执行类方法 1koomHandler.post(this::manualTriggerInternal); ResultReceiver使用ResultReceiver进行进程间通信，这个类也挺简单的，实现序列化接口。构造函数接受一个Handler。没有序列化的情况下使用Handler通信，序列化后使用Binder通信。send发送消息，onReceiveResult接收消息。 参考 https://github.com/KwaiAppTeam/KOOM https://www.gushiciku.cn/pl/p3Rl https://square.github.io/leakcanary/api/shark/shark/ https://github.com/iqiyi/xHook","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"关于KPI","slug":"技术开发/技术管理/关于KPI","date":"2021-06-25T04:00:58.344Z","updated":"2021-06-25T04:01:04.518Z","comments":true,"path":"wiki/技术开发/技术管理/关于KPI/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EKPI/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://shjlone.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"开发流程的思考","slug":"技术开发/技术管理/开发流程的思考","date":"2021-06-25T04:00:24.276Z","updated":"2021-06-28T13:09:50.702Z","comments":true,"path":"wiki/技术开发/技术管理/开发流程的思考/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"目前大多数互联网公司的开发流程如下图： 需求收集一个新功能的出现，可能来自多个地方。运营觉得有了XX功能，用户量就能增加XX倍；产品觉得XX竟品做了XX功能，我们也要做个一模一样的；开发觉得XX库又提升了XX性能。版本初期，一般由产品统一收集相关需求。 产品文档、设计文档这个阶段，产品开始整理前面收集到的idea。他不太清楚的点可能会找开发、测试。比如XX功能技术上是否可行。然后开始写产品文档。完成后，会进行需求宣讲，开发、测试同事会参与。这个过程中，开发、测试会提出自己的意见，产品方进行解答。没问题后，该需求会进入设计阶段。这个阶段中，开发人员会根据需求进行概要设计，比如了解需要用到的技术，看看里面有什么坑。 开发阶段当设计稿完成后，该需求会进入到开发阶段。开发人员拿到需求后，一般的小厂就开始对着产品文档、设计稿开发了，大厂会做详细设计，比如画流程图。开发完成后，小厂就直接进入测试阶段了，做的稍微好点，开发会进行简单的自我测试，稍微再好点的，可能会自己写些测试脚本。而大厂会有其他的一些流程，比如单元测试、集成测试，开发完成后，进行代码Review。开发的过程中还牵扯到前后端联调，所以在刚开始开发时，做同一个需求的不同端同事应该沟通好联调相关事宜。 开发阶段，测试同事也会同步了解需求，并完成相关测试用例。 测试阶段这个阶段就是发现bug、改bug的循环，当把测试发现的所有bug改完后，就达到灰度条件了。 上线阶段灰度的作用是进行少量的更新，检查新上线的需求是否存在问题，将风险降到最低。当灰度一段时间后，App的崩溃率在正常范围内时，即可安排正式上线。 思考有些小厂为了能快速的上线，会省掉其中的一些环节，而那些环节恰恰又是很重要的。为什么会经常在线上出锅，一方面来自测试的不严谨，漏掉了某些使用场景没测试，或者说就是没发现那些问题。一方面也来自开发人员，他们为了赶快，不会花很多心思去考虑代码的复用、性能问题。结果造成问题频繁出现。 代码review个人觉得是非常有必要去做的一件事情，让资深的工程师来review其他人的代码，一方面能发现问题，一方面对于被review方，也是快速提升的好机会。 还有单元测试、集成测试，这些虽然做的时候可能会多花一些时间，但当项目不断迭代，他们也是发现问题的重要方式。现实环境中，很多小厂都是不会考虑这方面的。 现在市面上出现了很多项目管理的工具，个人是不建议同时使用多个工具。来回切换麻烦，数据也无法统一处理。其实大家都大同小异，而且大部分的定制化程度很是蛮高的，完全可以在一款工具中，进行相关的定制来达到自己的目的。比如TAPD就实现了从需求收集到项目上线整个流程的管理方案。 项目的进度可以通过相应的工具来管理，项目的质量则更多的应该通过人来管理。只有让团队成员的技术都变得强大了，整体的代码质量才会稳定。光抓进度不管质量，项目迟早有一点会掉到大坑里面。","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://shjlone.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"设计原则","slug":"设计模式/设计原则","date":"2021-06-21T12:09:59.222Z","updated":"2021-07-13T03:19:14.081Z","comments":true,"path":"wiki/设计模式/设计原则/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】： 一个类负责一项职责。 里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】： 继承与派生的规则。 依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】： 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】： 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 隔离的定义: 客户端不应该依赖它不需要的接口。 类间的关系应该建立在最小的接口上。 迪米特原则【LOW OF DEMETER】： 也叫“最少知识”原则，低耦合，高内聚。 开闭原则【OPEN CLOSE PRINCIPLE】： 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】： 尽量使用组合和聚合少使用继承的关系来达到复用的原则。 参考","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"emoji表情处理","slug":"PyQt/emoji表情处理","date":"2021-06-21T12:09:59.221Z","updated":"2021-06-21T12:09:59.221Z","comments":true,"path":"wiki/PyQt/emoji表情处理/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/emoji%E8%A1%A8%E6%83%85%E5%A4%84%E7%90%86/","excerpt":"","text":"在QLabel上显示emoji表情，win10和win7显示的效果不一样，win10能显示出彩色的，但win7只能显示黑白色，且有些表情甚至不能显示。 不同系统的实现效果都是不一样的，所以要实现统一，最好的方式就是自己实现，通过其unicode值建立一套对应的图片，显示的时候，直接绘制本地的图片。而不走系统渲染。 参考 https://appuals.com/how-to-get-windows-10-emojis-on-windows-7-8/ 这篇文章说明win7是不支持的系统显示彩色emoji的 https://github.com/carpedm20/emoji unicode值和对应表情的字符串之间的互相转换，有一些非标准的emoji表情，比如**:thumbs_up:**表示 👍 https://github.com/googlefonts/noto-emoji google 彩色字体库 https://github.com/DeeDeeG/noto-color-emoji-font","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/tags/PyQt/"}]},{"title":"UML知识","slug":"设计模式/UML知识","date":"2021-06-21T12:09:59.221Z","updated":"2021-07-13T03:19:26.926Z","comments":true,"path":"wiki/设计模式/UML知识/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%9F%A5%E8%AF%86/","excerpt":"","text":"继承关系使用带空心箭头带实线 实现关系使用带空心箭头带虚线 聚合关系使用带空心菱形箭头的直线 聚合关系表示实体对象之间的关系，表示整体有部分构成。与组合关系有所不同，整体和部分不是强依赖的。比如：部门撤销了，人员还在。 组合关系使用带实心菱形箭头直线 组合关系是强依赖的，比如：公司不存在了，部门也就不存在了。 关联关系使用带箭头带实线 关联关系是一种静态关系，通常与运行状态无关。关联对象通常是以成员变量的形式实现的 依赖关系使用带箭头带虚线 描述一个对象在运行期间会用到另一个对象的关系。在代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是使用对方的方法和属性 参考 https://test-design-patterns.readthedocs.io/zh/latest/read_uml.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Handler使用不当造成的OOM","slug":"Android/性能优化/OOM专题/Handler使用不当造成的OOM","date":"2021-06-18T08:48:56.507Z","updated":"2021-06-18T09:05:44.190Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/Handler使用不当造成的OOM/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/Handler%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E9%80%A0%E6%88%90%E7%9A%84OOM/","excerpt":"","text":"问题重现编写以下代码 123456789101112131415161718public class OOMHandlerActivity extends Activity &#123; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); ((EditText) findViewById(R.id.oom_handler_edit_text)).setText(&quot;aaaas&quot;); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_oom_handler); mHandler.sendEmptyMessageDelayed(1, 1000 * 60); //这里注意，当延迟时间较小时，Profile中Leaks显示为0 &#125;&#125; 使用Android Studio自带的Profile进行监控，打开OOMHandlerActivity页面，然后返回上一个页面。Dump内存后，会出现以下提示： 原因分析依据Handler的实现原理，我们可知，内存泄漏的引用链如下： 主线程 —&gt; threadlocal —&gt; Looper —&gt; MessageQueue —&gt; Message —&gt; Handler —&gt; Activity 解决办法对于Handler的使用技巧，我们应该： 使用静态内部类的方式 如果需要处理宿主，则通过弱引用的传入进来 Activity生命周期结束时，释放Handler资源 参考以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lqd.androidpractice.oom.handler;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.widget.TextView;import com.lqd.androidpractice.R;import java.lang.ref.WeakReference;/** * @author: shjlone * @Date 2021/6/18 */public class OOMHandlerRightActivity extends Activity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView; //使用静态内部类 private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference;//使用弱引用 public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; OOMHandlerRightActivity activity = (OOMHandlerRightActivity) reference.get(); if (activity != null) &#123; activity.mTextView.setText(&quot;&quot;); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_oom_handler); mTextView = (TextView) findViewById(R.id.textview); mHandler.sendEmptyMessageDelayed(1, 1000 * 60); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mHandler.removeCallbacksAndMessages(null);//Activity销毁时同时移除handler的监听 &#125;&#125; 参考 https://www.cnblogs.com/jimuzz/p/14187408.html","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"WMRouter","slug":"Android/开源库/WMRouter","date":"2021-06-18T02:09:55.583Z","updated":"2021-07-02T07:24:01.529Z","comments":true,"path":"wiki/Android/开源库/WMRouter/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/WMRouter/","excerpt":"","text":"参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"GreenDao","slug":"Android/开源库/GreenDao","date":"2021-06-17T06:57:46.323Z","updated":"2021-06-17T06:58:13.959Z","comments":true,"path":"wiki/Android/开源库/GreenDao/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/GreenDao/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"《计算机是怎么跑起来的》读书笔记","slug":"读书笔记/计算机是怎样跑起来的","date":"2021-06-15T01:50:53.779Z","updated":"2021-06-15T01:50:53.780Z","comments":true,"path":"wiki/读书笔记/计算机是怎样跑起来的/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/","excerpt":"","text":"计算机三个根本性基础： 计算机是执行输入、运算、输出的机器； 程序是指令和数据的集合； 计算机的处理方式有时与人们的思维习惯不同。 计算机的硬件由大量集成电路组成。每块集成电路上都带有许多引脚。这些引脚有些用于输入，有些用于输出。 时钟发生器 操作数：操作数笔试是已存储在CPU寄存器中的数字。操作码 机器语言是唯一一种cpu能直接理解的编程语言。 CPU内部存储数据的地方也具备对数据进行计算的能力。有些寄存器中存储着接下来要执行的指令的地址。程序就是依靠着不断变花的寄存器的值运行起来的。 cpu信息cpu的种类：不同的CPU对于二进制的理解是不一样的。时钟信号的频率：时钟发生器发送给cpu的电信号的频率。表示时钟信号频率的单位是MHz（兆赫兹=100万回/秒）。时钟信号是在0和1之间反复变换的电信号。通常把发出一次滴答的时间称作一个时钟周期。 内存信息地址空间每个地址中可以存储多少比特的信息 I/O信息I/O的种类地址空间连接着何种周边设备 最低限度所需的流程图符号 网卡地址前半部分表示生产商，后半部分表示编号。 子网掩码的作用是标识出在32比特的IP地址中，从哪一位到哪一位是网络地址，从哪一位到哪一位是主机地址。255.255.255.240用二进制表示：11111111.11111111.11111111.11110000值为1的那些位对应着IP地址中的网络地址，后面为0的那些则对应着主机地址。 DHCP：Dynamic Host Configuration Protocol 动态主机设置协议 tracert ARP：Address Resolution Protocol，地址解析协议，用于实现由IP地址到MAC地址的转换arp -a 查询apr缓存表 硬件商发送数据的是网卡，网卡之上是设备驱动程序，之上是实现了IP协议的程序，之上是实现了TCP协议的程序，再之上才是应用程序。TCP协议使用“TCP端口号”的数字识别上层的应用程序。TCP端口中有一些是预先定义好的，比如Web使用80端口，电子邮件使用25端口（用于发送）","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"读书笔记6：存储器层次结构","slug":"读书笔记/深入理解计算机/读书笔记6-存储器层次结构","date":"2021-06-15T01:50:53.779Z","updated":"2021-06-24T11:34:54.717Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记6-存储器层次结构/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B06-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记7：链接","slug":"读书笔记/深入理解计算机/读书笔记7-链接","date":"2021-06-15T01:50:53.779Z","updated":"2021-06-24T11:34:54.708Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记7-链接/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B07-%E9%93%BE%E6%8E%A5/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记8：异常流控制","slug":"读书笔记/深入理解计算机/读书笔记8-异常流控制","date":"2021-06-15T01:50:53.779Z","updated":"2021-06-24T11:34:54.720Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记8-异常流控制/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B08-%E5%BC%82%E5%B8%B8%E6%B5%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记9：虚拟内存","slug":"读书笔记/深入理解计算机/读书笔记9-虚拟内存","date":"2021-06-15T01:50:53.779Z","updated":"2021-06-24T11:34:54.673Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记9-虚拟内存/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B09-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记2：信息的表示和处理","slug":"读书笔记/深入理解计算机/读书笔记2-信息的表示和处理","date":"2021-06-15T01:50:53.778Z","updated":"2021-06-24T11:34:54.713Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记2-信息的表示和处理/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程 原码、反码、补码","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记3：程序的机器级表示","slug":"读书笔记/深入理解计算机/读书笔记3-程序的机器级表示","date":"2021-06-15T01:50:53.778Z","updated":"2021-06-24T11:34:54.722Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记3-程序的机器级表示/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记3：处理器体系结构","slug":"读书笔记/深入理解计算机/读书笔记4-处理器体系结构","date":"2021-06-15T01:50:53.778Z","updated":"2021-06-24T11:34:54.723Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记4-处理器体系结构/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记5：优化程序性能","slug":"读书笔记/深入理解计算机/读书笔记5-优化程序层次结构","date":"2021-06-15T01:50:53.778Z","updated":"2021-06-24T11:34:54.671Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记5-优化程序层次结构/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B05-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记11：网络编程","slug":"读书笔记/深入理解计算机/读书笔记11-网络编程","date":"2021-06-15T01:50:53.777Z","updated":"2021-06-24T11:34:54.725Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记11-网络编程/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B011-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记12：并发编程","slug":"读书笔记/深入理解计算机/读书笔记12-并发编程","date":"2021-06-15T01:50:53.777Z","updated":"2021-07-13T12:54:41.868Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记12-并发编程/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B012-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程 现代操作系统提供三种基本的构造并发程序的方法： 进程 I/O多路复用（select、poll、epoll） 线程 基于进程的并发编程基于I/O多路复用的并发编程基于线程的并发编程多线程程序中的共享变量用信号量同步线程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记1：计算机系统漫游","slug":"读书笔记/深入理解计算机/读书笔记1-计算机系统漫游","date":"2021-06-15T01:50:53.776Z","updated":"2021-06-24T11:35:31.467Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记1-计算机系统漫游/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程 计算机系统漫游本章只是对整个计算机体系进行概要的介绍，很多主题扩展开来又可以写一本很厚的书了。在阅读此章时，有个大概了解即可。 hello world源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文。 下图描述了一个c程序是如何被编译运行的。 关于计算机的构成 关于存储器 分层，高层提供给低层高速缓存，越高层性能越好，价格越贵。 计算机抽象的表示 关于shellshell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。 操作系统的两个基本功能： 防止硬件被失控的应用程序滥用； 向应用程序提成简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。 Posix的由来20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使他们的程序与众不同，为了阻止这种趋势，IEEE开始标准化Unix的开发，后来由Richard Stallman命名为“Posix”。结果就得到了一些列的标准，称作Posix标准。 并发运行一个进程的指令和另一个进程的指令是交错执行的。 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文。 进程间切换的交错执行的机制称为上下文切换。 Amdahl定律 a表示可以提升部分的比例 k表示可提升部分性能提升的比例","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"读书笔记10：系统级I/O","slug":"读书笔记/深入理解计算机/读书笔记10-系统级IO","date":"2021-06-15T01:50:53.776Z","updated":"2021-06-24T11:34:54.711Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记10-系统级IO/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B010-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《图解TCP/IP》读书笔记","slug":"读书笔记/图解TCPIP","date":"2021-06-15T01:50:53.775Z","updated":"2021-06-15T01:50:53.775Z","comments":true,"path":"wiki/读书笔记/图解TCPIP/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3TCPIP/","excerpt":"","text":"OSI参考模型 名字 描述 网卡 使计算机联网的设备 中继器（Repeater） 从物理层上延长网络的设备 2 网桥（Bridge） 从数据链路层上延长网络的设备 3 路由器 通过网络层转发分组数据的设备 4~7 交换机 处理传输层以上各层网络传输的设备 网管（Gateway） 转换协议的设备 数据链路名 通信媒介 传输速率 主要用途 以太网 同轴电缆 10Mbps LAN _ 双绞线电缆 10Mbps~100Gbps LAN _ 光纤电缆10Mbps~100Gbps LAN 无线 电磁波 数个Mbps LAN~WAN ATM 双绞线电缆光纤电缆 25Mbps155Mbps622Mbps LAN~WAN FDDI 光纤电缆双绞线电缆 100Mbps LAN~-WAN 帧中继 双绞线电缆光纤电缆 约64~1.5Mbps WAN ISDBN 双绞线电缆光纤电缆 64~1.5Mbps WAN 在数据传输过程中，两个设备之间数据流动的物理速度称为传输速率，单位为bps（Bits Per Second），传输速率高指单位时间内传输的数据量有多少。传输速率又称为带宽（Bandwidth） 协议规范https://www.rfc-editor.org/rfc 以太网协议https://www.iana.org/assignments/ethernet-numbers/ethernet-numbers.xhtml 分类 通信距离 标准化组织 相关其他组织及技术 短距离无线 数米 个别组织 RF-ID 无线PAN 10米左右 IEEE802.15 蓝牙 无线LAN 100米左右 IEEE802.11 Wi-Fi 无线MAN 数千米~100千米 IEEE802.16IEEE802.20 WiMAX 无线RAN 200千米~700千米 IEEE802.22 无线WAN GSM、CDMA2000、W-CDMA 3G、LTE、4G http://grouper.ieee.org/groups/802/11/Reports/802.11_Timelines.htm PPP：Point to Point ProtocolATM：Asynchronous Transfer Mode IP寻址路由IP分包和组包 IP是面向无连接的","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《Java编程思想》读书笔记","slug":"读书笔记/Java编程思想/Java编程思想","date":"2021-06-15T01:50:53.774Z","updated":"2021-07-08T12:26:36.340Z","comments":true,"path":"wiki/读书笔记/Java编程思想/Java编程思想/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/","excerpt":"","text":"final finally finalize finalize()主要是给其他调用而创建的空间在对象回 收时页同步回收而设置的。 比如，你调用了C语言，使用了mallow()开辟了一段内存空间。在你释放java对象的时候，虚拟机只能释放java对象占用的空间，而不能释放C开辟的内存空间，所你 你在释放此对象之前要先回收你在C语言中开辟的空间。 这各时候才用到finalize()方法。平时的 时候不要随便使用finalize()方法。","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java编程思想","slug":"读书笔记/Java编程思想","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"第15章：泛型","slug":"读书笔记/Java编程思想/第15章：泛型","date":"2021-06-15T01:50:53.774Z","updated":"2021-06-15T01:50:53.774Z","comments":true,"path":"wiki/读书笔记/Java编程思想/第15章：泛型/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义的类，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。 泛型实现了参数化类型的概念，使代码可以应用于多种类型。 容器类是引入泛型的一个重要原因 Java中，return语句只允许返回单个对象，通过泛型，则可以返回多个对象。这个概念成为元祖（tuple），它将一组对象直接打包存储于其中一个单一对象。 元祖可以具有任意长度，任意类型。 泛型方法使用泛型方法时，会进行类型参数推断，如果传入基本类型，则会自动打包 1234567891011public class GenericMethods &#123; public &lt;T&gt; void f(T x) &#123; System.out.println(x.getClass().getName()); &#125; /* public static T f(T a)&#123; //编译不通过 return a; &#125; */&#125; 普通static方法无法访问泛型类的类型参数，如果要是使用泛型就要定义成泛型静态方法。类的泛型要在创建对象时才确定，而类内的静态方法，静态域在类加载时初始化，因此如果使用类的泛型类型则初始化时无法知道具体类型是什么，此时使用泛型方法这样就和类的泛型无关了，这样静态方法初始化时类型只和自身的泛型相关。 泛型方法返回值是泛型，那么就返回一个泛型，不能是具体类型，反之亦然。 123public static &lt;T&gt; Set&lt;T&gt; set()&#123; // return new HashSet&lt;String&gt;(); //不能返回具体类型&#125; 泛型的一个重要好处是能够简单而安全的创建复杂的模型 可变参数泛型方法 擦除 jvm并不认识泛型因此需要将泛型擦除。 ArrayList 和 ArrayList很容易被认为是不同类型。因为他们有不同的行为，但程序却认为他们是相同的，正是因为擦除的存在。 擦除的结果就是把一个对象变为它的原生类 泛型只是用来检查类型正确性，泛型部分的代码不会参与运行，这是由于泛型的擦除作用。 泛型代码内部无法获得有关泛型参数的类型的信息。 泛型擦除到第一个边界 上界 意思就是T 只能为HasF或者其子类。 泛型只是在静态类型检查期间出现来验证类型正确性，程序一但运行后泛型都将被擦除，替换成他们的非泛型上界，如List被擦除为List，List被擦除为List, 擦除为 擦除动机 擦除使得泛化的代码变得具体，因此泛化客户端可以使用非泛化类库，非泛化客户端也可以使用泛化类库。 擦除的代价 泛型不能当做一个类去操作，如Foo&lt;Cat&gt; cat不能代表Cat这个类，因为它会被擦除为Object. 边界处的动作 边界就是对象进入和离开方法的地方，编译期执行类型检查和插入转型代码就是在边界处。 编译期执行了类型检查确保了数据一致性，在离开方法时由编译器为你插入转型代码执行转型，此时转型是安全的。 由于擦除kind实际被存储为Class，因此创建数组无法后知道要转型成什么类型，因此必须强转。但创建容器就不需要强转了，编译期可以保证类型的一致性，如果类型不一致不通过编译。 边界 强制泛型可以使用什么类型 按边界类型调用方法其方法，无边界的只能调用从Objec继承的方法。 通配符 通配符可以允许某种类型向上转型,与普通边界对比: List first = new ArrayList(); 只能使用TList&lt;? extends Fruit&gt; first = new ArrayList(); //可以使用各种Fruit的子类。List&lt;? extends Fruit&gt; 读作具有任何从Fruit继承的类型列表。 上界 ？是Fruit 的子类，但具体是什么不知道，因此当调用get方法时返回的对象可以赋值给Fruit引用,而add添加对象时由于不清楚具体要添加什么子类所以无法使用add方法。 超类型通配符 下界 也称 逆变？是Apple的父类，但具体是什么类型不得而知，因此当调用add方法添加对象时可以添加Apple和其子类对象，但调用get方法时无法确定要返回什么类型，因此不能调用get方法返回具体类型，只能返回Object。 无界通配符 与上下界之间的区别 - 一个方法的参数的类型如是 List ，List ，则可以接收任何形式的List参数，参数是不是泛型无所谓。 参数的类型如果是List&lt;? extends/super A &gt; ，则只能接收泛型的List参数. 如果参数的类型是 &lt;?&gt; 或者 &lt;? extends A&gt;，则该方法无法调用 可以向上转型 多个泛型参数下只有全为？时编译器无法与原生类区分，但只要有过一个参数不是？就会有所区分如Map&lt;String, ?&gt;必须传入map&lt;String,?&gt;类型的参数，而Map可以传入new HashMap();","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java编程思想","slug":"读书笔记/Java编程思想","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"第20章：注解","slug":"读书笔记/Java编程思想/第20章：注解","date":"2021-06-15T01:50:53.774Z","updated":"2021-06-15T01:50:53.775Z","comments":true,"path":"wiki/读书笔记/Java编程思想/第20章：注解/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%AC%AC20%E7%AB%A0%EF%BC%9A%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"参考","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java编程思想","slug":"读书笔记/Java编程思想","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"线性表","slug":"数据结构/线性表","date":"2021-06-15T01:50:53.773Z","updated":"2021-06-15T01:50:53.773Z","comments":true,"path":"wiki/数据结构/线性表/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"定义线性表（Linear List）是具有相同特性的数据元素的一个有限序列。该序列中所含元素的个数叫做线性表的长度，用n表示，n&gt;=0。当n=0时，表示线性表是一个空表。设序列中第i个元素为a1（1 ≤ i ≤ n），则线性表的一般表示为： (a1,a2,a3,…,ai,…,an) 特性 元素在位置上是有序的 长度是可变的 线性存储将数据依次存储在连续的整块物理空间中。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。 链式存储数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系。 在线性表的链接存储中，存储的第一个元素的结点称为表头结点，存储最后一个元素的结点称为表尾结点，其余为中间结点。每个链接表都需要设置一个指针指向表头结点，称为表头指针。从表头指针出发，沿着结点的链可以访问到每一个结点。 链接表由于每个结点带有指针域，因而在存储空间上比线性存储要付出较大代价。由于每个结点的存储位置可以任意安排，因此插入、删除操作方便又省时。 单链表 双链表 循环双链表尾结点的下一个结点是头结点。 代码实现","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树","slug":"数据结构/树","date":"2021-06-15T01:50:53.772Z","updated":"2021-06-15T01:50:53.772Z","comments":true,"path":"wiki/数据结构/树/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/","excerpt":"","text":"定义 树是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树的术语 节点的度：一个节点含有的子树的个数称为该节点的度； 树的度：一棵树中，最大的节点的度称为树的度； 叶节点或终端节点：度为零的节点； 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点：具有相同父节点的节点互称为兄弟节点； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度：树中节点的最大层次； 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 节点的祖先：从根到该节点所经分支上的所有节点； 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。 森林：由m（m ≥ 0）棵互不相交的树的集合称为森林； 树的种类 无序树： 树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树 有序树 树中任意节点的子节点之间有顺序关系，这种树称为有序树 二叉树：每个节点最多含有两个子树的树称为二叉树 完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树; 平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 排序二叉树： 霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树； B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。 树的性质 树中的节点数等于所有节点的度数加1。 度为k的树中第i层上至多有ki-1个节点（i ≥ 1）。 深度为h的k叉树至多有个节点 $\\frac{k^{h}-1}{h-1}$ 个节点。 具有n个节点的k叉树的最小深度为 ⌈$\\log_{k} (n(k-1)+1)$⌉ 二叉树 二叉树（Binary Tree）是指树的度为2的有序树。每个节点的左子树的根节点称为左孩子（left child），右子树的根节点称为右孩子（right child）。 性质 二叉树上终端节点数等于双分支节点数加1。 二叉树上第i层至多有2i-1个节点（i ≥ 1）。 深度为h的二叉树至多有2h-1个节点。 对完全二叉树中编号为i的节点（1 ≤ i ≤ n， n ≥ 1，n为节点数 ）有： 若i ≤ ⌊n/2⌋，即2i ≤ n，则编号为i的节点为分支节点，否则为叶子节点。 若n为奇数，则每个分支节点都既有左孩子，又有右孩子；若n为偶数，则编号最大的分支节点（编号为n/2）只有左孩子，没有右孩子，其余分支节点左、右孩子都有。 若编号为i的节点右左孩子，则左孩子节点的编号为2i；若编号为i的节点有右孩子，则右孩子节点的编号为2i+1。 除树根节点外，若一个节点的编号为i，则他的双亲节点的编号为 ⌊i/2⌋，也就是说，当i为偶数时，其双亲节点的编号为i/2，它时双亲节点的左孩子，当i为奇数时，其双亲节点的编号为(i-1)/2，它是双亲节点的右孩子。 具有n个（n &gt; 0）节点的完全二叉树的深度为⌈$\\log_{2} (n+1)$⌉或⌊$\\log_{2} n$⌋+1。 二叉树的存储结构 二叉树的遍历 遍历二叉树的问题可以分为： 访问根节点 遍历左子树 遍历右子树 遍历方式分为：DLR、LDR、LRD、DRL、RDL、RLD。 前序遍历算法 中序遍历算法 后续遍历算法 线索二叉树二叉树的线索化对二叉树进行某种遍历得到的节点序列，可以看做一个线性表，在该线性表中，除第一个节点外，每个节点有且仅有一个前驱，除最后一个节点外，每个节点有且仅有一个后继。为了同节点在二叉树中具有的前驱（即双亲）和后继（即孩子）区别开来，在容易混淆的地方，我们通常把序列中节点的前驱或后继冠以某种遍历的名称，如把中序序列中节点的前驱称做中序前驱，节点的后继称做中序后继。 对于一颗具有n个节点的二叉树，对应的二叉链表中共有2n个指针域，其中n-1个用于指向除树根节点的其余n-1个节点，另有n+1个指针域空着。若把每个节点中空着的左指针域和右指针域用于分别指向某种遍历次序的前驱节点和后继节点，则在遍历这种二叉树时，可由此信息直接找到在该遍历次序下的前驱节点或后继节点，从而比递归遍历提高了遍历速度和节省了建立系统栈所使用的存储空间。这种在节点的空指针域中存放的该节点在某次遍历次序下的前驱节点或后继节点的指针叫做线索，其中在空的左指针域中存放的指向其前驱节点的指针叫做左线索或前驱线索，在空的右指针域中存放的指向其后继节点的指针叫做右线索或后继线索。对一颗二叉树中的所有节点的空指针域按照某种遍历次序加线索的过程叫做线索化，被线索化了的二叉树叫做线索二叉树。 二叉排序树定义二叉排序树（Binary Sort Tree）又称为二叉查找树（Binary Search Tree），它或者是一颗空树，或者是一颗具有如下特征的非空二叉树： 若它的左子树非空，则左子树上所有节点的关键字小于根节点的关键字； 若它的右子树非空，则右子树上所有节点的关键字均大于（若允许具有相同的关键字的节点存在，则大于等于）根节点的关键字； 左、右子树本身又是二叉排序树。 查找和插入当二叉查找树不为空时： 首先将给定值与根节点的关键字比较，若相等，则查找成功 若小于根节点的关键字值，递归查左子树 若大于根节点的关键字值，递归查右子树 若子树为空，查找不成功 二叉排序树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的节点时再进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。如下图所示： 删除二叉查找树的删除操作分为三种情况： 如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示： 如果节点只有一个儿子，则将此节点parent的指针指向此节点的儿子，然后删除节点，如下图所示： 如果节点有两个儿子，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示： 参考 https://pegasuswang.github.io/python_data_structures_and_algorithms/17_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/binary_search_tree/ 哈夫曼树（最优二叉树） 路径和路径长度 若在一颗树中存在着一个节点序列k1，k2，….kj，使得kj是kj+1的双亲（1 ≤ i &lt; j），则称此节点序列是从k1～kj的路径，因树中每个节点只有一个双亲节点，所以它也是这两个节点之间的唯一路径。从k1～kj所经过的分支数称为这两点之间的路径长度，它等于路径上的节点数减1。 节点的权和带权路径长度 在许多应用中，常常将树中的节点赋上一个有着某种意义的实数，我们称此实数为该节点的权。节点的带权路径长度规定为从树根节点到该节点之间的路径长度于该节点上权的乘积。 树的带权路径长度 树的带权路径长度定义为树中所有叶子节点的带权路径长度之和，通常记为： $\\sum_{i=1}^n {w_{i}}l_{i}$ 其中n表示叶子节点的数目，wi和li分别表示叶子节点ki的权值和根到ki之间的路径长度。 哈夫曼树 哈夫曼树（Huffman）树又称最优二叉树。它是n个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树。 构造哈夫曼树 根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F={T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根节点,其左右子树为空。 在F中选取两棵根节点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根节点的权值为左右子树根节点的权值之和。 在F中删除这两棵树,同时将新的二叉树加入F中。 重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)。 平衡二叉树（AVL树）二叉搜索树中，每一个节点的左右子树深度差的绝对值不大于1。 (a）所示为 AVL 树，而（b）所示则不是 AVL 树。 那么，如何判断一棵树是否符合 AVL 树的性质？答案就是维护每个节点的平衡因子。每个节点的平衡因子即为节点左子树的深度减去右子树的深度得到的差。在符合 AVL 性质的情况下，平衡因子只能取 -1、0、1。 正因为这样，在插入或删除一个节点之后，要从插入或删除的位置沿通向根的路径回溯，更新这些经过的节点的平衡因子。在检测到当前节点的平衡因子的绝对值大于1时，停止回溯，根据回溯路径中当前节点以及当前节点深度+1 和深度+2 两层节点的位置，选择旋转方法对二叉树的结构进行调整。 如果一棵平衡二叉树中的节点发生了变化，使二叉树不再平衡，此时需要采用平衡化旋转来调整树的结构，使得在不破坏二叉搜索树性质的情况下，让二叉树重新达到平衡。 平衡化旋转分为两种：单向旋转和双向旋转。如果回溯路径中当前节点以及下两层节点处于一条直线上，就可以采用单向旋转。如果在下两层的节点中，每一个节点都是父亲节点的右孩子，那么如图 3 所示，此时采用单向左旋。 由于此处 A&lt;B&lt;C，所以左旋后并不破坏二叉搜索树的性质，而刚好使得平衡因子恢复到符合 AVL 树性质的大小。 这样的过程同样可以用图来展示。举例来说，在图 4 这样一棵平衡二叉树中插入节点后，整棵树就变得不平衡了。每个节点上方的数字就是该节点的平衡因子，而长方形代表子树，长方形里面的式子等于它的深度。 要想调整二叉树的结构，这里就要用到平衡左旋了。我们取每一棵子树的根节点来代表这一整棵子树，用一共 5 个节点来演示单向左旋的过程。图 5 所示就是单向左旋的效果。 平衡树的结构最后被调整成了图 6 所示这样，而平衡因子也重新变得符合 AVL 树性质了。 同样的道理，如果需要进行平衡旋转时，当前节点的下两层节点都是父节点的左孩子，那么就需要采用单向右旋。单向右旋的道理和单向左旋非常相似，下面就主要用图来演示，不多做讲解了。单向右旋的过程如图 7～图 9 所示。 参考 https://www.cxyxiaowu.com/1663.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"稀疏矩阵和广义表","slug":"数据结构/稀疏矩阵和广义表","date":"2021-06-15T01:50:53.772Z","updated":"2021-06-15T01:50:53.772Z","comments":true,"path":"wiki/数据结构/稀疏矩阵和广义表/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/","excerpt":"","text":"定义矩阵矩阵是一个具有m行 x n列的数表，共包含m x n个数（元素），每个元素处在确定行和列的交点位置上，都与一对行号和列号唯一对应。当一个矩阵中的行数和列数相同时，即m = n时则称为n阶矩阵或方阵。 稀疏矩阵（SparseMatrix）是矩阵中的一种特殊情况，其非零元素的个数小于零元素的个数。 对于稀疏矩阵中的每个非零元素，可用它所在的行号、列号以及元素这三元组（i，j，aij）来表示。若把所有的三元组按照行号为主序（即主关键字）、列号为辅序（次关键字）进行排序，就构成一个表示稀疏矩阵的三元组线性表。 ((1,1,3),(1,4,5),(2,3,-2),(3,1,1),(3,3,4),(3,5,6),(5,3,-1)) 稀疏矩阵的存储结构顺序存储链式存储 带行指针向量的链接存储 在这种链接存储中，需要把具有相同行号的三元组结点按照列号从小到大的顺序链接成一个单链表，每个三元组结点的类型可定义为： 1234567class TripleNode: def __init__(self): self.row = 0 self.col = 0 self.val = None self.next = None # 指向同一行的下一个结点 稀疏矩阵中的每一行对应一个单链表，每一个单链表都有一个表头指针，为了把它们保存起来，便于访问每一个单链表，需要一个行指针向量，该向量中的第i个分量用来存储稀疏矩阵中的第i行所对应的单链表的表头指针。 12345678class LMatrix: def __init__(self): self.m = 0 self.n = 0 self.t = 0 # 非零元素的个数 self.vector = [] 十字链接存储 既带行指针向量又带列指针向量的链接存储。在这种链接存储中，每个三元组结点既处于同一行的单链表中，又处于同一列的单链表中，即处于所在的行单链表和列单链表的交点处。 1234567891011121314151617class CrossNode: def __init__(self): self.row = 0 self.col = 0 self.val = None self.right = None # 存储指向同一行下一个结点的指针 self.down = None # 存储同一列下一个结点的指针class CLMatrix: def __init__(self): self.m = 0 self.n = 0 self.t = 0 self.rv = [] # 行向量指针，存储行单链表的表头指针 self.cv = [] # 列向量指针，存储列单链表的表头指针 广义表(Generalized List)一个广义表是n（n ≥ 0）个元素的一个序列，当n = 0时则称为空表。在一个非空的广义表中，其元素可以是某一确定类型的对象（这种元素被称为单元素），也可以是由单元素构成的表（这种元素可相对的被称为子表或表元素）。显然，广义表的定义是递归的。 设ai为广义表的第i个元素，则广义表的一般表示与线性表相同： (a1,a2,a3,…,ai,…,an) 其中n表示广义表的长度，即广义表中所含元素的个数，n ≥ 0。 深度：表中括号的最大层数 表示方式 用小写字母表示单元素，用大写字母表示表 A = ()A是空表，长度为0，深度为1。 B = (e)B是长度为1的广义表，深度为1。线性表。 C = (a, (b,c,d))C是长度为2的广义表，深度为2。 D = (A, B, C) = ((), (e), (a, (b, c, d)))D是长度为3的广义表，深度为3。A、B、C为子表。 E = ((a, (a,b), ((a,b), c))) 用圆圈和方框分别表示表和单元素，并用线段把表和它的元素连接起来，则可得到一个广义表的图形表示。 抽象数据类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ADT GList&#123;数据对象： D=&#123;ei | i=1,2,...,n; n&gt;0; ei∈AtomSet 或ei∈GList, AtomSet为某个数据对象 &#125;数据关系： R1=&#123;&lt;ei-1,ei&gt; | ei-1,ei∈D, 2&lt;=i&lt;=n&#125;基本操作： InitGList(&amp;L); 操作结果： 创建空的广义表L。 CreateGList(&amp;L, S); 初始条件： S是广义表的书写形式串。 操作结果： 由S创建广义表L。 DestroyGList(&amp;L); 初始条件： 广义表L存在 操作结果： 销毁广义表L。 CopyGList(&amp;T, L); 初始条件： 广义表L存在 操作结果： 由广义表L复制得到广义表T。 GListLength(L); 初始条件： 广义表L存在 操作结果： 求广义表L的长度 GListenDepth(L); 初始条件： 广义表L存在 操作结果： 求广义表L的深度 GListEmpty(L); 初始条件： 广义表L存在 操作结果： 判定广义表L是否为空 GetHead(L); 初始条件： 广义表L存在 操作结果： 取广义表L的头 GetTail(L); 初始条件： 广义表L存在 操作结果： 取广义表L的尾 InsertFirst_GL(&amp;L, e); 初始条件： 广义表L存在 操作结果： 插入元素e作为广义表L的第一元素 DeleteFirst_GL(&amp;L, &amp;e); 初始条件： 广义表L存在 操作结果： 删除广义表L的第一元素，并用e返回其值 Traverse_GL(L, Visit()); 初始条件： 广义表L存在 操作结果： 遍历广义表L，用函数Visit处理每个元素&#125;ADT GList; 存储在一个广义表中，其数据元素有单元素和子表之分，所以在对应的存储结构中，其存储结点也有单元素结点和子表结点之分。对于单元素结点，应包括值域和指向其后继结点的指针域；对于子表结点，应包括指向子表中第一个结点的表头指针域和指向其后继结点的指针域。为了把广义表中的单元素结点和子表结点区别开，还必须在每个结点中增设一个标志域，让标志域取不同的值，从而区别不同的结点。 由于列表中的数据元素可能为原子或列表， 由此需要两种结构的结点： 一种是表结点，用于表示列表；一种是原子结点，用以表示原子。若列表不空，则可分解成表头和表尾；反之，一对确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成： 标志域、指示表头的指针域和指示表尾的指针域； 而原子结点只需两个域： 标志域和值域。 头尾链表存储结构123456789101112131415161718//------ 广义表的头尾链表存储表示 -------typedef enum&#123; ATOM, //ATOM == 0: 原子 LIST //LIST == 1: 子表&#125;ElemTag;typedef GLNode&#123; ElemTag tag; //公共部分，用于区分原子结点和表结点 union&#123; //原子结点和表结点的联合部分 AtomType atom; //atom是原子结点的值域，AtomType由用户定义 struct&#123; struct GLNode *hp; struct GLNode *tp; &#125;ptr; //ptr是表节点的指针域，ptr.hp和ptr.tp分别指向表头和表尾 &#125;&#125;*GList; //广义表类型 扩展线性链表存储结构123456789101112131415161718//------ 广义表的扩展线性链表存储表示 -------typedef enum&#123; ATOM, //ATOM == 0: 原子 LIST //LIST == 1: 子表&#125;ElemTag;typedef GLNode&#123; ElemTag tag; //公共部分，用于区分原子结点和表结点 union&#123; //原子结点和表结点的联合部分 AtomType atom; //atom是原子结点的值域，AtomType由用户定义 struct GLNode *hp; //表结点的表头指针 &#125;; struct GLNode *tp; //相当于线性链表的next，指向下一个元素结点&#125;*GList; 参考 https://www.scipy.org/ SciPy使用多个数据结构为创建稀疏矩阵提供了工具，以及将稠密矩阵转化为稀疏矩阵的工具。 csc_matrix: Compressed Sparse Column format csr_matrix: Compressed Sparse Row format bsr_matrix: Block Sparse Row format lil_matrix: List of Lists format dok_matrix: Dictionary of Keys format coo_matrix: COOrdinate format (aka IJV, triplet format) dia_matrix: DIAgonal format","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"红黑树","slug":"数据结构/红黑树","date":"2021-06-15T01:50:53.772Z","updated":"2021-06-15T01:50:53.772Z","comments":true,"path":"wiki/数据结构/红黑树/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/","excerpt":"","text":"定义红黑树是一种自平衡二叉查找树，它可以在 O($\\log(n)$ ) 时间内完成查找、插入和删除，这里的n是树中元素的数目。 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： 节点是红色或黑色。 根节点是黑色。 每个叶子节点都是黑色的空节点（NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 操作因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O($\\log(n)$)的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为 O ($\\log(n)$)次。 左旋转 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。下图中身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。 右旋转 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。下图中身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。 插入应用场景 JDK的集合类TreeMap、TreeSet、HashMap 参考 https://www.cxyxiaowu.com/3173.html https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"平衡二叉树AVL","slug":"数据结构/平衡二叉树AVL","date":"2021-06-15T01:50:53.771Z","updated":"2021-06-15T01:50:53.771Z","comments":true,"path":"wiki/数据结构/平衡二叉树AVL/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/","excerpt":"","text":"定义平衡二叉树也叫自平衡二叉搜索树（Self-Balancing Binary Search Tree），所以其本质也是一颗二叉搜索树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树（旋转操作）。 最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。Ï 平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋与右旋。 旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。 左旋 节点的右孩子替代此节点位置 右孩子的左子树变为该节点的右子树 节点本身变为右孩子的左子树 右旋 节点的左孩子代表此节点 节点的左孩子的右子树变为节点的左子树 将此节点作为左孩子节点的右子树。 AVL树的四种插入节点方式平衡二叉树插入节点的情况分为以下四种： 插入方式 描述 旋转方式 LL 在 A 的左子树根节点的左子树上插入节点而破坏平衡 右旋转 RR 在 A 的右子树根节点的右子树上插入节点而破坏平衡 左旋转 LR 在A的左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋 RL 在 A 的右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋 详细分析删除AVL 树和二叉查找树的删除操作情况一致，都分为四种情况： 删除叶子节点 删除的节点只有左子树 删除的节点只有右子树 删除的节点既有左子树又有右子树 只不过AVL树在删除节点后需要重新检查平衡性并修正，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。 删除操作的大致步骤如下： 以前三种情况为基础尝试删除节点，并将访问节点入栈。 如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。 如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。 再依次检查栈顶节点的平衡状态和修正直到栈空。 对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。 详细分析参考 https://blog.csdn.net/jyy305/article/details/70949010 https://zhuanlan.zhihu.com/p/56066942 https://www.cs.usfca.edu/~galles/visualization/AVLtree.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"栈和队列","slug":"数据结构/栈和队列","date":"2021-06-15T01:50:53.771Z","updated":"2021-06-15T01:50:53.771Z","comments":true,"path":"wiki/数据结构/栈和队列/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈栈（Stack），也叫后进先出表（Last In First Out），是一种运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算。这一端称为栈顶，栈顶的第一个元素被称为栈顶元素，相对的，另一端称为栈底。向一个栈插入新元素称为进栈或入栈，从一个栈删除元素又称为出栈或退栈。 存储结构栈分为顺序栈和链式栈，可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。 顺序存储链式存储队列队列（Queue），也叫先进先出表（First In First Out）仅允许在表的一端（队尾rear）进行插入，在表的另一端（队首front）进行删除。","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"B树、B+树","slug":"数据结构/B树","date":"2021-06-15T01:50:53.770Z","updated":"2021-06-15T01:50:53.770Z","comments":true,"path":"wiki/数据结构/B树/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B%E6%A0%91/","excerpt":"","text":"B树B树也称B-树,它是一颗多路平衡查找树。描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。 一颗m阶的B树定义如下： 每个结点最多包含m个子结点；且M&gt;2 根结点的儿子数为[2, M] 除根结点以外，非叶子结点的子结点数为[M/2, M] 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 非叶子结点的关键字个数=指向儿子的指针个数-1； 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层； 插入插入在叶节点级别完成。要将项目插入B树，需要遵循以下算法。 遍历B树以找到可插入节点的适当叶节点。 如果叶节点包含少于m-1个键，则按递增顺序插入元素。 否则，如果叶节点包含m-1个键，则按照以下步骤操作。 按元素的递增顺序插入新元素。 将节点拆分为中间的两个节点。 将中值元素推送到其父节点。 如果父节点还包含m-1个键，则按照相同的步骤将其拆分。 删除还在叶节点处执行删除。 要删除的节点可以是叶节点或内部节点。 需要遵循以下算法才能从B树中删除节点。 找到叶节点。 如果叶节点中有多于m/2个键，则从节点中删除所需的键。 如果叶节点不包含m/2个键，则通过从8个或左兄弟中获取元素来完成键。 如果左侧兄弟包含多于m/2个元素，则将其最大元素推送到其父元素，并将插入元素向下移动到删除键的节点。 如果右侧兄弟包含多于m/2个元素，则将其最小元素向上推送到父节点，并将插入元素向下移动到删除键的节点。 如果兄弟节点都不包含多于m/2个元素，则通过连接两个叶节点和父节点的插入元素来创建新的叶节点。 如果父节点的节点少于m/2，那么也应在父节点上应用上述过程。 如果要删除的节点是内部节点，则将节点替换为其有序后继或前一个节点。 由于后继或前任将始终位于叶节点上，因此该过程将类似于从叶节点中删除节点。 应用场景 查找磁盘中的大量数据。 数据库中的索引。 参考 https://www.yiibai.com/data_structure/b-tree.html B+树B+树是B树的变体，有着更高的查询性能。 参考 https://www.cnblogs.com/nullzx/p/8729425.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图","slug":"数据结构/图","date":"2021-06-15T01:50:53.770Z","updated":"2021-06-15T01:50:53.770Z","comments":true,"path":"wiki/数据结构/图/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/","excerpt":"","text":"定义图（Graph）是图形结构的简称。 G = (V, E) V称为顶点集（Vertices set），E称为边集（Edges set）。E的元素是一个二元组数对，用(x,y)表示，其中x,y∈V。 其中V是非空的顶点集合，即V = {Vi|0≤i≤n-1,n≥1, Vi$\\in$VertexType}，其中VertexType表示任何类型，n为顶点数；E是V上二元关系的集合。 V(G1) = {0,1,2,3,4,5,}E(G1) = {(0,1),(0,2),(0,3),(0,4),(1,4),(2,4),(3,5),(4,5)}V(G2) = {0,1,2,3,4}E(G2) = {&lt;0,1&gt;,&lt;0,2&gt;,&lt;1,2&gt;,&lt;1,4&gt;,&lt;2,1&gt;,&lt;2,3&gt;,&lt;4,3&gt;} G1为无向图（undirected graph），图中每个元素为一个无序二元组 (u,v)，称作无向边 (Undirected edge)，简称**边 (Edge)，其中 u,v∈V。设 e=(u,v)，则 u,v 称为 e 的端点 (End-vertex)**。 G2为有向图（directed graph），每一个元素为一个 (有序) 二元组 (u,v)，有时也写作 u→v，称作有向边 (Directed edge) 或弧 (Arc)，在不引起混淆的情况下也可以称作边。设 e=u→v，则此时 u 称为 e 的起点 (Origin)，v 称为 e 的终点 (Terminus)，起点和终点也称为 e 的端点。 对于 V 中的每个元素，我们称其为**顶点 (Vertex)或节点 (Node)**，简称点 (Vertex)，顶点的集合称为点集 (Vertex set)，边的集合称为边集 (Edge set)。 图 G 的点集和边集可以表示为 V(G) 和 E(G)，在不引起混淆的情况下，也能表示成 V,E。图 G 的点数 |V(G)| 也被称作图 G 的阶 (Order)。 基本术语 顶点的度、入度、出度度：顶点v的度（Degree）是和v相关联的边的数目，记为TD(v)。 对于有向图G=(V,{E})，如果弧∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧和顶点v，v’相关联。以顶点v为头弧的数目称为v的入度（InDegree），记为ID(v)；以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)； 顶点v的度为TD(v)=ID(v)+OD(v)。 完全图、稠密图、稀疏图完全图：每个顶点都与其他顶点相邻接的图。 有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图（dense graph）。 路径和回路依次遍历顶点序列之间的边所形成的轨迹。下图中依次访问顶点 V0 、V3 和 V2 ，则构成一条路径。 连通和连通分量在无向图 G 中，如果从顶点 v 到顶点 v’ 有路径，则称 v 和 v’ 是连通的。 如果对于图中任意两个顶点 vi 、vj ∈E， vi，和vj都是连通的，则称 G 是连通图，否则图为非连通图。 非连通图： 连通图： 强连通图和强连通分量在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 网“权”指边上面的信息，一般为数字。 每条边上都带有权的图叫做网。 存储结构12345678910111213141516171819ADT 图(Graph)Data 顶点的有穷非空集合和边的集合。Operation CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。 DestroyGraph(*G): 图G存在则销毁。 LocateVex(G, u): 若图G中存在顶点u，则返回图中的位置。 GetVex(G, v): 返回图G中顶点v的值。 PutVex(G, v, value): 将图G中顶点v赋值value。 FirstAdjVex(G, *v): 返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 NextAdjVex(G, v, *w): 返回顶点v相对于顶点w的下一个邻接顶点， 若w是v的最后一个邻接点则返回“空”。 InsertVex(*G, v): 在图G中增添新顶点v。 DeleteVex(*G, v): 删除图G中顶点v及其相关的弧。 InsertArc(*G, v, w): 在图G中增添弧&lt;v,w&gt;，若G是无向图，还需要增添对称弧&lt;w,v&gt;。 DeleteArc(*G, v, w): 在图G中删除弧&lt;v,w&gt;，若G是无向图，则还删除对称弧&lt;w,v&gt;。 DFSTraverse(G): 对图G中进行深度优先遍历，在遍历过程对每个顶点调用。 HFSTraverse(G): 对图G中进行广度优先遍历，在遍历过程对每个顶点调用。endADT 邻接矩阵（Adjacency Matrix）用两个数组来表示图。一个一维的数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 对于 n 个点，构造一个 n * n 的矩阵，如果有从点 i 到点 j 的边，就将矩阵的位置 matrix[i][j] 置为 1。 通常会将图 G 中的结点编为1，2，…，|V| （这种编号可以是任意的），然后使用一个 |V| ×|V| 的矩阵 A=(aij) 表示，该矩阵满足以下条件： 可以看出邻接矩阵是在无向图的表示中是转置矩阵，而在有向图中则不是。 对于带权图来说，可以将aij用来存储权值，如果两结点无连接，用0或无穷表示： 无向图邻接矩阵的特征 无向图的邻接矩阵对称且唯一。 有向图的邻接矩阵的第 i 行非零元素个数为第 i 个顶点的出度；第 j 列非零元素个数为第 j 个顶点的入度。 可快速判断两结点间是否有边。 A[i][j] = 1代表顶点i与顶点j邻接，A[i][j] = 0代表顶点i与顶点j不邻接。 顶点与自身之间并未邻接关系，因此边数组的对角线上的元素均为0。 顶点的度即为顶点所在的行或者列1的数目。 有向图邻接矩阵的特征 顶点数组长度为图的顶点数目n。边数组为n X n的二维数组。 边数组中，数组元素为1，即A[i][j] = 1,代表第i个顶点与第j个顶点邻接，且i为尾，j为头。 A[i][j] = 0代表顶点与顶点不邻接。 在有向图中，由于边存在方向性，因此数组不一定为对称数组。 对角线上元素为0。 第i行中，1的数目代表第i个顶点的出度。例如：顶点V1的出度为2，则顶点V1所在行的1的数目为2。 第j列中，1的数目代表第j个顶点的入度。例如：V3的入度为1，则V3所在列中1的数目为1。 邻接表（adjacency list）邻接链表（adjacency list）由图中的每一个结点及其相邻结点生成以该结点为头结点的一组链表。 当处理稀疏图时，相对于邻接矩阵，邻接链表无需一次就分配那么大的空间，而是在遍历图的过程中一点一点地分配，它是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。 虽然邻接链表是一种非常节约空间的结构，但在无向图中用邻接链表表示也会出现数据冗余。这是因为表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。 邻接表存储方法是一种数组存储和链式存储相结合的存储方法。在邻接表中，对图中的每个顶点建立一个单链表，第 i 个单链表中的结点依附于顶点 Vi 的边（对有向图是以顶点Vi为尾的弧）。链表中的节点称为表节点，共有 3个域，具体结构见下图： 表结点由三个域组成，adjvex存储与Vi邻接的点在图中的位置，nextarc存储下一条边或弧的结点，info存储与边或弧相关的信息如权值。 除表结点外，需要在数组中存储头结点，头结点由两个域组成，分别指向链表中第一个顶点和存储Vi的名或其他信息。具体结构如下图： 其中，data域中存储顶点相关信息，firstarc指向链表的第一个节点。 无向图采用邻接表方式存储 采用邻接表方式存储图 6.1 中的无向图，绘图过程中忽略边节点的info信息，头结点中的 data 域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，则可以创建3个表节点，表节点中adjvex分别存储V2、V3、V4的索引1、2、3，按照此方式，得到的邻接表为： 特征 数组中头节点的数目为图的顶点数目。 链表的长度即为顶点的度。例如：V1顶点的度为3，则以V1为头节点的链表中表节点的数目为3。 有向图采用邻接链表方式存储 采用邻接表方式存储图6.3中的有向图，绘图过程中忽略边节点的info信息，头结点中的data域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，但是以V1顶点为尾的边只有两条，即和因此，创建2个表节点。表节点中adjvex分别存储V3、V4的索引2、3，按照此方式，得到的邻接表为： 特征 数组中表节点的数目为图的顶点数目。 链表的长度即为顶点的出度。例如V1的出度为2，V1为头节点的链表中，表节点的数目为2。 顶点Vi的入度为邻接表中所有adjvex值域为i的表结点数目。例如：顶点V3的入度为4，则链表中所有adjvex值域为2的表结点数目为4。 逆邻接表在邻接表中，可以轻易的得出顶点的出度，但是想要得到顶点的入度，则需要遍历整个链表。为了便于确定顶点的入度，可以建立有向图的逆邻接表。逆邻接表的建立与邻接表相反。 十字链表对于有向图而言，邻接链表的缺陷是要查询某个顶点的入度时需要遍历整个链表，而逆邻接链表在查询某个顶点的出度时要遍历整个链表。为了解决这些问题，十字链表将邻接链表和逆邻接链表综合了起来，而得到的一种十字链表。在十字链表中，每一条边对应一种边节点，每一个顶点对应为顶点节点。 顶点结点 顶点节点即为头节点，由3个域构成，具体形式如下： 其中，data域存储与顶点相关的信息，firstin和firstout分别指向以此顶点为头或尾的第一个边节点。 边结点 在边节点为链表节点，共有5个域，具体形式如下： 其中，尾域tailvex和头域headvex分别指向尾和头的顶点在图中的位置。链域hlink指向头相同的下一条边，链域tlink指向尾相同的下一条边。info 存储此条边的相关信息。 例如： 采用十字链表的方式存储图的有向图，绘图过程忽略边节点中的info信息，表头节点中的data域存储顶点名称。以V1顶点为例，顶点节点的data域存储V1顶点名，firstin存储以V1顶点为头第一个边节点，以V1顶点为头边为，firstout存储以以V1顶点为尾第一个边节点，对应边为。按照此规则，得到的十字链表存储为： 邻接多重表对于无向图而言，其每条边在邻接链表中都需要两个结点来表示，而邻接多重表正是对其进行优化，让同一条边只用一个结点表示即可。邻接多重表仿照了十字链表的思想，对邻接链表的边表结点进行了改进。 其中，ivex和jvex是指某条边依附的两个顶点在顶点表中的下标。 ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。info存储边的相关信息。 重新定义的顶点结构如下图： 其中，data存储顶点的相关信息，firstedge指向第一条依附于该顶点的边。 所示的无向图，采用邻接多重表存储，以 V0 为例，顶点节点的data域存储V0名称，firstedge 指向(V0 , V1)边，边节点中的ilink指向依附V0顶点的下一条边(V0 , V3)，jlink指向依附V1顶点的下一条边(V1 , V2)，按照此方式建立邻接多重表： 关联矩阵邻接矩阵和邻接链表都是用来表示图中各个点和每个点之间的关系，而关联矩阵（incidence matrix）即用一个矩阵来表示各个点和每条边之间的关系。 设无向图 G=(V,E)，其中顶点集 V=v1,v2,⋯,vn, 边集 E=e1,e2,⋯,em，用 aij 表示顶点vi与边ej 关联的次数，可能取值为0, 1, 2, ….，我们称所得矩阵A=A(G)=(aij)n×m为图 G 的关联矩阵。 对于关联矩阵第一行1 1 1 0，表示点v1和各边的关系。如图所示，v1和e1,e2,e3相连，和e4未连，故关联矩阵的值为1 1 1 0. 下面各行为点v2，v3,v4 和各边的关联，以此类推。因此每一行值的总和为该点的度。 对于有向图，若bij=1，表示边j离开点i。 若 bij= -1， 表示边j进入点i。 若 bij = 0，表示边j和点i不相关联。 图的遍历 深度优先搜索遍历（DFS: Depdth First Search）广度优先搜索遍历（BFS: Breadth First Search）非连通图的遍历 图的生成树和最小生成树普里姆算法克鲁斯卡尔算法最短路径 从一顶点到其余顶点的最短路径每对顶点之间的最短路径拓扑排序 关键路径参考 https://www.cxyxiaowu.com/1293.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"CAS原理","slug":"Java/并发编程/CAS原理","date":"2021-06-15T01:50:53.769Z","updated":"2021-07-01T12:18:58.460Z","comments":true,"path":"wiki/Java/并发编程/CAS原理/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%8E%9F%E7%90%86/","excerpt":"","text":"CAS原理在计算机科学中，比较和交换(Conmpare And Swap)是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改 为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果 该值在同一时间被另一个线程更新，则写入将失败。操作结果必须说明是否进行替换; 这 可以通过一个简单的布尔响应(这个变体通常称为比较和设置)，或通过返回从内存位置读取的值来完成。 CAS带来的问题多线程情况下，每个线程使用 CAS 操作欲将数据 A 修改成 B，当然我们只希望 只有一个线程能够正确的修改数据，并且只修改一次。当并发的时候，其中一个线程已经将 A 成功的改成了 B，但是在线程并发调度过程中尚未被调度，在这个期间，另外一个线程(不在并发中的请求线程)将 B 又修改成了 A，那么原来并发中的线程又可以通过 CAS 操作将 A 改成 B。 解决办法 java 中提供了 AtomicStampedReference 来解决这个问题，它是基于版本或者是 一种状态，在修改的过程中不仅对比值，也同时会对比版本号","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"动画造成的OOM的处理方式","slug":"Android/性能优化/OOM专题/动画造成的OOM的处理方式","date":"2021-06-15T01:50:53.766Z","updated":"2021-06-15T01:50:53.766Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/动画造成的OOM的处理方式/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"解决办法在视图销毁的时候，要cancel掉动画 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Bitmap造成的OOM的处理方式","slug":"Android/性能优化/OOM专题/Bitmap造成的OOM的处理方式","date":"2021-06-15T01:50:53.765Z","updated":"2021-07-07T03:23:58.758Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/Bitmap造成的OOM的处理方式/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/Bitmap%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Bitmap总结Android中的图片是以Bitmap方式存在的，绘制的时候也是Bitmap，对内存的影响还是很大的。 Bitmap所占用内存的计算公式：图片长度 x 图片宽度 x 像素点的字节数 图片常用的压缩格式 ALPHA_8：每个像素都存储为一个半透明通道 ARGB_4444：API 13中已弃用 ARGB_8888：每个像素存储在4个字节 RGB_565：每个像素存储在2个字节中，只有RGB通道被编码；红色以5位精度存储，绿色以6位精度存储，蓝色以5位精度存储。 单个像素点的字节数 ALPHA_8：表示8位Alpha位图，即透明度占8个位，一个像素点占用1个字节，他没有颜色，只有透明度。 ARGB_4444：表示16位的ARGB位图，即A=4，R=4，G=4，B=4，一个像素点占4+4+4+4=16位，2个字节。 ARGB_8888：表示32位ARGB位图，即A=8，R=8，G=8，B=8，一个像素点占8+8+8+8=32位，4个字节。 RGB_565：表示16位RGB位图，即R=5，G=6，B=5，没有透明度，一个像素点占用5+6+5=16位，2个字节。 常用压缩方法 质量压缩 12345private void compressQuality() &#123; Bitmap bm = BitmapFactory.decodeResource(getResources(),R.drawable.test); mSrcSize = bm.getByteCount() + &quot;byte&quot;; ByteArrayOutputStream bos = new ByteArrayOutputStream(); bm.compress(Bitmap.CompressFormat.JPEG, 100, bos); byte[] bytes = bos.toByteArray(); mSrcBitmap = BitmapFactory.decodeByteArray(bytes, 0,bytes.length);&#125; 质量压缩不会减少图片的像素，它是在保持像素的前提下改变图片的位深和透明度来达到压缩的目的；图片的长、宽，像素不改变，占用的内存是不会变的。 质量压缩对png无效，png是无损压缩。 采样率压缩 1234private void compressSampling() &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 2; mSrcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test, options);&#125; 采样率压缩其原理是缩放 bitamp 的尺寸，通过调节其 inSampleSize 参数，比如调节为 2，宽高会为原来的 1/2，内存变回原来的 1/4. 缩放压缩 1234567private void compressMatrix() &#123; Matrix matrix = new Matrix(); matrix.setScale(0.5f, 0.5f); Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.test); mSrcBitmap = Bitmap.createBitmap(bm, 0, 0, bm.getWidth(), bm.getHeight(), matrix, true); bm = null; &#125; 放缩法压缩使用的是通过矩阵对图片进行裁剪，也是通过缩放图片尺寸，来达到 压缩图片的效果，和采样率的原理一样。 RGB_565压缩 12345private void compressRGB565() &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inPreferredConfig = Bitmap.Config.RGB_565; mSrcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test, options);&#125; 这是通过压缩像素占用的内存来达到压缩的效果，相比 ARGB_8888 将节省一半的内存开销。 createScaledBitmap 12345private void compressScaleBitmap() &#123; Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.test); mSrcBitmap = Bitmap.createScaledBitmap(bm, 600, 900, true); bm = null; &#125; 将图片的大小压缩成用户的期望大小，来减少占用内存。 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"内存溢出分析","slug":"Android/性能优化/OOM专题/内存溢出分析","date":"2021-06-15T01:50:53.765Z","updated":"2021-07-09T09:23:10.499Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/内存溢出分析/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/","excerpt":"","text":"概述OOM(Out of Memory)即内存溢出，是因为应用所需要分配的内存超过系统对应用内存的阈值，而抛出java.lang.OutOfMemoryError错误。 其根本原因是对象的生命周期不一致，导致内存泄漏。 内存抖动内存抖动是指在短时间内有大量的对象被创建或者被回收的现象，主要是循环中大量创建、回收对象。 内存泄漏和内存溢出的区别 内存溢出 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。 内存泄漏 是指程序在申请内存后，无法释放已申请的内存空间。内存泄漏最终会导致内存溢出。 栈内存溢出和堆内存溢出堆內存溢出 new出来的对象所需内存不够了 栈內存溢出 抛出”StackOverflowError”的原因：线程请求的栈深度大于JVM所允许的最大深度。所以根本原因是，某个线程所需的栈内存超过了JVM的限制，而此时物理内存仍有足够的可用空间。出现的情况：方法中无限递归调用。 抛出”OutOfMemoryError”的原因：无法（向操作系统）申请到足够的内存空间用来拓展栈。根本原因是，（操作系统管理的）物理内存已没有足够的可用内存分配给JVM的栈使用。出现的情况：方法中不停的创建线程。 可能出现OOM的场景静态变量导致的内存泄漏描述比如某个静态变量持有Activity，则当Activity生命周期结束时不会被释放。 1234567Static Vector v = new Vector(10);//静态变量的生命周期跟应用一致for (int i = 1; i&lt;100; i++)&#123; Object o = new Object(); v.add(o); o = null;&#125; 解决办法：及时释放静态变量 单例模式导致的内存泄漏描述单例持有Activity 解决办法如果需要持有Context，则使用ApplicationContext 属性动画导致的内存泄漏解决办法视图销毁时停止动画 for循环中不停的创建局部变量非静态内部类（包括匿名内部类）默认会持有外部类的引用当非静态内部类会持有外部类引用，如果在内部类中，将外部类的引用传入到另外的线程中，则可能造成内存泄漏。 未取消注册或回调导致的内存泄漏比如在Activity中注册广播，如果Activity销毁后不取消注册，那么这个广播就会一直存在系统中 一些经验 在onDestroy中手动释放View上的资源 尽量避免使用静态变量 兜底策略 在Activity、Fragment的onDestroy时，手动释放一下资源，降低内存泄漏时内存的占用。 123456789101112131415private void traverse(ViewGroup root) &#123; final int childCount = root.getChildCount(); for (int i = 0; i &lt; childCount; ++i) &#123; final View child = root.getChildAt(i); if (child instanceof ViewGroup) &#123; child.setBackground(null); traverse((ViewGroup) child); &#125; else &#123; if (child != null) &#123; child.setBackground(null); &#125; if (child instanceof ImageView) &#123; ((ImageView) child).setImageDrawable(null); &#125; else if (child instanceof EditText) &#123; ((EditText) child).cleanWatchers(); &#125; &#125; &#125;&#125; 监控内存使用情况，到达到某个阈值时，手动释放资源。 1234567891011121314151617181920212223242526272829303132private static Handler lowMemoryMonitorHandler;private static final int MEMORY_MONITOR_INTERVAL = 1000 * 60;/** * 开启低内存监测，如果低内存了，作出相应的反应 */public static void startMonitorLowMemory() &#123; HandlerThread thread = new HandlerThread(&quot;thread_monitor_low_memory&quot;); thread.start(); lowMemoryMonitorHandler = new Handler(thread.getLooper()); lowMemoryMonitorHandler.postDelayed(releaseMemoryCacheRunner, MEMORY_MONITOR_INTERVAL);&#125;/** * 低内存时释放内存资源 * 如果已用内存达到了总的 80%时，就清空缓存 */private static Runnable releaseMemoryCacheRunner = new Runnable() &#123; @Override public void run() &#123; long alreadyUsedSize = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); long maxSize = Runtime.getRuntime().maxMemory(); if (Double.compare(alreadyUsedSize, maxSize * 0.8) == 1) &#123; BitmapUtil.clearMemoryCaches(); &#125; lowMemoryMonitorHandler.postDelayed(releaseMemoryCacheRunner, MEMORY_MONITOR_INTERVAL); &#125;&#125;; 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Glide原理分析","slug":"Android/开源库/Glide原理分析","date":"2021-06-15T01:50:53.764Z","updated":"2021-06-15T01:50:53.764Z","comments":true,"path":"wiki/Android/开源库/Glide原理分析/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"流程图参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"APK包体积优化","slug":"Android/性能优化/APK包体积优化","date":"2021-06-15T01:50:53.764Z","updated":"2021-07-07T06:51:22.115Z","comments":true,"path":"wiki/Android/性能优化/APK包体积优化/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/APK%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/","excerpt":"","text":"删除无用资源底层库优化有时候，可能只使用了开源库中对某部分功能，可以对其源码进行删减重新打包。 图片压缩放入项目之前，对图片进行压缩，比如使用tinypng 图片资源格式的选择优先选择使用webp格式 Gradle配置minifyEnabled true //删除无用代码 shrinkResources true //删除无用资源 动态加载资源对于一些不是启动就要使用的资源，可以将其放到服务器，做成动态下载。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Activity","slug":"Android/基础/Activity基础","date":"2021-06-15T01:50:53.762Z","updated":"2021-06-15T01:50:53.762Z","comments":true,"path":"wiki/Android/基础/Activity基础/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Activity%E5%9F%BA%E7%A1%80/","excerpt":"","text":"由来我们在做带UI的软件时，一般的做法是先创建一个窗口，然后在窗口上添加各种Button、Text、List等其他UI控件。Android、iOS也是类似，但代码的设计上跟PC端有些差别，Android使用Activity来管理UI、iOS使用ViewController。一般软件的入口都是main函数开始，Android中则通过描述文件AndroidManifest.xml配置一个Activity的属性作为入口。用户操作手机的时候使得一个界面可能处于可视状态，也可能处理隐藏状态，对应着Activity会有自己的生命周期。不同UI的嵌套也是需要维护的，所以就有了Activity任务栈，对应着不同Activity有不同的启动模式。不同的Activity之间又可能需要数据传递，因而有了Intent。 生命周期 回调函数onCreate生命周期中的第一个函数，整个生命周期中只会调用一次。savedInstanceState参数如果不为空，表示Activity暂时销毁时有存储一些数据，此时可以恢复。 onRestart当前Activity从不可见重新变为可见状态时，会调用。 onStart此时准备进入前台了 onResume可见了 onPause表示Activity正在停止 onStop表示Activity即将停止 onDestroy表示Activity即将被销毁，一般在这个方法中进行资源释放。 savedInstanceState界面销毁时可保存数据 onRestoreInstanceState恢复数据 不同场景的生命周期流程正常的开启和结束从Activity1中打开Activity2 12345672021-06-02 21:03:06.820 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onCreate2021-06-02 21:03:06.831 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:03:06.835 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onResume2021-06-02 21:03:26.542 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onPause2021-06-02 21:03:26.649 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onCreate2021-06-02 21:03:26.659 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onStart2021-06-02 21:03:26.663 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onResume 在Activity2中点击返回键，当一个后台Activity会到前台时，会执行onRestart-&gt;onResume-&gt;onDestroy。当回到桌面，再次进入的应用的时候也是此流程 1234562021-06-02 21:06:54.500 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onPause2021-06-02 21:06:54.521 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onRestart2021-06-02 21:06:54.523 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:06:54.526 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onResume2021-06-02 21:06:54.762 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onDestroy 屏幕旋转时12345672021-06-02 21:14:02.755 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onPause2021-06-02 21:14:02.763 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onSaveInstanceState2021-06-02 21:14:02.768 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onDestroy2021-06-02 21:14:02.997 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onCreate2021-06-02 21:14:03.011 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:14:03.014 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onRestoreInstanceState2021-06-02 21:14:03.018 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onResume 异常情况下的数据保存和恢复某些情况下，Activity会被销毁，此时系统会调用savedInstanceState(Bundle bundle)方法，我们可以在这个方法中存储一些数据，等到Activity恢复时，bundle对象会被传递给onCreate和onRestoreInstanceState方法，我们就可以恢复到原来的状态了。 启动模式和任务栈任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放，也就是所谓的先进后出，主要有2个基本操作：压栈和出栈，其所存放的Activity是不支持重新排序的，只能根据压栈和出栈操作更改Activity的顺序。 启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，手机页面显示的就是前台任务栈中的栈顶元素。 启动模式则是用来管理Activity如何添加到任务栈里的。可以在描述文件中配置，也可以代码中设置。 启动模式launchModestandard默认模式，每次启动都会创建一个新的Activity实例。在这个模式中，谁启动了这个Activity，那么新的Activity会添加到启动的Activity所在的任务栈中。当使用非Activity的Context打开一个Activity时，则会创建一个新的任务栈，这个时候需要指定FLAG_ACTIVITY_NEW_TASK标识。 singleTop栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。举个例子，假设目前栈内的情况为ABCD，其中ABCD为四个Activity，A位于栈底，D位于栈顶，这个时候假设要再次启动D，如果D的启动模式为singleTop，那么栈内的情况仍然为ABCD;如果D的启动模式为standard，那么由于D 被重新创建，导致栈内的情况就变为ABCDD。 singleTask栈内复用模式。 这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。如果当前栈中启动，当前栈如果已经存在，则会将其上面的Activity全部出栈，自己排到栈顶。如果不存在，则创建新任务栈。 比如： 比如目前任务栈S1中的情况为ABC，这个时候Activity D以singleTask模式请求启动，其所需要的任务栈为S2，由于S2和D的实例均不存在，所以系统会先创建任务栈S2，然后再创建D的实例并将其入 栈到S2。 另外一种情况，假设D所需的任务栈为S1，其他情况如上面例子1所示，那么由于S1已经存在，所以系统会直接创建D的实例并将其入栈到S1。 如果D所需的任务栈为S1，并且当前任务栈S1的情况为ADBC，根据栈内复用的原则，此时D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent方法，同时由于singleTask默认具有clearTop的效果，会导致栈内所有在D上面的Activity全部出栈，于是最终S1中的情况为AD。 singleInstance单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，换句话说，比 如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了。”来电显示”界面就可以使用该模式。 Activity中的Flags标记位的作用很多，有的标记位可以设定Activity的启动模式，比如FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_SINGLE_TOP等;还有的标记位可以影响Activity的运行状态，比如FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS等。下面主要介绍几个比较常用的标记位，剩下的标记位读者可以查看官方文档去了解，大部分情况下，我们不需要为Activity指定标记位，因此，对于标记位理解即可。在使用标记位的时候，要注意有些标记位是系统内部使用的，应用程序不需要去手动设置这些标记位以防出现问题。 FLAG_ACTIVITY_NEW_TASK 这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_SINGLE_TOP 这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_CLEAR_TOP 具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性 android:excludeFromRecents=”true”。 Activity之间如何通信参考 https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn 《Android开发艺术探索》","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"WebView独立进程","slug":"Android/性能优化/WebView独立进程","date":"2021-06-11T02:27:48.789Z","updated":"2021-07-21T06:01:50.179Z","comments":true,"path":"wiki/Android/性能优化/WebView独立进程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/WebView%E7%8B%AC%E7%AB%8B%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"参考 https://github.com/tianshaojie/android-library-web https://github.com/xudjx/webprogress 有效解决WebView多进程崩溃","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"LeakCanary","slug":"Android/开源库/LeakCanary","date":"2021-06-10T08:50:27.638Z","updated":"2021-06-11T09:04:45.131Z","comments":true,"path":"wiki/Android/开源库/LeakCanary/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/LeakCanary/","excerpt":"","text":"参考 https://square.github.io/leakcanary","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"RxJava","slug":"Java/开源库/RxJava","date":"2021-06-07T10:16:51.809Z","updated":"2021-07-12T03:04:34.191Z","comments":true,"path":"wiki/Java/开源库/RxJava/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava/","excerpt":"","text":"基本概念 Observable(可观察者，即被观察者) Observer (观察者) subscribe (订阅) 事件 线程设置 Scheduler.immediate() 直接运行在当前线程，这是默认的scheduler Scheduler.newThread() 开一个新的线程，并在新的线程中执行操作 Scheduler.io() io操作(读写文件、网络交互)所使用的scheduler，和newThead类似，区别是io内部维护了一个没有数量上限的线程池，使用io可以避免不必要的线程创建 Scheduler.computation() 计算所用的scheduler，计算指的是cpu密集型计算，如图形的计算，使用固定数量(cpu核心数)的线程池 Scheduler.mainThread() 在android主线程中运行 参考","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"开源库","slug":"Java/开源库","permalink":"http://shjlone.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Handler基本用法","slug":"Android/基础/Handler基本用法","date":"2021-06-07T06:13:25.099Z","updated":"2021-06-10T13:06:52.909Z","comments":true,"path":"wiki/Android/基础/Handler基本用法/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"","text":"Hanlder系列目录： Handler基本用法 Handler原理 概要A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instanceis associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a Looper.It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread. There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future;and (2) to enqueue an action to be performed on a different thread than your own. Scheduling messages is accomplished with the post(Runnable), postAtTime(java.lang.Runnable, long),postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), andsendMessageDelayed(Message, long) methods. The post versions allow you to enqueue Runnable objects to be called by themessage queue when they are received; the sendMessage versions allow you to enqueue a Message object containing a bundleof data that will be processed by the Handler’s handleMessage(Message) method (requiring that you implement a subclass of Handler). When posting or sending to a Handler, you can either allow the item to be processed as soon as the message queue is readyto do so, or specify a delay before it gets processed or absolute time for it to be processed. The latter two allow youto implement timeouts, ticks, and other timing-based behavior. When a process is created for your application, its main thread is dedicated to running a message queue that takes careof managing the top-level application objects (activities, broadcast receivers, etc) and any windows they create. Youcan create your own threads, and communicate back with the main application thread through a Handler. This is done bycalling the same post or sendMessage methods as before, but from your new thread. The given Runnable or Message will thenbe scheduled in the Handler’s message queue and processed when appropriate. Handler用于Android中的线程通信。主要的用于在异步线程中发送Message或者直接运行一个Runnable，即可回到主线程执行UI操作。Handler在哪个线程初始化，则它依附在哪个线程。Activity中有一个runOnUiThread方法，封装了Handler可以直接在异步线程中使用。Handler也可以延迟执行。 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.lqd.androidpractice.handler;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.util.Log;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.lqd.androidpractice.R;import org.jetbrains.annotations.NotNull;import java.lang.ref.WeakReference;/** * handler 使用实例 * * 在异步线程发送消息到主线程刷新UI * * @author: a564 * @Date 2021/6/7 */public class HandlerActivity extends Activity &#123; private static String TAG = &quot;HandlerActivity&quot;; private TextView textView; private MyHandler myHandler; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler); textView = findViewById(R.id.ah_textview); findViewById(R.id.ah_btn1).setOnClickListener(v -&gt; &#123; new Thread() &#123; @Override public void run() &#123; super.run(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.d(TAG, Thread.currentThread().getStackTrace()[2].getMethodName()); Message msg = Message.obtain(); msg.what = 1; // 消息标识 msg.obj = &quot;A&quot;; // 消息内存存放 myHandler.sendMessage(msg); // 异步线程发送消息 //使用post myHandler.post(new Runnable() &#123; @Override public void run() &#123; //回到UI线程 &#125; &#125;); &#125; &#125;.start(); &#125;); myHandler = new MyHandler(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null);//跟随Activity销毁 myHandler = null; &#125; //静态内部类 private static class MyHandler extends Handler &#123; //弱引用 WeakReference&lt;HandlerActivity&gt; activityWeakReference; public MyHandler(HandlerActivity activity) &#123; activityWeakReference = new WeakReference&lt;HandlerActivity&gt;(activity); &#125; @Override public void handleMessage(@NonNull @NotNull Message msg) &#123; super.handleMessage(msg); Log.d(TAG, Thread.currentThread().getStackTrace()[2].getMethodName()); Log.d(TAG, msg.toString()); HandlerActivity activity = activityWeakReference.get(); if (activity == null) return; switch (msg.what) &#123; case 1: activity.textView.setText(&quot;执行了线程1的UI操作&quot;); break; case 2: activity.textView.setText(&quot;执行了线程2的UI操作&quot;); break; &#125; &#125; &#125;;&#125; HandlerThread顾名思义，HandlerThread使得Thread拥有的Handler的特性，可以在此线程中进行消息的分发和处理。使用场景也是创建异步线程并有数据交互。我们也可以将其封装成一个工具类，这样不需要每次都new一个线程出来，方便使用且节省性能。 123456789101112131415161718192021222324252627282930313233343536373839class BackgroundHandlerThread &#123; private static class Holder&#123; private static BackgroundHandlerThread _instance = new BackgroundHandlerThread(); static&#123; _instance.init(); &#125; &#125; public static BackgroundHandlerThread getInstance()&#123; return Holder._instance; &#125; private HandlerThread mHandlerThread; private Handler mHandler; private void init()&#123; //HandlerThread的第二个参数为线程优先级 mHandlerThread = new HandlerThread(BackgroundHandlerThread.class.getSimpleName()); mHandlerThread.start(); mHandler = new Handler(mHandlerThread.getLooper())&#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; &#125; public Looper getLooper()&#123; return mHandlerThread.getLooper(); &#125; public Handler getHandler()&#123; return this.mHandler; &#125;&#125;// 当需要异步执行的地方可以直接使用下面的代码BackgroundHandlerThread.getInstance().getHandler().post(Runnable) API介绍sendMessage(Message message) 发送消息到消息队列 post(Runnable runable) 把一个Runnable对象添加到消息队列中，这个方法会在对应Looper的线程中运行。 dispatchMessage(Message msg) 将消息分发给对应的Handler handleMessage 根据某个消息类型进行处理 参考 https://developer.android.com/reference/android/os/Handler 详解 Android 中的 HandlerThread","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ThreadPoolExecutor","slug":"Java/并发编程/ThreadPoolExecutor","date":"2021-06-07T03:47:22.391Z","updated":"2021-06-30T08:11:42.343Z","comments":true,"path":"wiki/Java/并发编程/ThreadPoolExecutor/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/","excerpt":"","text":"参数1234public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); corePoolSize: 线程池核心线程的数量； maximumPoolSize: 线程池可创建的最大线程数量； keepAliveTime: 当线程数量超过了corePoolSize指定的线程数，并且空闲线程空闲的时间达到当前参数指定的时间时该线程就会被销毁，如果调用过allowCoreThreadTimeOut(boolean value)方法允许核心线程过期，那么该策略针对核心线程也是生效的； unit: 指定了keepAliveTime的单位，可以为毫秒，秒，分，小时等； workQueue: 存储未执行的任务的队列； threadFactory: 创建线程的工厂，如果未指定则使用默认的线程工厂； handler: 指定了当任务队列已满，并且没有可用线程执行任务时对新添加的任务的处理策略； 调度策略当初始化一个线程池之后，池中是没有任何用户执行任务的活跃线程的，当新的任务到来时，根据配置的参数其主要的执行任务如下： 若线程池中线程数小于corePoolSize指定的线程数时，每来一个任务，都会创建一个新的线程执行该任务，无论线程池中是否已有空闲的线程； 若当前执行的任务达到了corePoolSize指定的线程数时，也即所有的核心线程都在执行任务时，此时来的新任务会保存在workQueue指定的任务队列中； 当前核心线程都在执行任务，并且任务队列已满时，会创建新的线程执行任务，这里需要注意的是，创建新线程的时候当前总共需要执行的任务数是(corePoolSize + workQueueSize)，并不是只有corePoolSize个任务； 当所有的核心线程都在执行任务，并且任务队列中存满了任务，此时若新来了任务，那么线程池将会创建新线程执行任务； 这里workQueue主要有三种类型：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue，第一个是有界阻塞队列，第二个是无界阻塞队列，当然也可以为其指定界限大小，第三个是同步队列，对于ArrayBlockingQueue，其是需要指定队列大小的，当队列存满了任务线程池就会创建新的线程执行任务，对于LinkedBlockingQueue，如果其指定界限，那么和ArrayBlockingQueue区别不大，如果其不指定界限，那么其理论上是可以存储无限量的任务的，实际上能够存储Integer.MAX_VALUE个任务（还是相当于可以存储无限量的任务），此时由于LinkedBlockingQueue是永远无法存满任务的，因而maxPoolSize的设定将没有意义，一般其会设定为和corePoolSize相同的值，对于SynchronousQueue，其内部是没有任何结构存储任务的，当一个任务添加到该队列时，当前线程和后续添加任务的线程都会被阻塞，直至有一个线程从该队列中取出任务，当前线程才会被释放，因而如果线程池使用了该队列，那么一般corePoolSize都会设计得比较小，maxPoolSize会设计得比较大，因为该队列比较适合大量并且执行时间较短的任务的执行； 若所有的线程（maximumPoolSize指定的线程数）都在执行任务，并且任务队列也存满了任务时，对于新添加的任务，其都会使用handler所指定的方式对其进行处理。 DiscardPolicy和DiscardOldestPolicy一般不会配合SynchronousQueue使用，因为当同步队列阻塞了任务时，该任务都会被抛弃；对于AbortPolicy，因为如果队列已满，那么其会抛出异常，因而使用时需要小心；对于CallerRunsPolicy，由于当有新的任务到达时会使用调用线程执行当前任务，因而使用时需要考虑其对服务器响应的影响，并且还需要注意的是，相对于其他几个策略，该策略不会抛弃任务到达的任务，因为如果到达的任务使队列满了而只能使用调用线程执行任务时，说明线程池设计得不够合理，如果任其发展，那么所有的调用线程都可能会被需要执行的任务所阻塞，导致服务器出现问题。 系统提供的线程池FixedThreadPool123456public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 特征 这是一种线程数量固定的线程池，因为corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉，不过因为最多只有nThreads个线程，且corePoolSize和maximunPoolSize值一致，所以不会发送线程停掉的情况； 阻塞队列采用了LinkedBlockingQueue，它是一个无界队列，由于阻塞队列是一个无界队列，因此永远不可能拒绝任务 弊端 由于使用的是LinkedBlockingQueue无界队列，在资源有限的时候容易引起OOM异常 CachedThreadPool12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 特征 corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大 keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死 采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程 弊端 当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队列永远是满的，因此最终会创建非核心线程来执行任务。 对于非核心线程空闲60s时将被回收。因为Integer.MAX_VALUE非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起OOM异常 SingleThreadExecutor1234567public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 特征 只有一个线程，使用了无界队列LinkedBlockingQueue，某种意义上等同于newFixedThreadPool(1) ScheduledThreadPool12345public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 特征 ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。能够延时调度任务或者周期性调度任务 参考 https://juejin.cn/post/6844903542965157901 https://blog.csdn.net/kusedexingfu/article/details/107374172","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"访问者模式","slug":"设计模式/行为型模式/访问者模式","date":"2021-06-07T01:45:07.570Z","updated":"2021-07-13T06:58:16.369Z","comments":true,"path":"wiki/设计模式/行为型模式/访问者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 类图 角色 Visitor：接口或者抽象类，定义了对每个 Element 访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁地修改 Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。 ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。 Element：元素接口或者抽象类，它定义了一个接受访问者（accept）的方法，其意义是指每一个元素都要可以被访问者访问。 ElementA、ElementB：具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。 优缺点 各角色职责分离，符合单一职责原则 高扩展性 使用场景参考 https://www.jianshu.com/p/1f1049d0a0f4 https://refactoringguru.cn/design-patterns/visitor","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"设计模式/行为型模式/责任链模式","date":"2021-06-07T01:45:07.570Z","updated":"2021-07-13T01:44:42.784Z","comments":true,"path":"wiki/设计模式/行为型模式/责任链模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 类图 角色 抽象处理者(Handler)角色：声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。 具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。 优缺点 单一职责原则。 开闭原则。可以在不更改现有代码的情况下在程序中新增处理者。 使用场景 OkHttp框架中，分析参考OkHttp GUI中的事件流，某个view如果要处理就会进行拦截，如果不处理，则传给后续的view。 参考 https://refactoringguru.cn/design-patterns/chain-of-responsibility","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"迭代器模式","slug":"设计模式/行为型模式/迭代器模式","date":"2021-06-07T01:45:07.570Z","updated":"2021-07-13T12:18:59.963Z","comments":true,"path":"wiki/设计模式/行为型模式/迭代器模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义Iterator Pattern：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。 类图 角色 Iterator（抽象迭代器）：接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。 ConcreteIterator（具体迭代器）：实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。 IterableCollections：接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。 ConcreteCollections（具体集合）：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。 优缺点 单一职责原则 开闭原则 使用场景 Java集合类 数据库操作Cursor 参考 https://refactoringguru.cn/design-patterns/iterator","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板方法模式","slug":"设计模式/行为型模式/模板方法模式","date":"2021-06-07T01:45:07.569Z","updated":"2021-07-13T11:58:38.314Z","comments":true,"path":"wiki/设计模式/行为型模式/模板方法模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义Template Method Pattern：定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。 类图 角色 抽象类 （AbstractClass）：会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为抽象类型， 也可以提供一些默认实现。 具体类 （ConcreteClass）：可以重写所有步骤， 但不能重写模板方法自身。 优缺点使用场景参考 https://refactoringguru.cn/design-patterns/template-method https://www.liaoxuefeng.com/wiki/1252599548343744/1281319636041762","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","slug":"设计模式/行为型模式/状态模式","date":"2021-06-07T01:45:07.569Z","updated":"2021-07-13T01:44:42.798Z","comments":true,"path":"wiki/设计模式/行为型模式/状态模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义State Pattern：允许一个对象在其内部状态改变的时候改变其行为。 状态模式的状态是不可替换的而且是兄弟关系，但是策略模式是可以替换的彼此独立的。他们执行完之后的行为也不同，状态模式会更改状态但是策略模式执行完就是执行完。 类图 跟策略模式的类图一样… 角色 State: 抽象状态类，定义一个接口以封装与context的一个状态相关的行为 ConcreteState: 具体状态，每一子类实现一个与Context的一个状态相关的行为 Context: 状态上下文，维护一个ConcreteState子类的实例，这个实例定义当前的状态。 优缺点 单一职责原则 开闭原则 封装了转换规则 使用场景 播放器的不同状态 参考 http://ifeve.com/state-design-pattern-in-java-example-tutorial/ https://juejin.cn/post/6844903455492931598 https://refactoringguru.cn/design-patterns/state/java/example","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"设计模式/行为型模式/策略模式","date":"2021-06-07T01:45:07.569Z","updated":"2021-07-13T01:44:42.824Z","comments":true,"path":"wiki/设计模式/行为型模式/策略模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义Strategy Pattern：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。 类图 角色 Context（环境类）：维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。目的是避免高层模块对策略的直接调用。 Strategy（抽象策略类）：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。 ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。 优缺点 开闭原则 多重if/else的解决方式之一 使用场景 Arrays.sort() 参考 https://refactoringguru.cn/design-patterns/strategy","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","slug":"设计模式/行为型模式/解释器模式","date":"2021-06-07T01:45:07.569Z","updated":"2021-07-13T07:20:45.434Z","comments":true,"path":"wiki/设计模式/行为型模式/解释器模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义Interpreter Patttern：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 类图 角色 AbstractExpression（抽象表达式）：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。 TerminalExpression（终结符表达式）：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 NonterminalExpression（非终结符表达式）：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。 Context（环境类）：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。 优缺点使用场景参考 https://www.cnblogs.com/java-my-life/archive/2012/06/19/2552617.html https://juejin.cn/post/6844903760376889358","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"查找算法","slug":"算法/查找","date":"2021-06-07T01:45:07.568Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/算法/查找/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/","excerpt":"","text":"顺序查找顺序查找（Sequential Search）又称线性查找。从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，如果查找到表中最后一个元素，还没有找到，则查找不成功。 二分查找二分查找（Binary Search）又称折半查找。它的前提是线性表中的记录必须是关键码有序，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 插值查找(Interpolation Search)基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。即根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式mid=low+(key-a[low])/(a[high]-a[low])(high-low)，替换了二分查找的计算公式mid=low+1/2(high-low)。 这样的好处在于，对表长较长，且关键字分布比较均匀，插值查找算法的平均性能要比折半查找要好的多。但是如果表中关键字分布极端不均匀，那么插值查找还不如折半查找呢。 斐波那契查找(Fibonacci Search)也是一种改进的二分查找，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。 斐波那契查找的整个过程可以分为： 构建斐波那契数列； 计算数组长度对应的斐波那契数列元素个数； 对数组进行填充； 循环进行区间分割，查找中间值； 判断中间值和目标值的关系，确定更新策略； 二叉树查找对二叉查找树进行中序遍历，即可得到有序的数列。 平衡树2-3查找树红黑树B树(B_树)、B+树B树也称B-树,它是一颗多路平衡查找树 分块查找分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 算法流程： step1 先选取各块中的最大关键字构成一个索引表； step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。 哈希查找我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。 总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。 什么是哈希函数？ 哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。 算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 算法流程： 1）用给定的哈希函数构造哈希表； 2）根据选择的冲突处理方法解决地址冲突； 常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。 3）在哈希表的基础上执行哈希查找。 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 复杂度分析： 单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。 使用Hash，我们付出了什么？ 我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？ Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。 参考 算法可视化演示","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"中介者模式","slug":"设计模式/行为型模式/中介者模式","date":"2021-06-07T01:45:07.568Z","updated":"2021-07-13T03:15:10.181Z","comments":true,"path":"wiki/设计模式/行为型模式/中介者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。 类图 角色 抽象中介者(Mediator)：定义出同事对象到中介者对象的接口，其中主要方法是一个（或多个）事件方法。 具体中介者(ConcreteMediator)：实现了抽象中介者所声明的事件方法。具体中介者知晓所有的具体同事类，并负责具体的协调各同事对象的交互关系。 抽象同事类(Colleague)：定义出中介者到同事对象的接口。同事对象只知道中介者而不知道其余的同事对象。同事类行为分为两种： 自发行为（self-Method）：一种同事本身的行为，例如改变对象本身的状态，处理自己的行为等。与其他同事类或中介者没有任何。 依赖方法(Dep-Method)：必须依赖中介者才能完成的行为。 具体同事类(ConcreteColleague)：所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者会负责与其他的同事交互。 优缺点 松散耦合 将对象间一对多的关联转变为一对一的关联 单一职责原则 开闭原则 使用场景 java.util.Timer中 参考 https://juejin.cn/post/6844903699643383821 https://refactoringguru.cn/design-patterns/mediator","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","slug":"设计模式/行为型模式/备忘录模式","date":"2021-06-07T01:45:07.568Z","updated":"2021-07-13T05:56:42.121Z","comments":true,"path":"wiki/设计模式/行为型模式/备忘录模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义Memento Pattern：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 类图 角色 原发器 （Originator） ：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。 备忘录 （Memento） ：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。 负责人 （Caretaker）：对备忘录进行管理，保存和提供备忘录。 优缺点 提供一种状态恢复机制 使用场景 游戏的当前状态 回滚操作 参考 https://xmuxiaomo.github.io/2015/05/25/设计模式学习（五）——备忘录模式/ https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html https://refactoringguru.cn/design-patterns/memento","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"排序算法","slug":"算法/排序","date":"2021-06-07T01:45:07.567Z","updated":"2021-06-23T07:45:06.577Z","comments":true,"path":"wiki/算法/排序/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"插入排序直接插入排序具体算法： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2-5。 希尔排序希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。 希尔排序实质上是一种分组直接插入方法。 基本思想： 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，即所有记录放在同一组中进行直接插入排序为止, 整个数列就是有序的。 选择排序直接选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 堆选择排序什么是堆？堆结构有很多种，如二叉堆、B堆、斐波那契堆、三元堆，树堆、弱堆等。二叉堆是堆实现中最流行的一种。二叉堆是一个完全二叉树，树的所有内部节点都被完全填充，最后一层可以完全填充的或部分填充。通俗的说，堆（二叉堆）可以视为一棵完全的二叉树。完全二叉树的一个优秀的性质就是，除了最底层之外，每一层都是满的。堆又分为最大堆（堆顶Root是最大值）和最小堆（堆顶Root是最小值）。 总结一下，只要你是一个完全二叉树，父节点又大于子节点，你就是堆。 完全二叉树 + 父节点大于(或小于)子节点 = 堆 https://chihokyo.com/post/18/ 交换排序冒泡排序从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。 快速排序 https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html 归并排序归并排序算法完全遵循分治模式。直观上其操作如下： 分解：分解等排序的n个元素的序列成各具n/2个元素的两个子序列；解决：使用归并排序递归地排序两个子序列；合并：合并两个已排序的子序列以产生已排序的答案。 https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F#Python3 各种内排序方法的比较","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PHP中opcodes的原理","slug":"程序语言/PHP/PHP中opcodes的原理","date":"2021-06-07T01:45:07.567Z","updated":"2021-06-07T01:45:07.567Z","comments":true,"path":"wiki/程序语言/PHP/PHP中opcodes的原理/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/PHP%E4%B8%ADopcodes%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"PHP代码的生命周期不启用OPcache的流程 启用OPcache的流程 Scanning：将PHP代码转换为语言片段（Tokens） Parsingg：将Tokens转换成简单而有意义的表达式 Compilation：将表达式编译成opcodes Execution:执行opcodes，每次一条，从而实现PHP脚本的功能 opcodes当一个 PHP 文件被解释执行的时候，首先是被编译成名为 opcode （CPU专用的机器语言指令）的中间代码，然后才被底层的虚拟机执行。 如果PHP文件没有被修改过，opcode 始终是一样的。这就意味着编译步骤白白浪费了 CPU 的资源。此时 opcode 缓存就派上用场了。通过将 opcode 缓存在内存中，它能防止冗余的编译步骤，并且在下次调用执行时得到重用。一般执行过程是先检查文件的签名（signature）或者修改时间，以防文件有改动。 PHP 5.5 以后的所有版本都内置了一个 opcode 缓存工具，叫做 Zend OPcache。 根据你所使用的 PHP 安装包/发行版的不同，一般情况下是默认开启的，请查看 OPcache.enable phpinfo() 和 phpinfo() 输出的信息确认是否已经开启。 Operate Code：当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码。 OPcacheopcode cache的目地是避免重复编译，减少CPU和内存开销。 PHP配置PHP5.5以上默认有OPcache，如果需要安装，则使用以下脚本： 123456wget http://pecl.php.net/get/zendOPcache-7.0.3.tgztar zxvf zendOPcache-7.0.3.tgz &amp;&amp; cd zendOPcache-7.0.3/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install php.ini配置说明 123456789101112131415161718192021222324252627282930[Zend Opcache]zend_extension = OPcache.so#比较常用的配置OPcache.enable=1 #是否启用操作码缓存OPcache.enable_cli=1 #仅针对CLI环境启用操作码缓存OPcache.revalidate_freq=60 #检查文件的修改的时间周期, 定位为秒，即缓存后60秒去检查代码文件是否被修改过OPcache.fast_shutdown=1 #打开快速关闭, 一次释放全部请求变量的内存，打开这个在PHP Request Shutdown的时候回收内存的速度会提高;OPcache.error_log=&quot;&quot; #OPcache模块的错误日志文件;OPcache.log_verbosity_level=1 #将错误信息写入到服务器的日志级别。致命（0）错误（1) 警告（2）信息（3）调试（4）#其它不常用的配置OPcache.memory_consumption=128 #共享内存大小，单位MBOPcache.interned_strings_buffer=8 #存储临时字符串的内存大小，单位MBOPcache.max_accelerated_files=4000 #哈希表中可存储的脚本文件数量上限;OPcache.max_wasted_percentage=5 #浪费内存的上限，以百分比计;OPcache.use_cwd=1 #附加改脚本的工作目录,避免同名脚本冲突OPcache.validate_timestamps=1 #每隔revalidate_freq 设定的秒数 检查脚本是否更新;OPcache.revalidate_path=0 #如果禁用此选项，在同一个 include_path 已存在的缓存文件会被重用;OPcache.save_comments=1 #禁用后将也不会加载注释内容OPcache.enable_file_override=0 #如果启用，则在调用函数file_exists()， is_file() 以及 is_readable() 的时候， 都会检查操作码缓存;OPcache.optimization_level=0xffffffff #控制优化级别的二进制位掩码。;OPcache.inherited_hack=1 #PHP 5.3之前做的优化;OPcache.dups_fix=0 #仅作为针对 “不可重定义类”错误的一种解决方案。;OPcache.blacklist_filename=&quot;&quot; #黑名单文件为文本文件，包含了不进行预编译优化的文件名;OPcache.max_file_size=0 #以字节为单位的缓存的文件大小上限;OPcache.consistency_checks=0 #如果是非 0 值，OPcache 将会每隔 N 次请求检查缓存校验和OPcache.force_restart_timeout=180 #如果缓存处于非激活状态，等待多少秒之后计划重启。;OPcache.preferred_memory_model=&quot;&quot; #OPcache 首选的内存模块。可选值包括： mmap，shm, posix 以及 win32。;OPcache.protect_memory=0 #保护共享内存，以避免执行脚本时发生非预期的写入。 仅用于内部调试。;OPcache.mmap_base=null #在Windows 平台上共享内存段的基地址 监测OPcache 可视化显示：https://github.com/PeeHaa/OpCacheGUI **简易的显示缓存信息(PHP7+)**：https://github.com/rlerdorf/opcache-status 相关PHP的API使用12345opcache_is_script_cached(string $filename):bool 是否缓存opcache_get_configuration(): array 获取缓存的配置信息opcache_invalidate(string $script , boolean $force = false):boolean 废除脚本缓存opcache_reset():boolean 重置字节码缓存的内容 参考 Understanding OPCode OPcache运行时配置 PHP Opcache工作原理 PHP内核探索：操作码OpCode OPcache安装配置及链接生效配置 OPcache 函数 Opcode是啥以及如何使用好Opcache","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://shjlone.github.io/tags/PHP/"}]},{"title":"Symfony使用记录","slug":"程序语言/PHP/symfony使用记录","date":"2021-06-07T01:45:07.567Z","updated":"2021-06-07T01:45:07.567Z","comments":true,"path":"wiki/程序语言/PHP/symfony使用记录/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/symfony%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Symfony中请求的流程如何在新接口部署的时候平稳的切换缓存使用php console cache:warmup命令，进行缓存预热，当缓存文件全部生成好后，即可平稳当切换。而不是手动删除缓存文件，待请求来之后再生成缓存。 参考 https://blog.whiteoctober.co.uk/index.html%3Fp=1751.html","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://shjlone.github.io/tags/PHP/"}]},{"title":"C语言学习笔记","slug":"程序语言/C++/C语言学习笔记","date":"2021-06-07T01:45:07.566Z","updated":"2021-06-07T01:45:07.566Z","comments":true,"path":"wiki/程序语言/C++/C语言学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Hello World1234567891011121314//文件名hello.c//预处理指令#include &lt;stdio.h&gt;//入口函数int main() &#123; printf(&quot;hello world&quot;); return 0;&#125;gcc hello.c./a.out //输出hello world C语言数据类型 字符型（char）：描述单个字符（一个字节），用半角的单引号包含起来，如’a’、’A’、’1’、’$’等，键盘能输入的英文和半角的符号都是字符。中文的汉字和标点符号是两个字节（GBK编码），不能算一个字符。 整型（int）：描述整数。 浮点型（float）：描述实数。 字符串：描述多个字符，用半角的双引号包含起来，可以是英文、数字、中文、标点符号，半角全角的都可以。 结构体（struct）：由基本类型通过一定的构造方法构造出来的类型，包括数组和结构体。 指针类型：指针可以存放内存变量和常量地址。 其他类型：如复数类型（_Complex）、虚数类型（_Imaginary）、布尔型（_bool）等。 变量变量的命名变量名属于标识符，需要符合标识符的命名规范，具体如下： 变量名的第一个字符必须是字母或下划线，不能是数字和其它字符。 变量名中的字母是区分大小写的。比如a和A是不同的变量名，num和Num也是不同的变量名。 变量名绝对不可以是C语言的关键字。 变量的定义和初始化变量在定义后，操作系统为它分配了一块内存，但并不会把这块内存打扫干静，也就是说内存中可能有垃圾数据，建议在使用之间对其初始化（打扫干静）。 1234567891011121314151617181920212223242526int ii; // 定义整数型变量，用于存放整数。char cc; // 定义字符型变量，用于存放字符。double money; // 定义浮点型变量，用于存放浮点数。char name[21]; // 定义一个可以存放20字符的字符串。//对整数型、字符型、浮点型变量来说，初始化就是给它们赋0值。int ii=0; // 定义整数型变量并初始化char cc=0; // 定义字符型变量并初始化double money=0; // 定义浮点型变量并初始化 //也可以先定义，然后再初始化。int ii; // 定义整数型变量char cc; // 定义字符型变量double money; // 定义浮点型变量ii=0; // 初始化ii为0cc=0; // 初始化cc为0money=0; // 初始化money为0//对字符串变量来说，初始化就是把内容清空，本质上也是赋0值。char name[21]; // 定义一个可以存放20字符的字符串memset(name,0,sizeof(name)); // 清空字符串name中的内容//声明常量const double pi = 3.1415926; C语言中的关键字1234567891011121314151617181920212223242526272829303132auto：声明自动变量break：跳出当前循环case：开关语句分支char：声明字符型变量或函数返回值类型const：声明只读变量continue：结束当前循环，开始下一轮循环default：开关语句中的“默认”分支do：循环语句的循环体double：声明双精度浮点型变量或函数返回值类型else：条件语句否定分支（与if连用）enum：声明枚举类型extern：声明变量或函数是在其它文件或本文件的其他位置定义float：声明浮点型变量或函数返回值类型for：一种循环语句goto：无条件跳转语句if：条件语句int：声明整型变量或函数long：声明长整型变量或函数返回值类型register：声明寄存器变量return：子程序返回语句（可以带参数，也可不带参数）short：声明短整型变量或函数signed：声明有符号类型变量或函数sizeof：计算数据类型或变量长度（即所占字节数）static：声明静态变量struct：声明结构体类型switch：用于开关语句typedef：用以给数据类型取别名unsigned：声明无符号类型变量或函数union：声明共用体类型void：声明函数无返回值或无参数，声明无类型指针volatile：说明变量在程序执行中可被隐含地改变while：循环语句的循环条件 输入和输出12345678910111213141516171819202122232425262728293031getchar：输入单个字符，保存到字符变量中。gets：输入一行数据，保存到字符串变量中。scanf：格式化输入函数，一次可以输入多个数据，保存到多个变量中。putchar：输出单个字符。puts：输出字符串。printf：格式化输出函数，可输出常量、变量等。int age=18;char xb=&#x27;x&#x27;;double weight=62.5;char name[21];memset(name,0,sizeof(name));strcpy(name, &quot;西施&quot;);printf(&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\\n&quot;,name,xb,age,weight);int age=0;char xb=0;double weight=0;char name[21];memset(name,0,sizeof(name));printf(&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;);scanf(&quot;%s %c %d %lf&quot;,name,&amp;xb,&amp;age,&amp;weight); printf(&quot;您的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\\n&quot;,name,xb,age,weight); 运算符 算术运算符； 赋值运算符； sizeof运算符； 关系运算符； 逻辑运算符； 位运算符。 算术运算符 运算符 描述 实例 + 两个数相加 A+B 将得到 23 - 一个数减另一个数 A-B 将得到 13 * 两个数相乘 A*B 将得到 90 / 分子除以分母 A/B 将得到 3.6 % 余数运算符，整除后的余数 B%A 将得到 3 ++ 自增运算符，整数值增加 1 A++ 将得到 19 – 自减运算符，整数值减少 1 A– 将得到 17 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。 C %= A 相当于 C = C % A sizeof运算符用来计算变量（或数据类型）在当前系统中占用内存的字节数。sizeof不是函数，产生这样的疑问是因为sizeof的书写确实有点像函数，sizeof有两种写法： 1234567891011121314//用于数据类型，数据类型必须用括号括住。sizeof(数据类型);printf(&quot;字符型变量占用的内存是=%d\\n&quot;,sizeof(char)); // 输出：字符型变量占用的内存是=1printf(&quot;整型变量占用的内存是=%d\\n&quot;,sizeof(int)); // 输出：整型变量占用的内存是=4//用于变量sizeof(变量名);sizeof 变量名;int ii;printf(&quot;ii占用的内存是=%d\\n&quot;,sizeof(ii)); // 输出：ii占用的内存是=4printf(&quot;ii占用的内存是=%d\\n&quot;,sizeof ii); // 输出：ii占用的内存是=4 关系运算符 关系 数学中的表示 C语言的表示 小于 &lt; &lt; 小于等于 ≤ &lt;= 大于 &gt; &gt; 大于等于 ≥ &gt;= 等于 = == 不等于 ≠ != 逻辑运算符 运算符 描述 实例 &amp;&amp; 逻辑与 true &amp;&amp; false 等于false || 逻辑或 true &amp;&amp; false 等于true ! 逻辑非 true的逻辑非为真 三目运算符 表达式1?表达式2:表达式3; 先执行表达式1，如果表达式1的结果如果为真，那么执行表达式2，并且这个整体的运算式的结果是表达式2的结果；如果表达式1的结果如果为假，执行表达式3，运算式的结果是表达式3的结果。 12int year;year=(year%100==0)?(year%400==0?1:0):(year%4==0?1:0); if、switch语句1234567891011121314151617if(表达式)&#123;&#125; else &#123;&#125;switch (表达式)&#123;case 整型数值1: 语句1;case 整型数值2: 语句2;......case 整型数值n: 语句n;default: 语句n+1;&#125;//注意//1. case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能包含任何变量//2. default不是必须的。当没有 default时，如果所有case都匹配失败，那么就什么都不执行。 程序结构while循环123456789101112131415161718192021222324252627282930while (表达式)&#123; if(表达式)语句块; if(表达式)break;//跳出当前循环 if(表达式)continue; //跳转到循环的首部&#125;do&#123; 语句块&#125; while (表达式)int times=0; // 记录用户输入数据的次数int value=0; // 用户每次从键盘输入的数据int sum=0; // 记录用户输入数据的和while (sum&lt;5000) // 如果sum的值小于5000，进入循环&#123;printf(&quot;请输入数字：&quot;); // 提示用户输入scanf(&quot;%d&quot;,&amp;value); // 接受用户从键盘输入的数据times++; // 用户输入数据的次数自增1sum=sum+value; // 记录用户输入数据的和&#125;printf(&quot;您一共输入了%d个数据，和为%d。\\n&quot;,times,sum); for循环12345for (语句1;表达式;语句2) &#123; 语句块 &#125; for循环开始时，会先执行语句1，而且在整个循环过程中只执行一次语句1。 接着判断表达式的条件，如果条件成立，就执行一次循环体中的语句块。 语句块执行完后，接下来会执行语句2。 重复第2）步和第3），直到表达式的条件不成立才结束for循环。 注意： 在for循环中，语句1、表达式和语句2都可以为空，for (;;)等同于while (1)。 continue和break两个关键字也可以用在for循环体中。 123456789int ii=1; // 用于for循环的计数器 int sum=0; // 记录1到100的累积值 for (ii=1;ii&lt;=100;ii++) &#123; sum=sum+ii; &#125; printf(&quot;1到100的累积值为%d。\\n&quot;,sum); 数组数组（array）是一组数据类型相同的变量，可以存放一组数据，它定义的语法是： 数据类型 数组名[数组长度]; 定义数组的时候，数组的长度必须是整数，可以是常量，也可以是变量。数据的下标也必须是整数，可以是常量，也可以是变量。 1234567int ii[10]; // 定义一个整型数组变量printf(&quot;sizeof(ii)=%d\\n&quot;,sizeof(ii)); // 输出结果：sizeof(ii)=40//数组初始化int no[10];memset(no,0,sizeof(no)); //第一个参数是数组名，第二个参数填0，第三个参数是数组占用的内存总空间，用sizeof(变量名)获取。 二维数组 数据类型 数组名[第一维的长度][第二维的长度]; 1234567891011121314151617181920int ii=0; // 用于组别循环的计数器int jj=0; // 用于超女人数循环的计数器int class=3; // 小组总数，初始化为3int total=5; // 每个组超女的总人数，初始化为5double weight[class][total]; // 定义二维数组，存放超女的体重double sum[class]; // 定义一维数组存放超女体重的和memset(weight,0,sizeof(weight)); // 初始化数组为0memset(sum,0,sizeof(sum)); // 初始化数组为0// 采用两个循环，第一级循环为小组数，第二级循环为超女人数for (ii=0;ii&lt;class;ii++)&#123;for (jj=0;jj&lt;total;jj++)&#123; printf(&quot;请输入第%d组第%d名超女的体重：&quot;,ii+1,jj+1); scanf(&quot;%lf&quot;,&amp;weight[ii][jj]); // 接受从键盘输入的体重 sum[ii]=sum[ii]+weight[ii][jj]; // 计算小组超女体重的和&#125;&#125; 字符串字符串就是一个以空字符’\\0’结束的字符数组，是一个特别的字符数组，这是约定，是规则。空字符’\\0’也可以直接写成0。 1234567891011121314151617//初始化， 因为字符串需要用0结束，所以在定义字符串的时候，要预留多一个字节来存放0。char name[21]; // 定义一个最多存放20个字符或10个汉字的字符串//字符串是数组，当然可以用初始化数组的方法来初始化字符串。memset(strname,0,sizeof(strname));//字符串的赋值strcpy(strword,&quot;hello&quot;);// 或者用以下代码char strword[21];memset(strword,0,sizeof(strword));strword[0]=&#x27;h&#x27;;strword[1]=&#x27;e&#x27;;strword[2]=&#x27;l&#x27;;strword[3]=&#x27;l&#x27;;strword[4]=&#x27;o&#x27;;strword[5]=&#x27;\\0&#x27;; // 或者 name[5]=0; 函数函数声明 return_type function_name( parameter list ); 返回值的数据类型return_type：函数执行完任务后的返回值，可以是int、char、double或其它自定义的数据类型。如果函数只执行任务而不返回值，return_type用关键字 void表示，如下： 1void function_name( parameter list ); 函数名function_name：函数名是标识符，命名规则与变量相同。 参数列表parameter list：当函数被调用时，调用者需要向函数传递参数。参数列表包括参数的数据类型和书写顺序。参数列表是可选的，也就是说，函数可以没有参数，如下： 1return_type function_name(); 函数定义12345//函数定义的return_type、function_name和parameter list必须与函数声明一致。return_type function_name( parameter list ) // 注意，不要在函数定义的最后加分号。 &#123; // 实现函数功能的代码 &#125; 注意： #include &lt;&gt; 用于包含系统提供的头文件，编译的时候，gcc在系统的头文件目录中寻找头文件。 #include “” 用于包含程序员自定义的头文件，编译的时候，gcc先在当前目录中寻找头文件，如果找不到，再到系统的头文件目录中寻找。 库函数C语言标准库函数的声明的头文件存放在/usr/include目录中，如下： 123&lt;asset.h&gt; &lt;ctype.h&gt; &lt;errno.h&gt; &lt;float.h&gt; &lt;limits.h&gt;&lt;locale.h&gt; &lt;math.h&gt; &lt;setjmp.h&gt; &lt;signal.h&gt; &lt;stdarg.h&gt;&lt;stddef.h&gt; &lt;stdlib.h&gt; &lt;stdio.h&gt; &lt;string.h&gt; &lt;time.h&gt; 变量的作用域作用域是程序中定义的变量存在（或生效）的区域，超过该区域变量就不能被访问。C 语言中有四种地方可以定义变量。 在所有函数外部定义的是全局变量。 在头文件中定义的是全局变量。 在函数或语句块内部定义的是局部变量。它们只能在该函数或语句块内部的语句使用。 函数的参数是该函数的局部变量。 注意 局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量。 指针变量 内存变量简称变量，在C语言中，每定义一个变量，系统就会给变量分配一块内存，而内存是有地址的。如果把计算机的内存区域比喻成一个大宾馆，每块内存的地址就像宾馆房间的编号。 12345678 int ii=10; char cc=&#x27;A&#x27;; double dd=100.56;//在printf函数中，输出内存地址的格式控制符是%p，地址采用十六进制的数字显示。 printf(&quot;变量ii的地址是：%p\\n&quot;,&amp;ii); printf(&quot;变量cc的地址是：%p\\n&quot;,&amp;cc); printf(&quot;变量dd的地址是：%p\\n&quot;,&amp;dd); 指针 指针是一种特别变量，全称是指针变量，专用于存放其它变量在内存中的地址编号，指针在使用之前要先声明，语法是： 123456789101112131415161718192021222324252627282930313233343536datatype *varname;datatype 是指针的基类型，它必须是一个有效的C数据类型（int、char、double或其它自定义的数据类型），varname 是指针的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。int *ip; // 一个整型的指针char *cp; // 一个字符型的指针double *dp; // 一个 double 型的指针int ii = 10;int *pii = 0; // 定义整数型指针并初始化pii = &amp;ii; // 数型指针指向变量ii// 通过指针操作内存变量，改变内存变量的值*pii = 20; // 同ii=20;printf(&quot;pii的值是：%p\\n&quot;, pii);printf(&quot;*pii的值是：%d\\n&quot;, *pii);printf(&quot;ii的值是：%d\\n&quot;, ii);//空指针int *pi=0; // 定义一个指针*pi=10; // 试图对空指针进行赋值操作，必将引起程序的崩溃//地址的运算char cc[4]; // 字符数组int ii[4]; // 整数数组double dd[4]; // 浮点数组// 用地址相加的方式显示数组全部元素的的址printf(&quot;%p %p %p %p\\n&quot;,cc,cc+1,cc+2,cc+3);printf(&quot;%p %p %p %p\\n&quot;,ii,ii+1,ii+2,ii+3);printf(&quot;%p %p %p %p\\n&quot;,dd,dd+1,dd+2,dd+3);//指针也是一种内存变量，是内存变量就要占用内存空间，在C语言中，任何类型的指针占用8字节的内存（32位操作系统4字节）。printf(&quot;sizeof(int *) is %d.\\n&quot;,sizeof(int *)); // 输出：sizeof(int *) is 8printf(&quot;sizeof(char *) is %d.\\n&quot;,sizeof(char *)); // 输出：sizeof(char *) is 8printf(&quot;sizeof(double *) is %d.\\n&quot;,sizeof(double *)); // 输出：sizeof(double *) is 8 整数在定义整型变量的时候，可以在int关键字之前加signed、unsigned、short和long四种修饰符。 signed：有符号的，可以表示正数和负数。 unsigned：无符号的，只能表示正数，例如数组的下标、人的身高等。 short：短的，现在主流的64位操作系统下，整数占用内存4个字节。 long：长的，更长的整数。 整数的取值范围整数的取值范围与计算机操作系统和C语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围。 12345678910111213一个字节有8个位，表示的数据的取值范围是28-1，即255。如果占用的内存是两个字节，无符号型取值范围是2**8ⅹ2**8-1。如果占用的内存是四个字节，无符号型取值范围是2**8ⅹ2**8ⅹ2**8ⅹ2**8-1。如果占用的内存是八个字节，无符号型取值范围是2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8-1。如果是有符号，取值范围减半，因为符号占一个位。short si; // 短整数int ii; // 整数long li; // 长整数printf(&quot;sizeof short is %d\\n&quot;,sizeof(short));printf(&quot;sizeof int is %d\\n&quot;,sizeof(int));printf(&quot;sizeof long is %d\\n&quot;,sizeof(long)); 类型简写 类型全称 长度 取值范围 short [signed] short [int] 2字节 -32768~32767 unsigned short unsigned short [int] 2字节 0~65535 int [signed] int 4字节 -2147483648~2147483647 unsigned int unsigned [int] 4字节 0~4294967295 long [signed] long [int] 8字节 -9223372036854775808~9223372036854775807 unsigned long unsigned long [int] 8字节 0~18446744073709551615 注意： 计算机用最高位1位来表达符号（0-正数，1-负数），unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍。 在写程序的时候，上表中括号[]的单词可以省略不书写。 在写程序的时候，给整数变量赋值不能超出变量的取值范围，编译的时候会出现类似以下的错误，程序运行也可能产生不可预后的后果。 常用的库函数 1234int atoi(const char *nptr); // 把字符串nptr转换为int整数long atol(const char *nptr); // 把字符串nptr转换为long整数int abs(const int j); // 求int整数的绝对值long labs(const long int j); // 求long整数的绝对值 数据类型的别名 12typedef unsigned int size_t;size_t ii; 等同于 unsigned int ii; 类型转换自动类型转换整型类型级别从低到高依次为： signed char-&gt;unsigned char-&gt;short-&gt;unsigned short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long 浮点型级别从低到高依次为： float-&gt;double 操作数中没有浮点型数据时 当 char、unsigned char、short 或 unsigned short 出现在表达式中参与运算时，一般将其自动转换为 int 类型。int 与 unsigned int混合运算时，int自动转换为unsigned int型。int、unsigned int 与 long 混合运算时，均转换为 long 类型。 操作数中有浮点型数据时 当操作数中含有浮点型数据时，所有操作数都将转换为 double 型。 赋值运算符两侧的类型不一致时 当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型提升/降低为左值类型。 右值超出左值类型范围时 赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。 强制类型转换 (目标类型) 表达式; 结构体结构体（struct）来存放一组不同类型的数据。语法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct 结构体名&#123; 结构体成员变量一的声明; 结构体成员变量二的声明; 结构体成员变量三的声明; ...... 结构体成员变量四的声明;&#125;;struct st_girl&#123; char name[51]; // 姓名 int age; // 年龄 int height; // 身高，单位：cm int weight; // 体重，单位：kg char sc[31]; // 身材，火辣；普通；飞机场 char yz[31]; // 颜值，漂亮；一般；歪瓜裂枣&#125;;//结构体是一种程序员自定义的数据类型，是模板，可以用它来定义变量struct st_girl queen, princess, waiting, workers;struct st_girl queen;printf(&quot;sizeof(struct st_girl) %d\\n&quot;,sizeof(struct st_girl));printf(&quot;sizeof(queen) %d\\n&quot;,sizeof(queen)); //C语言提供了结构体成员内存对齐的方法，在定义结构体之前，增加以下代码可以使结构体成员变量之间的内存没有空隙。#pragma pack(1)//和数组不一样，结构体变量名不是结构体变量的地址，结构体变量名就是变量名，就象int ii一样，只是不能直接输出，直接输出没有意义。取地址要用&amp;struct st_girl stgirl;printf(&quot;%d\\n&quot;,stgirl); // 没有意义。printf(&quot;%p\\n&quot;,stgirl); // 没有意义，结构体变量名不是结构体变量的地址。printf(&quot;%p\\n&quot;,&amp;stgirl); // 这才是结构体的地址。//结构体的初始化memset(&amp;queen,0,sizeof(struct st_girl));//或memset(&amp;queen,0,sizeof(queen));//注意事项，如果把一个结构体的地址传给子函数，子函数用一个结构体指针（如struct st_girl *pst）来存放传入的结构体的地址，那么，在子函数中只能用以下方法来初始化结构体memset(pst,0,sizeof(struct st_girl));//结构体指针struct st_girl queen;struct st_girl *pst=&amp;queen; //结构体指针使用成员变量(*pointer).memberNamepointer-&gt;memberName//结构体复制struct st_girl girl1,girl2;strcpy(girl1.name,&quot;西施&quot;); // 对girl1的成员赋值girl1.age=18;memcpy(&amp;girl2,&amp;girl1,sizeof(struct st_girl));//结构体是多个变量集合，作为函数参数时就可以传递整个集合，也就是所有成员。如果结构体成员较多，函数参数的初始化和赋值的内存开销会很大，影响程序的运行效率。所以最好的办法就是传递结构体变量的地址。// 对结构体赋值的函数void setvalue(struct st_girl *pst);struct st_girl queen; // 定义结构体变量 // 初始化结构体变量memset(&amp;queen,0,sizeof(struct st_girl)); 格式化输出1234567int printf(const char *format, ...);int sprintf(char *str, const char *format, ...);int snprintf(char *str, size_t size, const char *format, ...);//printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。 格式说明符 %[flags][width][.prec]type 类型符type：表示输出数据的类型 %hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。 %hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数 %c 输出字符。 %lf 以普通方式输出double（float弃用，long doube无用）。 %e 以科学计数法输出double。 %s 输出字符串。 %p 输出内存的地址。 宽度width：用于控制输出内容的宽度 123printf(&quot;=%12s=\\n&quot;,&quot;abc&quot;); // 输出= abc=printf(&quot;=%12d=\\n&quot;,123); // 输出= 123=printf(&quot;=%12lf=\\n&quot;,123.5); // 输出= 123.500000= 对其标志flags：用于控制输出内容的对齐方式 不填或+：输出的内容右对齐，这是缺省的方式 -：输出的内容左对齐。 12345678printf(&quot;=%-12s=\\n&quot;,&quot;abc&quot;); // 输出=abc =printf(&quot;=%-12d=\\n&quot;,123); // 输出=123 =printf(&quot;=%-12f=\\n&quot;,123.5); // 输出=123.500000 =printf(&quot;=%012s=\\n&quot;,&quot;abc&quot;); // 输出= abc=printf(&quot;=%012d=\\n&quot;,123); // 输出=000000000123=printf(&quot;=%012f=\\n&quot;,123.5); // 输出=00123.500000= 精度prec：如果输出的内容是浮点数，它用于控制输出内容的精度，也就是说小数点后面保留多少位，后面的数四舍五入。 1234printf(&quot;=%12.2lf=\\n&quot;,123.5); // 输出= 123.50=printf(&quot;=%.2lf=\\n&quot;,123.5); // 输出=123.50=printf(&quot;=%12.2e=\\n&quot;,123500000000.0); // 输出= 1.24e+11=printf(&quot;=%.2e=\\n&quot;,123500000000.0); // 输出=1.24e+11= main函数12345678910int main(int argc,char *argv[],char *envp[])//int argc，存放了命令行参数的个数。//char *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。//char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。//envp存放了当前程序运行环境的参数。 动态内存管理1234567void *malloc(unsigned int size)；//malloc的作用是向系统申请一块大小为size的连续内存空间，如果申请失败，函数返回0，如果申请成功，返回成功分配内存块的起始地址。malloc(100)； // 申请 100 个字节的临时分配域，返回值为其第一个字节的地址void free(void *p);//free的作用是释放指针p指向的动态内存空间，p是调用malloc函数时返回的地址，free函数无返回值。 野指针 内存指针变量未初始化 内存释放后之后指针未置空 1234567int *pi=0;int i;int *pi=&amp;i;free(pi);pi=0; 文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//操作文件的时候，C语言为文件分配一个信息区，该信息区包含文件描述信息、缓冲区位置、缓冲区大小、文件读写到的位置等基本信息，这些信息用一个结构体来存放（struct _IO_FILE），这个结构体有一个别名FILE（typedef struct _IO_FILE FILE），FILE结构体和对文件操作的库函数在 stdio.h 头文件中声明的。//打开文件的时候，fopen函数中会动态分配一个FILE结构体大小的内存空间，并把FILE结构体内存的地址作为函数的返回值，程序中用FILE结构体指针存放这个地址。//关闭文件的时候，fclose函数除了关闭文件，还会释放FILE结构体占用的内存空间。//FILE结构体指针习惯称为文件指针。FILE *fopen( const char * filename, const char * mode );//参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的当前目录。实际开发中，采用文件的全路径。//参数mode也是字符串，表示打开文件的方式（模式），打开方式可以是下列值中的一个。//r 只读 文件必须存在，否则打开失败//w 只写 如果文件存在，则清除原文件内容；如果文件不存在，则新建文件。//a 追加只写 如果文件存在，则打开文件，如果文件不存在，则新建文件。//r+ 读写 文件必须存在。在只读 r 的基础上加 &#x27;+&#x27; 表示增加可写的功能。//w+ 在只写w的方式上增加可读的功能。//a+ 在追加只写a的方式上增加可读的功能。/*注意了，不同教材中对文件打开的方式有不同的说法。有的说打开文本文件的方式要用&quot;rt&quot;、&quot;wt&quot;、&quot;at&quot;、&quot;rt+&quot;、&quot;wt+&quot;、&quot;at+&quot;，&quot;t&quot;是text的简写，&quot;t&quot;可以省略不写。有的说打开二进制文件的方式要用&quot;rb&quot;、&quot;wb&quot;、&quot;ab&quot;、&quot;rb+&quot;、&quot;wb+&quot;、&quot;ab+&quot;，&quot;b&quot;是binary的简写。准确的说，在Linux平台下，打开文本文件和二进制文件的方式没有区别。在windows平台下，如果以“文本”方式打开文件，当读取文件的时候，系统会将所有的&quot;\\r\\n&quot;转换成&quot;\\n&quot;；当写入文件的时候，系统会将&quot;\\n&quot;转换成&quot;\\r\\n&quot;写入， 如果以&quot;二进制&quot;方式打开文件，则读和写都不会进行这样的转换，真是罗嗦。*/int fclose(FILE *fp);int fprintf(FILE *fp, const char *format, ...);char *fgets(char *buf, int size, FILE *fp);/*fgets的功能是从文件中读取一行。参数buf是一个字符串，用于保存从文件中读到的数据。参数size是打算读取内容的长度。参数fp是待读取文件的文件指针。如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。*/ 二进制文件处理 12345678910111213141516size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);//ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。//size：固定填1。//nmemb：表示打算写入数据的字节数。//fp：表示文件指针。//函数的返回值是本次成功写入数据的字节数size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp);//ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。//size：固定填1。//nmemb：表示打算读取的数据的字节数。//fp：表示文件指针。//调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。 文件定位12345678910111213141516171819202122//ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。long ftell(FILE *fp);//rewind函数用来将位置指针移动到文件开头void rewind ( FILE *fp );//fseek() 用来将位置指针移动到任意位置int fseek ( FILE *fp, long offset, int origin );//fp 为文件指针，也就是被移动的文件。//offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。//origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。fseek(fp,100,0); // 从文件的开始位置计算，向后移动100字节。fseek(fp,100,1); // 从文件的当前位置计算，向后移动100字节。fseek(fp,-100,2); // 从文件的尾部位置计算，向前移动100字节。/**当offset是向文件尾方向偏移的时候，无论偏移量是否超出文件尾，fseek都是返回0，当偏移量没有超出文件尾的时候，文件指针式指向正常的偏移地址的，当偏移量超出文件尾的时候，文件指针是指向文件尾的，不会返回偏移出错-1值。当offset是向文件头方向偏移的时候，如果offset没有超出文件头，是正常偏移，文件指针指向正确的偏移地址，fseek返回值为0，当offset超出文件头时，fseek返回出错-1值，文件指针还是处于原来的位置。**/ 文件缓冲区在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。 1int fflush(FILE *fp); 标准输入、标准输出、标准错误Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。 目录操作1234567891011121314151617181920212223242526272829303132333435363738//获取当前目录char strpwd[301];memset(strpwd,0,sizeof(strpwd));getcwd(strpwd,300);printf(&quot;当前目录是：%s\\n&quot;,strpwd);//切换工作目录int chdir(const char *path);//目录的创建和删除int mkdir(const char *pathname, mode_t mode);int rmdir(const char *pathname);//获取目录中的文件列表#include &lt;dirent.h&gt;//打开目录DIR *opendir(const char *pathname);//读取目录struct dirent *readdir(DIR *dirp);//关闭目录int closedir(DIR *dirp);//目录指针DIR *目录指针名;//每调用一次readdir函数会返回一个struct dirent的地址，存放了本次读取到的内容，它的原理与fgets函数读取文件相同。struct dirent&#123; long d_ino; // inode number 索引节点号 off_t d_off; // offset to this dirent 在目录文件中的偏移 unsigned short d_reclen; // length of this d_name 文件名长 unsigned char d_type; // the type of d_name 文件类型 char d_name [NAME_MAX+1]; // file name文件名，最长255字符&#125;; 时间操作123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef long time_t;time_t tnow;tnow =time(0); // 将空地址传递给time函数，并将time返回值赋给变量tnowtime(&amp;tnow); // 将变量tnow的地址作为参数传递给time函数struct tm&#123; int tm_sec; // 秒：取值区间为[0,59] int tm_min; // 分：取值区间为[0,59] int tm_hour; // 时：取值区间为[0,23] int tm_mday; // 日期：一个月中的日期：取值区间为[1,31] int tm_mon; // 月份：（从一月开始，0代表一月），取值区间为[0,11] int tm_year; // 年份：其值等于实际年份减去1900 int tm_wday; // 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 int tm_yday; // 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 int tm_isdst; // 夏令时标识符，该字段意义不大，我们不用夏令时。&#125;;struct tm * localtime(const time_t *);//函数用于把struct tm表示的时间转换为time_t表示的时间time_t mktime(struct tm *tm);//unsigned int sleep(unsigned int seconds);int usleep(useconds_t usec);struct timeval&#123; long tv_sec; // 1970年1月1日到现在的秒。 long tv_usec; // 当前秒的微妙，即百万分之一秒。&#125;;struct timezone&#123; int tz_minuteswest; // 和UTC（格林威治时间）差了多少分钟。 int tz_dsttime; // type of DST correction，修正参数据，忽略&#125;;//gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数int gettimeofday(struct timeval *tv, struct timezone *tz ) 编译预处理 C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件 预处理指令 包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。 宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。 条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。 12345678910111213141516171819202122232425262728//如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的 include文件中去找指定的文件（/usr/include）//#include包含文件，可以是 “.h”,表示C语言程序的头文件，也可以是“.c”,表示包含普通C语言源程序。#include &lt;文件名&gt;#include &quot;文件名&quot;//宏定义#define 宏名 字符串/*define 关键字“define”为宏定义命令。宏名 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。字符串 可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。*/#define PI 3.141592/*宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，编译预处理时不会对它进行语法检查，如有错误，只能在编译已被宏展开后的源程序时发现。 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。建议不要这么做，会把程序复杂化。 习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。*///带参数的宏#define 宏名(形参表) 字符串#define MAX(x,y) ((x)&gt;(y) ? (x) : (y)) 条件编译123456789101112131415#ifdef 标识符 程序段 1#else 程序段 2#endif#ifndef 标识符 程序段 1#else 程序段 2 #endif//取消已定义的标志符#undef 系统错误我们在写程序的时候需要调用C语言提供的库函数，并通过函数的返回值判断调用是否成功。其实在C语言中，还有一个全局变量errno，存放了函数调用过程中产生的错误码。 为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为 errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt; 文件中。如果库函数调用失败，可以通过读出 errno 的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。 配合 strerror和perror两个库函数，可以很方便地查看出错的详细信息。 strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。 perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。 1234char *strerror(int errno);//strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。 参考 https://freecplus.net/3e27bfb1a810493d9a0550131e2a1633.html","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"cef笔记","slug":"程序语言/C++/cef","date":"2021-06-07T01:45:07.566Z","updated":"2021-06-07T01:45:07.566Z","comments":true,"path":"wiki/程序语言/C++/cef/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/cef/","excerpt":"","text":"官网：https://github.com/chromiumembedded/cef下载地址：http://opensource.spotify.com/cefbuilds/index.html Python版： https://github.com/cztomczak/cefpython","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"socket编程笔记","slug":"程序语言/C++/socket编程笔记","date":"2021-06-07T01:45:07.566Z","updated":"2021-06-07T01:45:07.566Z","comments":true,"path":"wiki/程序语言/C++/socket编程笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/socket%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"API介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int socket(int af, int type, int protocol);af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAMprotocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDPint bind(int sock, struct sockaddr *addr, socklen_t addrlen); //Linuxint bind(SOCKET sock, const struct sockaddr *addr, int addrlen); //Windowssock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。struct sockaddr_in&#123; sa_family_t sin_family; //地址族（Address Family），也就是地址类型 uint16_t sin_port; //16位的端口号 struct in_addr sin_addr; //32位IP地址 char sin_zero[8]; //不使用，一般用0填充&#125;;int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); //Linuxint connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows让套接字进入被动监听状态，所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。 int listen(int sock, int backlog); //Linuxint listen(SOCKET sock, int backlog); //Windowssock 为需要进入监听状态的套接字backlog 为请求队列的最大长度请求队列当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); //LinuxSOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen); //Windows返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字Linux下的数据接收和发送会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。ssize_t write(int fd, const void *buf, size_t nbytes);fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。 会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。ssize_t read(int fd, void *buf, size_t nbytes);Windows下的数据接收和发送int send(SOCKET sock, const char *buf, int len, int flags);int recv(SOCKET sock, char *buf, int len, int flags); 基本概念socket缓冲区每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。 write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。 TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 这些I/O缓冲区特性可整理如下： I/O缓冲区在每个TCP套接字中单独存在； I/O缓冲区在创建套接字时自动生成； 即使关闭套接字也会继续传送输出缓冲区中遗留的数据； 关闭套接字将丢失输入缓冲区中的数据。 输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取： 12345unsigned optVal;int optLen = sizeof(int);getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&amp;optVal, &amp;optLen);printf(&quot;Buffer length: %d\\n&quot;, optVal); 阻塞模式对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时： 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。 直到所有数据被写入缓冲区 write()/send() 才能返回。 当使用 read()/recv() 读取数据时： 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。 这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。 TCP数据报结构以及三次握手TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。 客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话： [Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。” [Shake 2] 套接字B：“好的，我这边已准备就绪。” [Shake 3] 套接字A：“谢谢你受理我的请求。” TCP数据报结构 带阴影的几个字段需要重点说明一下： 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：建立一个新连接。 FIN：断开一个连接。 Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。 连接的建立（三次握手） 客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。 这个时候，客户端开始发起请求： 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。服务器将数据包发出，进入SYN-RECV状态。 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。 数据的传输过程 上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。 为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。 此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号： Ack号 = Seq号 + 传递的字节数 + 1，与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。 下面分析传输过程中数据包丢失的情况，如下图所示： 上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。 为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。 重传超时时间（RTO, Retransmission Time Out） 这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。 往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。 重传时间 TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。 TCP四次握手断开连接建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话： [Shake 1] 套接字A：“任务处理完毕，我希望断开连接。” [Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。” 等待片刻后…… [Shake 3] 套接字B：“我准备好了，可以断开连接了。” [Shake 4] 套接字A：“好的，谢谢合作。” 建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求： 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 关于 TIME_WAIT 状态的说明 客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？ TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。 客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？ 数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。 窗口协议ARQ协议ARQ协议主要包含：停等ARQ协议、连续ARQ协议，其中连续ARQ协议是为了解决停等ARQ协议信道利用率低的问题，目前传统的连续ARQ协议有回退N帧ARQ协议、选择性重传ARQ协议。 连续ARQ协议（Continuous ARQ） 回退N帧ARQ协议（Go-Back-N） 接收端丢弃从第一个没有收到的数据包开始的所有数据包 发送端收到NACK后，从NACK中指明的数据包开始重新发送 选择性重传ARQ协议（Selective Repeat） 发送端连续发送数据包但对每个数据包都设有个一个计时器 当在一定时间内没有收到某个数据包的ACK时，发送端只重新发送那个没有ACK的数据包","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"C++学习笔记","slug":"程序语言/C++/C++学习笔记","date":"2021-06-07T01:45:07.565Z","updated":"2021-06-07T01:45:07.565Z","comments":true,"path":"wiki/程序语言/C++/C++学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"函数重载（Function Overloading）定义：函数名相同，函数的参数列表包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。 12345// 解析XML字符串的函数族，支持int、char *和double三种类型。// 返回值：0-成功，-1-失败。int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,int *out_Value);int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,char *out_Value);int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,double *out_Value); C++编译器在编译的时候会根据参数列表的类型对函数进行重命名，比如： 1int GetXMLBuffer_char_char_int(const char *in_XMLBuffer,const char *in_FieldName,int *out_Value); 结构体新特征在C++中，结构体的成员可以有函数。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct st_girl &#123; char name[50]; // 姓名 int age; // 年龄 int height; // 身高，单位：厘米cm char sc[30]; // 身材，火辣；普通；飞机场。 char yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 int show(); // 声明结构体成员函数show，用于显示其它成员变量的值。&#125;;int main() &#123; st_girl stgirl; // struct关键定可以不书写 memset(&amp;stgirl, 0, sizeof(stgirl)); strcpy(stgirl.name, &quot;西施&quot;); stgirl.age = 22; stgirl.height = 168; strcpy(stgirl.sc, &quot;火辣&quot;); strcpy(stgirl.yz, &quot;漂亮&quot;); stgirl.show(); // 调用结构体的成员函数&#125;int st_girl::show() // 结构体st_girl成员函数的定义&#123; printf(&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\\n&quot;, name, age, height, sc, yz);&#125; 类详解构造函数 构造函数必须是 public 属性。 构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。 构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。 构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，注意，不能用memset对整个类进行初始化。 析构函数 析构函数必须是 public 属性的。 析构函数没有参数。 析构函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。 析构函数不允许重载的。一个类只能有一个析构函数。 1234567891011121314151617181920212223242526272829303132//头文件class CFile&#123;private: FILE *m_fp; // 文件指针 bool m_bEnBuffer; // 是否启用缓冲区，true-启用；false-不启用 public: CFile(); // 类的构造函数 CFile(bool bEnBuffer); // 类的构造函数 ~CFile(); // 类的析构函数 void EnBuffer(bool bEnBuffer=true); // 启、禁用缓冲区 // 打开文件，参数与fopen相同，打开成功true，失败返回false bool Open(const char *filename,const char *openmode); // 调用fprintf向文件写入数据 void Fprintf(const char *fmt, ... ); // 调用fgets从文件中读取一行 bool Fgets(char *strBuffer,const int ReadSize); // 关闭文件指针 void Close();&#125;; 12345678910111213141516171819//实现文件CFile::CFile() // 类的构造函数&#123; m_fp=0; m_bEnBuffer=true;&#125; CFile::CFile(bool bEnBuffer) // 类的构造函数&#123; m_fp=0; m_bEnBuffer=bEnBuffer; &#125;CFile::~CFile() // 类的析构函数&#123; Close(); // 调用Close释放资源&#125; C++引用引用就是变量的别名，对引用的操作与对变量直接操作完全一样。 12345//数据类型 &amp;引用名=目标变量名；int ii;int &amp;rii=ii; // 定义引用rii，它是变量ii的引用，即别名。rii=1; 等价于 ii=1; &amp;在此不是求地址运算，而是声明引用。 数据类型可以是C语言的基本数据类型，也可以是结构体和类等构造类型。 引用在声明的时候必须对其进行初始化（指向目标变量名），否则编译器会报错。 引用初始化之后，不能再用作其他变量名的别名。 引用声明后，相当于目标变量名有两个名称。 不能建立数组的引用，因为数组是多个变量的集合。 引用可以用const修饰，表示只读，用这种方式声明的引用，不能通过引用名对目标变量的值进行修改。 运算符重载123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt; class CGirl // 定义类&#123;public: char m_name[50]; // 姓名 char m_sc[30]; // 身材，火辣；普通；飞机场。 bool operator==(const CGirl &amp;Girl); // 重载==运算符&#125;; int main()&#123; CGirl Girl1,Girl2; strcpy(Girl1.m_name,&quot;西施&quot;); strcpy(Girl2.m_name,&quot;东施&quot;); if (Girl1 == Girl2) printf(&quot;Girl1和Girl2是同一个人。\\n&quot;); else printf(&quot;Girl1和Girl2不是同一个人。\\n&quot;);&#125; bool CGirl::operator==(const CGirl &amp;Girl) // 重载==运算符&#123; // 如果两个类的姓名相同，就相等 if (strcmp(m_name,Girl.m_name)== 0) return true; return false;&#125; string类123456789101112131415#include &lt;string&gt;//string是一个模板类，位于std命名空间内，为方便使用还需要在程序中增加：using namespace std; // 指定缺省的使名空间。string str; // 创建string对象。//如果不指定命名空间std::string str;const char *c_str();//c_str函数返回这个字符串的地址int size(); // 返回当前字符串的大小。int length(); // 返回当前字符串的长度，注意和size的区别。void clear(); // 清空字符串。 vector类12345678910111213141516171819202122232425262728iterator begin()：返回容器头的指针，指向容器第一个元素的位置。iterator end()：返回容器尾的指针，指向容器最后一个元素的下一个位置。void push_back(const T&amp; x)：向容器的尾部增加一个元素x。iterator insert(iterator it,const T&amp; x)：向容器中指定位置（it）前插入一个元素x。iterator erase(iterator it)：删除容器中指定位置（it）的元素。bool empty()：判断容器是否为空。int size()：返回容器中元素的个数。sort(begin,end,cmp);/**sort函数包含在头文件为#include &lt;algorithm&gt;的c++标准库中，调用排序方法不必知道其内部是如何实现的，只要出现我们想要的结果就行。sort函数有三个参数：（1）第一个是要排序的数组的起始地址。（2）第二个是结束的地址。（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时缺省的排序方法是从小到大排序。如果vector容器中元素的数据类型不是基本数据类型，sort函数必须指定排序方法函数。**/ C++动态内存123456789101112datatype *pointer = new datatype; // 其它代码delete pointer;//datatype可以是C语言的基本数据类型，也可以是结构体，还可以是类。//pointer是一个指针，指向new返回的地址。int *pi= new int; // 动态分配一个整数大小的内存(*pi)=10;delete pi; // 释放pi指向的内存 继承和派生123456789101112class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123; // 派生类类体&#125;;class CGirl // 定义超女类&#123;&#125;class CKCon:public CGirl // 定义王妃类，从超女类继承&#123;&#125; 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种方式，当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当类派生以public方式继承时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当类派生以protected方式继承时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当类派生以private方式继承时，基类的公有和保护成员将成为派生类的私有成员。 多态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;string.h&gt;class CGirl // 定义超女类&#123;public: char m_name[50]; // 姓名 int m_age; // 年龄 int m_height; // 身高，单位：厘米cm char m_sc[30]; // 身材，火辣；普通；飞机场。 char m_yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 int Show() // 显示超女基本信息的成员函数体 &#123; printf(&quot;CGirl 姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\\n&quot;, m_name, m_age, m_height, m_sc, m_yz); &#125;&#125;;class CKCon : public CGirl // 定义王妃类，从超女类继承&#123;public: char m_ch[50]; // 称号 char m_palace[50]; // 居住的宫殿 int m_sal; // 奉禄 int Show() // 显示王妃的称号、宫殿和奉禄 &#123; printf(&quot;CKCon 姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\\n&quot;, m_name, m_ch, m_palace, m_sal); &#125;&#125;;int main() &#123; CKCon KCon; strcpy(KCon.m_name, &quot;杨玉环&quot;); KCon.m_age = 28; KCon.m_height = 168; strcpy(KCon.m_sc, &quot;火辣&quot;); strcpy(KCon.m_yz, &quot;漂亮&quot;); strcpy(KCon.m_ch, &quot;杨贵妃&quot;); strcpy(KCon.m_palace, &quot;华清宫&quot;); KCon.m_sal = 10000; CGirl *pGirl; // 基类的指针 CKCon *pCon; // 派生类的指针 pGirl = pCon = &amp;KCon; // 都指向派生类 pGirl-&gt;Show(); // 将调用的是基类的Show方法 pCon-&gt;Show(); // 将调用的是派生类的Show方法&#125; 动态多态 动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。在CGirl类中，Show方法的声明前放置关键字 virtual，则pGirl-&gt;Show()会打印出CKCon中的show方法内容。 虚函数 虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义虚函数。我们想要的是在程序中可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 纯虚函数 只声明，具体实现在派生类中实现 1234567891011class CGirl // 定义超女类&#123;public: char m_name[50]; // 姓名 int m_age; // 年龄 int m_height; // 身高，单位：厘米cm char m_sc[30]; // 身材，火辣；普通；飞机场。 char m_yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 virtual int Show()=0; // 申明一个纯虚函数。&#125;;","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"计算机网络知识总结","slug":"网络编程/计算机网络知识总结","date":"2021-06-07T01:45:07.562Z","updated":"2021-07-02T06:57:08.314Z","comments":true,"path":"wiki/网络编程/计算机网络知识总结/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"计算机网络的带宽网络可通用的最高数据率，即每秒多少比特bit。 计算机网络性能指标 速率 带宽 吞吐量 时延（delay或latency）： 传输时延：从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需时间 传播时延：电磁波在信道中需要传播一定的距离而花费的时间 处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间 排队时延：结点缓存队列中分组排队所经历的时延 时延带宽积 利用率： 信道利用率 网络利用率 数据链路层： 信道主要有以下两种类型： 点对点信道： 广播信道： 各层传输的数据单位： 网络层：IP数据报 数据链路层：帧 物理层：比特 数据链路层传输数据时三个基本问题： 封装成帧 透明传输 差错控制 点对点协议（Point-to-Point Protocol） PPP协议应满足的需求： 简单 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传输单元 网络层地址协商 数据压缩协商 PPP协议不需要的功能： 纠错 流量控制 序号 多点线路 半双工或单工链路 PPP协议有三个组成部分 一个将IP数据报封装到串行链路的方法； 链路控制协议LCP 网络控制协议NCP PPP协议之不使用序号和确认机制 网际协议IP IP时TCP/IP体系中两个最主要的协议之一，与IP协议配套使用的还有四个协议： 地址解析协议ARP（Address Resolution Protocol） 逆地址解析协议RARP（Reverse Address Resolution Protocol） 网际控制报文协议ICMP（Internet Control Message Protocol） 网际组管理协议IGMP（Internet Group Management Protocol） 网络互相连接起来要使用的一些中间设备 物理层中继系统：转发器（repeater）、中继器 数据链路层中继系统：网桥或桥接器 网络层中继系统：路由器 网桥和路由器的混合物：桥路器（brouter） 网络层以上的中继系统：网关（gateway） TCP、UDP的区别 TCP三次握手 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户 端和服务器总共发送 3 个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。 在 socket 编程中，客户端执行 connect()时，将触发三次握手:即客户端和服务端通信前要进行连接，3次握手的作用就是双方都能明确自己和对方的收、发能力正常。 TCP四次挥手 参考 https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html","raw":null,"content":null,"categories":[{"name":"网络编程","slug":"网络编程","permalink":"http://shjlone.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://shjlone.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"FFMpeg常用命令","slug":"技术开发/杂项/常用ffmpeg命令","date":"2021-06-07T01:45:07.562Z","updated":"2021-06-07T06:12:10.827Z","comments":true,"path":"wiki/技术开发/杂项/常用ffmpeg命令/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%B8%B8%E7%94%A8ffmpeg%E5%91%BD%E4%BB%A4/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#格式转换ffmpeg -i input.avi output.mp4ffmpeg -i input.mp4 output.ts#提取音频ffmpeg -i input.mp4 -acodec copy -vn output.aac#提取视频ffmpeg -i input.mp4 -vcodec copy -an output.mp4#视频剪切 -ss表示开始时间 -t表示长度ffmpeg -ss 00:00:00 -t 00:00:10 -i input.mp4 -vcodec copy -acodec copy output.mp4#码率控制 bitrate=filesize/duration，比如一个文件20.8M，时长1分钟，那么，码率就是：biterate = 20.8M bit/60s = 20.8*1024*1024*8 bit/60s= 2831Kbps一般音频的码率只有固定几种，比如是128Kbps，那么，video的就是：video biterate = 2831Kbps -128Kbps = 2703Kbps。ffmpeg -i input.mp4 -b:v 2000k output.mp4ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4 # 官方建议加上-bufsize，用于设置码率控制缓冲器的大小ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4 # -minrate -maxrate 最小最大范围#视频编码格式转换ffmpeg -i input.mp4 -vcodec h264 output.mp4 #使用h264编码ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4 #使用mpeg4编码#视频大小修改ffmpeg -i input.mp4 -vf scale=960:540 output.mp4 //ps: 如果540不写，写成-1，即scale=960:-1, 那也是可以的，ffmpeg会通知缩放滤镜在输出时保持原始的宽高比#添加水印ffmpeg -i input.mp4 -i logo.png -filter_complex overlay output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4 #右上角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4 #左下角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4 #右下角#去掉logo有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。语法：-vf delogo=x:y:w:h[:t[:show]]x:y 离左上角的坐标w:h logo的宽和高t: 矩形边缘的厚度默认值4show：若设置为1有一个绿色的矩形，默认值0。ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4#从视频中获取指定尺寸的缩略图， -ss参数要在-i参数之前ffmpeg.exe -ss 2672 -i input.mkv -y -f mjpeg -t 0.01 -s 96x54 U:/xiaodao/src/temp/xxx.jpg#将gif转成mp4ffmpeg -f gif -i origin.gif -pix_fmt yuv420p output.mp4#使用基于GDI的抓屏设备ffmpeg -f gdigrab -i desktop out.mpg#从屏幕的（10,20）点处开始，抓取640x480的屏幕，设定帧率为5ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg#设置帧率ffmpeg -i input.avi -r 29.97 output.mpg#码率 ABR、CBR、VBRffmpeg -i film.avi -b 1.5M film.mp4ffmpeg -i file.avi -b:v 1500k output.mp4设置输出文件最大大小ffmpeg -i input.avi -fs 10MB output.mp4文件大小计算video_size = video_bitrate * time_in_seconds / 8如果音频没有压缩：audio_size = sampling_rate * bit_depth * channels * time_in_seconds / 8压缩音频的文件：audio_size = bitrate * time_in_seconds / 8缩放视频ffmpeg -i input_file -s 320x240 output_file高级缩放 scale=width:height[:interl=&#123;1|-1&#125;]ffmpeg -i input.mpg -vf scale=320:240 output.mp4根据输入来设置缩放大小ffmpeg -i input.mpg -vf scale=iw/2:ih*0.9 裁剪视频 crop=ow[:oh[:x[:y[:keep_aspect]]]]从左上角裁剪，宽度为原始尺寸的一半，高宽跟原始尺寸一样ffmpeg -i input -vf crop=iw/2:ih:0:0 output移动视频 pad=width[:height[:x[:y[:color]]]]ffmpeg -i photo.jpg -vf pad=860:660:30:30:pink framed_photo.jpg将视频比例从4:3转为16:9ffmpeg -i input -vf pad=ih*16/9:ih:(ow-iw)/2:0:color output翻转和旋转视频水平翻转ffplay -f lavfi -i testsrc -vf hflip旋转 transpose=&#123;0, 1, 2, 3&#125;ffplay -f lavfi -i smptebars -vf transpose=2, vflip画中画ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output水印在右下角ffmpeg -i pair.mp4 -i logo.png -filter_complex overlay=W-w:H-h pair1.mp4指定水印开始的时间ffmpeg -i video_width_timer.mp4 -itsoffset 5 -i logo.png -filter_complex overlay timer_width_logo.mp4修改速度ffplay -i input.mpg -vf setpts=PTS/3快放2倍，取值范围0.5-2.0ffplay -i speech.mp3 -af atempo=2创建元数据 -metadata 后面跟键值对ffmpeg -i input -metadata artist=FFmpeg -metadata title=&quot;test&quot; output保存元数据到文件ffmpeg -i video.wmv -f ffmetadata data.txt删除元数据ffmpeg -i input.avi -map_metadata -l output.mp4截图ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg获取gif动画ffmpeg -i promotion.swf -pix_fmt rgb24 promotion.gif根据图片创建视频ffmpeg -loop l -i photo.jpg -t 10 photo.mp4根据多张图片生成视频ffmpeg -f image2 -i img%d.jpg -r 25 video.mp4播放rtmpffplay &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot;保存直播流ffmpeg -i http://60.199.188.151/HLS/WG_ETTV-N/index.m3u8 -c:v copy -c:a copy -bsf:a aac_adtstoasc d:\\cap.mp4从视频中抽离部分生成webpffmpeg -t 3 -ss 00:00:01 -i $&#123;video_path&#125; -vf scale=320:-1 -q:v 50 -r 10 -compression_level 6 -vcodec libwebp -loop 0 $&#123;output_path&#125;从视频中提取关键帧图片ffmpeg -i video_name.mp4 -vf select=&#x27;eq(pict_type\\,I)&#x27; -vsync 2 -s 1920*1080 -f image2 keyframe-%02d.jpeg计算视频的时长ffmpeg -i source.mp4 2&gt;&amp;1 | grep &#x27;Duration&#x27; | cut -d &#x27; &#x27; -f 4 | sed s/,//合并两个视频实用文件的方式：1. 编写filetext.txt文件file ‘a.mp4’file ‘b.mp4’2. 执行命令ffmpeg -f concat -i filelist.txt -c copy output.mp4直接用命令行ffmpeg -i “concat:a.mp4|b.mp4&quot; -c copy output.mp4","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://shjlone.github.io/tags/ffmpeg/"}]},{"title":"按键精灵的使用记录","slug":"技术开发/杂项/按键精灵的使用记录","date":"2021-06-07T01:45:07.562Z","updated":"2021-06-07T01:45:07.562Z","comments":true,"path":"wiki/技术开发/杂项/按键精灵的使用记录/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"最近因为工作需要，研究了下按键精灵和相关生态。按键精灵的主要功能是模拟用户行为，可以导出Android、iOS的包。直接在手机上运行。大致猜测下实现原理： 电脑上通过用户的脚本，转换成相关指令，在电脑上的脚本应该通过adb相关指令来控制模拟器或者手机，到处的apk应该是通过调用系统的相关命令（sendevent等）来实现的。 图片检测像素检测应该是通过opencv相关库来实现的。 脚本的编写也是蹲守基本的编程规则，基本的运算、流程控制、多线程，不过还不够完善。 基本的脚本编写方式也比较傻瓜式，得到具体的坐标，模拟用户点击、输入。哪怕没学过编程的，上手也比较容易。 因为有了这样自动化的工具，再加上大量的需求（用户想刷游戏里的金币、自动完成任务），从而衍生出了许多贩售脚本的。根据这几天的调查，从事这一行的并不少。有依赖按键精灵开发脚本卖钱的，有根据用户需求定制脚本的，还有自己自主开发脚本卖VIP的（如：http://hm.hy6665.cn）。说明这个市场还是蛮大的。 按键精灵的使用按键精灵分为PC版和移动版，移动版在脚本开发完成后，可以导出相应App，在手机和模拟器直接安装即可使用。启动后，会有一个悬浮窗来控制脚本的运行。手机助手还有一个抓抓的功能，可以对模拟器进行截图，截图后可以使用像素点点颜色判断或者图片判断位置。 按键精灵的命令分类： 基本命令 界面命令 悬浮窗命令 扩展命令 标准库命令 运算符命令 插件命令 如何发送语音文件模拟用户按下开始录音，录音过程中替换音频文件使用e2eSoft vsc，将扬声器声音转到麦克风中。当用户按下时，播放提前准备好的音频文件，直接录制改声音。wwww.e2esoft.cn/record-music-with-vsc JSDROID实例 王者荣耀大厅自动喊话和给好友发送语音消息脚本","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"按键精灵","slug":"按键精灵","permalink":"http://shjlone.github.io/tags/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/"}]},{"title":"虚拟主机的玩法","slug":"技术开发/杂项/虚拟主机的玩法","date":"2021-06-07T01:45:07.562Z","updated":"2021-07-02T07:08:30.750Z","comments":true,"path":"wiki/技术开发/杂项/虚拟主机的玩法/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%8E%A9%E6%B3%95/","excerpt":"","text":"代理神器Shadowsocks安装 wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 操作 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 设置密码 查看ss服务器所开放的端口 ss -lntp | grep ssserver 查看ss的配置文件 ps aux | grep ssserver 修改对应的配置文件，重启 什么是socks代理Socks 是个电路级的底层网关，是 DavidKoblas 在 1990 年开发的， 此后就一直作为 Internet RFC 标准的开放标准。Socks 不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、 HTTP 层代理不同，Socks 代理只是简单地传递数据包，而不必关心是何种应用协议(比如 FTP、HTTP 和 NNTP 请求)。所以，Socks 代理比其他应用层代理要快得多。 云储存工具seafiledocker run -d --name seafile -e SEAFILE_SERVER_HOSTNAME=seafile.example.com -e SEAFILE_ADMIN_EMAIL=xxxj@gmail.com -e SEAFILE_ADMIN_PASSWORD=123456 -v /opt/seafile-data:/shared -p 8088:80 seafileltd/seafile:latest 搭建Maven仓库docker pull sonatype/nexus docker run -d -p 8081:8081 --name nexus -v /home/alone/nexus-data:/nexus-data sonatype/nexus3 /home/alone/nexus-data:/nexus-data表示数据存储目录 搭建FTP服务器修改ssh端口vim /etc/ssh/sshd_config修改Port 2222重启服务/etc/init.d/ssh restart 安装v2ray123456789101112131415161718192021222324252627282930313233343536373839404142卸载v2raysystemctl stop v2raysystemctl disable v2rayservice v2ray stopupdate-rc.d -f v2ray removerm -rf /etc/v2ray/* #(配置文件)rm -rf /usr/bin/v2ray/* #(程序)rm -rf /var/log/v2ray/* #(日志)rm -rf /lib/systemd/system/v2ray.service #(systemd 启动项)rm -rf /etc/init.d/v2ray #(sysv 启动项)wget https://install.direct/go.shsudo bash go.shwget https://git.io/v2ray.sh## 启动systemctl start v2ray## 停止systemctl stop v2ray## 重启systemctl restart v2ray## 开机自启systemctl enable v2ray查看状态service v2ray statuscenter os使用## 查看已开放端口firewall-cmd --zone=public --list-ports## 添加开放端口firewall-cmd --zone=public --add-port=80/tcp --permanent","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://shjlone.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"关于建设技术团队的思考","slug":"技术开发/技术管理/关于建设技术团队的思考","date":"2021-06-07T01:45:07.561Z","updated":"2021-06-07T01:45:07.561Z","comments":true,"path":"wiki/技术开发/技术管理/关于建设技术团队的思考/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8E%E5%BB%BA%E8%AE%BE%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"一个好的技术领导者真的可以为公司省很多钱，可以保障产品的质量。自己在这条路上还有很多路要走，现将自己的一些感悟记录下来。 一个优秀的团队，首先要有靠谱的成员，至少核心成员要靠谱，要有主见，要想当“将军”，这样他才能带好手下的兵。一个优秀的团队，需要好的规范，无规矩不成方圆，有了规矩，大家都按照规矩来做事，能减少很多不必要的麻烦，不会让成员觉得无所适从。 开发流程需要的工具：文档管理工具团队的产品、设计、技术文档进行整理归档，随着版本不停的迭代，团队成员进进出出若干，如果没有这些文档，会需要很多时间跟新同事交代哪里哪里是干嘛的，哪里哪里需要注意什么。有了这些文档，一方面方便新来的同事，一方面也是对现有技术的沉淀。 文档分为： 公共文档：用来存放团队所有成员都应知晓的事情，比如团队的开发流程，各个岗位的指责，一些规范注意事项等； 产品文档：用来存放产品的版本迭代详细文案，使用说明等； 设计文档：用来存放PS源文件，sketch源文件，sketch导出的html文件，设计规范等； 技术接口文档：存放不同端的API Docs，方便其他端同事查阅，特别是后端接口文档，非常必要； 技术博客，技术上的沉淀能反映出一家公司的技术底蕴； 各种release包的存放，方便以后使用，有时候需要找到很老的版本找不到的时候会很痛苦的。 如何进行管理：目前的做法是将文档统一存放到服务器上，服务器通过配置Nginx指向不同的文件夹，配置不同的域名分别表示各种类型的文档。 项目管理工具 项目整个周期的时间规划； 任务的分派，所有人都应该把自己的任务规划好计划开始、结束时间，实际开始、结束时间； 项目需要一个人来跟踪进度，每天汇总、统计，同步给项目相关的所有人，发现问题及时调整；（这样做的目的是让大家彼此知道大家的进展，督促自己按时完成自己的任务，管理人员也好根据实际情况调配） 自动构建、持续集成工具Jenkins自动构建，比起本地构建，不依赖个人机器的环境，相应有权限的人都可以进行构建。 Bug统计、管理工具友盟等第三方统计 持续部署工具Docker Kubernetes 技术管理OKRs制定目标，目标拆分，制定关键节点，核对结果。 Review Code代码Review，提升代码质量 Unit Test单元测试，减少bug数 技术分享技术沉淀 一些感悟金无足赤、人无完人，想要团队内所有的人都积极主动，把工作当成自己生命中很重要的东西是很困难的。所以才需要管理，需要规则。让大家努力工作的几个核心： 赏罚分明。且要加大力度，如果做的很好，才奖励几百块，出了事故就批评一下；会让大家变的不在乎。所以一定要加大赏罚力度。让大家感觉有奔头，比如如果能完成全年KPI，奖金就能超过基本工资，那大家一定会想尽办法来完成它。如果出现严重的bug，会严厉批评，扣奖金；更严重的会让你直接走人。那么大家就会重视自己的每一行代码了。 比较强势的团队文化。一个好的团队，是需要狼性的，为了目标就应该全力以赴。而不是拖拖拉拉。当然，适当的调整也是有必要的，如果一直在强压力工作下，人也会受不了的。这是相辅相成的。 关于需求变动在日常开发中，需求的变动是很正常的。但因此带来的影响则需要好好分析，而不是一味的来了需求就安排。正常情况下，每个周期的需求定好之后，团队中所有人的工作安排应该都是100%满负荷的。如果在开发过程中，有需求要修改或者新增，则要么版本的周期进行调整，要么大家加班加点把它做完。在这里，我会先评估改动对整个周期造成的影响，如果影响并不大，则会安排人员在周期内进行消化；如果消化不了，也是不建议修改版本周期的。如果因为个别的改动，造成大部分人的影响是不值得的。比如，开发团队30人，新增的需求需要3个人开发3天，如果将周期延后3天，则其他27人是要重新安排工作的。如果经常出现需求变动的时候，就应该思考需求提出者是不是没有把本职工作做好。 按职能还是按业务来分配子团队不同人数的团队 如何进行良好的沟通所有事情有开始有结束。当你把一件事情交代给某一个人时，首先要描述清楚自己想要的结果，然后让对方明确是否明白，再确认最后完成时间。作为收到任务的一方，也应该把自己的理解表达清楚，双方达成一致；最好能在deadline之前就找需求方告知结果，而不是踩着时间线甚至延期告知。 如何带新人对于刚进来的同事，应该准备一份详细的注意事项。比如我们的开发流程是怎样的；有那些账号需要申请，申请流程；常用的工具，工具的使用文档、下载地址；还有许多平常开发中常见的问题。有这样一份文档，新人也不需要一遇到问题就来找你，也节省了你的时间。","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术开发/技术管理","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://shjlone.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"多线程","slug":"操作系统/线程/多线程","date":"2021-06-07T01:45:07.561Z","updated":"2021-07-07T08:32:43.953Z","comments":true,"path":"wiki/操作系统/线程/多线程/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"线程的概念引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。 线程的状态 新建状态: 线程对象已经创建，还没有在其上调用start()方法。 可运行状态: 当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。 运行状态: 就绪状态的线程获取了CPU，执行程序代码。 阻塞状态: 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入可运行状态，才有机会转到运行状态。 阻塞的情况分三种： 等待阻塞:运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒. (注意:当调用wait()后，线程会释放掉它所占有的&#39;锁&#39;，所以线程只有在持有&#39;锁&#39;才能进入可运行状态.) 同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。 其他阻塞:运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态: 线程执行完了或者因异常退出了run()时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 线程的实现方式线程间通讯参考","raw":null,"content":null,"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"线程","slug":"操作系统/线程","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://shjlone.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"PC客户端技术方案分析","slug":"技术开发/杂项/PC客户端技术方案分析","date":"2021-06-07T01:45:07.560Z","updated":"2021-06-07T01:45:07.560Z","comments":true,"path":"wiki/技术开发/杂项/PC客户端技术方案分析/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/PC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/","excerpt":"","text":"不同PC客户端技术方案的比较Qt官网：https://www.qt.io/ Qt具有跨平台的特性，可选择QWidget、QQuick。整个包比较大。虽然可以根据实际情况去掉一部分动态库和文件，还是比较大。 CEF（Chromium Embedded Framework）官网：https://bitbucket.org/chromiumembedded/cef/src/master/ 是一个基于Google Chromium 的开源项目。Google Chromium项目主要是为Google Chrome应用开发的，而CEF的目标则是为第三方应用提供可嵌入浏览器支持。CEF隔离底层Chromium和Blink的复杂代码，并提供一套产品级稳定的API，发布跟踪具体Chromium版本的分支，以及二进制包。通过封装接口, 然后由chromium回调到自己的程序, 驱动整个程序运行。 个人认为选择CEF的主要原因有以下几点： 基于JS、Html这一套Web技术，开发速度快； 能做出高性能的动画效果 Electron官网：http://www.electronjs.org/ 使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。Electron是在chromium的基础之上, 再嵌入一了个js执行的v8引擎, 由此v8引擎与chromium内部的v8进行信号的交互, 驱动程序运行。 duilib官网：https://github.com/duilib/duilib 开源，小巧灵活，容易扩展，界面与业务逻辑分离。国内有许多大厂都在用这个库，不过应该都进行过深入的定制，官方版本的更新并不频繁，文档跟其他几个比起来差距较大。 教程： https://blog.oo87.com/cpp/6868.html WPF（Windows Presentation Foundation）微软推出的基于Windows Vista的用户界面框架，属于.NET Framework 3.0的一部分。基于Direct3D创建，使用GPU，拥有更好的性能。 UMP（Universal Windows Platform）官方介绍：https://docs.microsoft.com/zh-cn/windows/uwp/get-started/universal-application-platform-guide 在 Windows 10 中，微软首次引入了 UWP（通用 Windows 平台）的概念，让开发者只需一次编写，就能让程序在电脑和手机等多种设备上运行。 PyQt下载地址： https://pypi.org/project/PyQt5/ 基于Qt的Python封装，由于Python的简易特性，开发效率极高。 不同软件的技术实现方案： yy：Qt+CEF 钉钉：CEF+Qt5+duilib 斗鱼：Qt+声网SDK+CrashRpt 虎牙：.Net+Qt4 刀锋电竞：Electron 微信PC端：duilib 网易CC：Qt4+PyQt4+ActionScript(Flex) 参考 https://www.dazhuanlan.com/2019/09/29/5d8f936a633a2/?cf_chl_jschl_tk=ef7184070e28df4b7ee98496aa8b8ff50c47dcd7-1602323919-0-ASFIF35e3NpZNuU7Ndt3pR36r7hlqGch5EsER64Huxe0jFolt_H3NQYXXDmvjWl_m8WVlRnkeLLk1CpX-mLzObrx_mpJIWdumnG8N-g4L7RCf1XxZyM3Ucv6EPDJhAfJSexUlyeoz-AzeC4nE10bcWsW6MyJjhJRQfvo2ABHsoKcu0RLGe4_PIkvL8ox7CchII1vJKWNus0JBvjUiLa0TWyWOGE2WLCwUAwYSEIRE5vqTnW4bMP0C5MTZnjw6sk7Je9gHmAM79oqXilMJdJrVonFl3oItVG8fPn-iwqZbFdBK3iqj7xjlstE8HSgJ7ZEdQ","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"PC","slug":"PC","permalink":"http://shjlone.github.io/tags/PC/"}]},{"title":"ReactiveX","slug":"技术开发/杂项/ReactiveX","date":"2021-06-07T01:45:07.560Z","updated":"2021-06-07T01:45:07.560Z","comments":true,"path":"wiki/技术开发/杂项/ReactiveX/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/ReactiveX/","excerpt":"","text":"Observables概述ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持大部分主流语言。 使用这种方法的优点是，当你有一大堆的任务是不相互依赖，你就可以同时执行他们，而不是等待每一个类启动下一个前完成，这样你的整个任务包只需要花最长的任务时间。 在ReactiveX中，一个观察者(Observer)订阅一个可观察对象(Observable)。观察者对Observable发射的数据或数据序列作出响应。这种模式可以极大地简化并发操作，因为它创建了一个处于待命状态的观察者哨兵，在未来某个时刻响应Observable的通知，不需要阻塞等待Observable发射数据。 背景知识在很多软件编程任务中，或多或少你都会期望你写的代码能按照编写的顺序，一次一个的顺序执行和完成。但是在ReactiveX中，很多指令可能是并行执行的，之后他们的执行结果才会被观察者捕获，顺序是不确定的。为达到这个目的，你定义一种获取和变换数据的机制，而不是调用一个方法。在这种机制下，存在一个可观察对象(Observable)，观察者(Observer)订阅(Subscribe)它，当数据就绪时，之前定义的机制就会分发数据给一直处于等待状态的观察者哨兵。 这种方法的优点是，如果你有大量的任务要处理，它们互相之间没有依赖关系。你可以同时开始执行它们，不用等待一个完成再开始下一个（用这种方式，你的整个任务队列能耗费的最长时间，不会超过任务里最耗时的那个）。 有很多术语可用于描述这种异步编程和设计模式，在在本文里我们使用这些术语：一个观察者订阅一个可观察对象 (An observer subscribes to an Observable)。通过调用观察者的方法，Observable发射数据或通知给它的观察者。 在其它的文档和场景里，有时我们也将Observer叫做Subscriber、Watcher、Reactor。这个模型通常被称作Reactor模式。 创建观察者关于Observers的创建 同步方式： 调用一个方法 用一个变量存储方法返回值 使用这个变量作为一个新的值做其他事情 例如： 123//写一个回调returnVal = someMethod(paramters);//做新的事情 异步方式： 定义一个方法，此方法是做一些事情并带有来之于异步调用的返回值；这个方法也是observer的一部分 定义异步调用自身作为一个Observable 通过订阅的方式连接observer到Observable 执行你的业务 123def myOnNext = &#123;it-&gt;do something useful with it&#125;;def myObservable = someOvservable(itsParamters);myObservable.subscribe(myOnNext); onNext，onCompleted，onError回调 onNext：每当Observable广播数据时将会调用该方法，这个方法将会被作为Observable的一个广播项目参数被发送 onError：表示内部已经发生异常 onCompleted：成功调用onNext 123456def myOnNext = &#123; item -&gt; /* 任务执行 */ &#125;;def myError = &#123; throwable -&gt; /* 失败时的响应 */ &#125;;def myComplete = &#123; /* 成功后的响应 */ &#125;;def myObservable = someMethod(itsParameters);myObservable.subscribe(myOnNext, myError, myComplete);// 继续执行相应的业务逻辑 取消订阅（Ubsubscribing）在一些ReactiveX实现中，有一个特殊的观察者接口Subscriber，它有一个unsubscribe方法。调用这个方法表示你不关心当前订阅的Observable了，因此Observable可以选择停止发射新的数据项（如果没有其它观察者订阅）。 取消订阅的结果会传递给这个Observable的操作符链，而且会导致这个链条上的每个环节都停止发射数据项。这些并不保证会立即发生，然而，对一个Observable来说，即使没有观察者了，它也可以在一个while循环中继续生成并尝试发射数据项。 关于命名约定ReactiveX的每种特定语言的实现都有自己的命名偏好，虽然不同的实现之间有很多共同点，但并不存在一个统一的命名标准。 而且，在某些场景中，一些名字有不同的隐含意义，或者在某些语言看来比较怪异。 例如，有一个onEvent命名模式(onNext, onCompleted, onError)，在一些场景中，这些名字可能意味着事件处理器已经注册。然而在ReactiveX里，他们是事件处理器的名字。 Observables的”热”和”冷”Observable什么时候开始发射数据序列？这取决于Observable的实现，一个”热”的Observable可能一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。 在一些ReactiveX实现里，还存在一种被称作Connectable的Observable，不管有没有观察者订阅它，这种Observable都不会开始发射数据，除非Connect方法被调用。 用操作符组合Ovservable创建新的Observables的操作符： Create Defer Empty/Never/Throw From Interval Just Range Repeat Start Timer 转换被一个Observable发送的项目的操作付 Buffer FlatMap GroupBy Map Scan Window 过滤被Observable发送的项目的操作符 Debounce Distinct ElementAt Filter First IgnoreElements Last Sample Skip SkipLast Take TakeLast 将多个Observable合并成单个Observable的操作符 And/Then/When CombineLatest Join Merge StartWith Switch Zip 错误处理操作符 Catch Retry 实用工具操作符 Delay Do Materialize/Dematerialize ObserveOn Serialize Subscribe SubscribeOn TimeInterval Timeout Timestamp Using 条件和布尔运算操作符 All Amb Contains DefaultIfEmpty SequenceEqual SkipUntil SkipWhile TakeUntil TakeWhile 算术和集合操作符 Average Concat Count Max Min Reduce Sum 转换操作符 To 可连接Obervable的操作符 Connect Publish RefCount Replay SingleRxJava（以及它派生出来的RxGroovy和RxScala）中有一个名为Single的Observable变种。 Single类似于Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值。 因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两个方法： onSuccess - Single发射单个的值到这个方法 onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法 Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关系终止。 Single操作符 操作符 返回值 说明 compose Single 创建一个自定义的操作符 concat and concatWith Observable 连接多个Single和Observable发射的数据 create Single 调用观察者的create方法创建一个Single error Single 返回一个立即给订阅者发射错误通知的Single flatMap Single 返回一个Single，它发射对原Single的数据执行flatMap操作后的结果 flatMapObservable Observable 返回一个Observable，它发射对原Single的数据执行flatMap操作后的结果 from Single 将Future转换成Single just Single 返回一个发射一个指定值的Single map Single 返回一个Single，它发射对原Single的数据执行map操作后的结果 merge Single 将一个Single(它发射的数据是另一个Single，假设为B)转换成另一个Single(它发射来自另一个Single(B)的数据) merge and mergeWith Observable 合并发射来自多个Single的数据 observeOn Single 指示Single在指定的调度程序上调用订阅者的方法 onErrorReturn Single 将一个发射错误通知的Single转换成一个发射指定数据项的Single subscribeOn Single 指示Single在指定的调度程序上执行操作 timeout Single 它给原有的Single添加超时控制，如果超时了就发射一个错误通知 toSingle Single 将一个发射单个值的Observable转换为一个Single zip and zipWith Single 将多个Single转换为一个，后者发射的数据是对前者应用一个函数后的结果 SubjectSubject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。 由于一个Subject订阅一个Observable，它可以触发这个Observable开始发射数据（如果那个Observable是”冷”的–就是说，它等待有订阅才开始发射数据）。因此有这样的效果，Subject可以把原来那个”冷”的Observable变成”热”的。 Subject种类AsyncSubjectBehaviorSubjectPublishSubjectReplaySubjectScheduler如果你想给Observable操作符链添加多线程功能，你可以指定操作符（或者特定的Observable）在特定的调度器(Scheduler)上执行。 某些ReactiveX的Observable操作符有一些变体，它们可以接受一个Scheduler参数。这个参数指定操作符将它们的部分或全部任务放在一个特定的调度器上执行。 默认情况下，可观察对象和观察者的订阅方法是在同一个线程中运行的。使用ObserveOn和SubscribeOn操作符，你可以让Observable在一个特定的调度器上执行，ObserveOn指示一个Observable在一个特定的调度器上调用观察者的onNext, onError和onCompleted方法，SubscribeOn更进一步，它指示Observable将全部的处理过程（包括发射数据和通知）放在特定的调度器上执行。 RxJava示例调度器的种类下表展示了RxJava中可用的调度器种类： 调度器类型 效果 Schedulers.computation( ) 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量 Schedulers.from(executor) 使用指定的Executor作为调度器 Schedulers.immediate( ) 在当前线程立即开始执行任务 Schedulers.io( ) 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器 Schedulers.newThread( ) 为每个任务创建一个新线程 Schedulers.trampoline( ) 当其它排队的任务完成后，在当前线程排队开始执行 默认调度器在RxJava中，某些Observable操作符的变体允许你设置用于操作执行的调度器，其它的则不在任何特定的调度器上执行，或者在一个指定的默认调度器上执行。下面的表格个列出了一些操作符的默认调度器： 操作符 调度器 buffer(timespan) computation buffer(timespan, count) computation buffer(timespan, timeshift) computation debounce(timeout, unit) computation delay(delay, unit) computation delaySubscription(delay, unit) computation interval computation repeat trampoline replay(time, unit) computation replay(buffersize, time, unit) computation replay(selector, time, unit) computation replay(selector, buffersize, time, unit) computation retry trampoline sample(period, unit) computation skip(time, unit) computation skipLast(time, unit) computation take(time, unit) computation takeLast(time, unit) computation takeLast(count, time, unit) computation takeLastBuffer(time, unit) computation takeLastBuffer(count, time, unit) computation throttleFirst computation throttleLast computation throttleWithTimeout computation timeInterval immediate timeout(timeoutSelector) immediate timeout(firstTimeoutSelector, timeoutSelector) immediate timeout(timeoutSelector, other) immediate timeout(timeout, timeUnit) computation timeout(firstTimeoutSelector, timeoutSelector, other) immediate timeout(timeout, timeUnit, other) computation timer computation timestamp immediate window(timespan) computation window(timespan, count) computation window(timespan, timeshift) computation 使用调度器除了将这些调度器传递给RxJava的Observable操作符，你也可以用它们调度你自己的任务。下面的示例展示了Scheduler.Worker的用法： 1234567891011worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); &#125;&#125;);// some time later...worker.unsubscribe(); 递归调度器要调度递归的方法调用，你可以使用schedule，然后再用schedule(this)，示例： 12345678910111213worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); // recurse until unsubscribed (schedule will do nothing if unsubscribed) worker.schedule(this); &#125;&#125;);// some time later...worker.unsubscribe(); 检查或设置取消订阅状态Worker类的对象实现了Subscription接口，使用它的isUnsubscribed和unsubscribe方法，所以你可以在订阅取消时停止任务，或者从正在调度的任务内部取消订阅，示例： 123456789101112Worker worker = Schedulers.newThread().createWorker();Subscription mySubscription = worker.schedule(new Action0() &#123; @Override public void call() &#123; while(!worker.isUnsubscribed()) &#123; status = yourWork(); if(QUIT == status) &#123; worker.unsubscribe(); &#125; &#125; &#125;&#125;); 延时和周期调度器你可以使用schedule(action,delayTime,timeUnit)在指定的调度器上延时执行你的任务，下面例子中的任务将在500毫秒之后开始执行： 1someScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS); 使用另一个版本的schedule，schedulePeriodically(action,initialDelay,period,timeUnit)方法让你可以安排一个定期执行的任务，下面例子的任务将在500毫秒之后执行，然后每250毫秒执行一次： 1someScheduler.schedulePeriodically(someAction, 500, 250, TimeUnit.MILLISECONDS); 测试调度器TestScheduler让你可以对调度器的时钟表现进行手动微调。这对依赖精确时间安排的任务的测试很有用处。这个调度器有三个额外的方法： advanceTimeTo(time,unit) 向前波动调度器的时钟到一个指定的时间点 advanceTimeBy(time,unit) 将调度器的时钟向前拨动一个指定的时间段 triggerActions( ) 开始执行任何计划中的但是未启动的任务，如果它们的计划时间等于或者早于调度器时钟的当前时间 Operators创建操作 just( ) — 将一个或多个对象转换成发射这个或这些对象的一个Observable from( ) — 将一个Iterable, 一个Future, 或者一个数组转换成一个Observable repeat( ) — 创建一个重复发射指定数据或数据序列的Observable repeatWhen( ) — 创建一个重复发射指定数据或数据序列的Observable，它依赖于另一个Observable发射的数据 create( ) — 使用一个函数从头创建一个Observable defer( ) — 只有当订阅者订阅才创建Observable；为每个订阅创建一个新的Observable range( ) — 创建一个发射指定范围的整数序列的Observable interval( ) — 创建一个按照给定的时间间隔发射整数序列的Observable timer( ) — 创建一个在给定的延时之后发射单个数据的Observable empty( ) — 创建一个什么都不做直接通知完成的Observable error( ) — 创建一个什么都不做直接通知错误的Observable never( ) — 创建一个不发射任何数据的Observable 变换操作 map( ) — 对序列的每一项都应用一个函数来变换Observable发射的数据序列 flatMap( ), concatMap( ), and flatMapIterable( ) — 将Observable发射的数据集合变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable switchMap( ) — 将Observable发射的数据集合变换为Observables集合，然后只发射这些Observables最近发射的数据 scan( ) — 对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值 groupBy( ) — 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据 buffer( ) — 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个 window( ) — 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项 cast( ) — 在发射之前强制将Observable发射的所有数据转换为指定类型 过滤操作 filter( ) — 过滤数据 takeLast( ) — 只发射最后的N项数据 last( ) — 只发射最后的一项数据 lastOrDefault( ) — 只发射最后的一项数据，如果Observable为空就发射默认值 takeLastBuffer( ) — 将最后的N项数据当做单个数据发射 skip( ) — 跳过开始的N项数据 skipLast( ) — 跳过最后的N项数据 take( ) — 只发射开始的N项数据 first( ) and takeFirst( ) — 只发射第一项数据，或者满足某种条件的第一项数据 firstOrDefault( ) — 只发射第一项数据，如果Observable为空就发射默认值 elementAt( ) — 发射第N项数据 elementAtOrDefault( ) — 发射第N项数据，如果Observable数据少于N项就发射默认值 sample( ) or throttleLast( ) — 定期发射Observable最近的数据 throttleFirst( ) — 定期发射Observable发射的第一项数据 throttleWithTimeout( ) or debounce( ) — 只有当Observable在指定的时间后还没有发射数据时，才发射一个数据 timeout( ) — 如果在一个指定的时间段后还没发射数据，就发射一个异常 distinct( ) — 过滤掉重复数据 distinctUntilChanged( ) — 过滤掉连续重复的数据 ofType( ) — 只发射指定类型的数据 ignoreElements( ) — 丢弃所有的正常数据，只发射错误或完成通知 结合操作 startWith( ) — 在数据序列的开头增加一项数据 merge( ) — 将多个Observable合并为一个 mergeDelayError( ) — 合并多个Observables，让没有错误的Observable都完成后再发射错误通知 zip( ) — 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果 and( ), then( ), and when( ) — (rxjava-joins) 通过模式和计划组合多个Observables发射的数据集合 combineLatest( ) — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果 join( ) and groupJoin( ) — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射 switchOnNext( ) — 将一个发射Observables的Observable转换成另一个Observable，后者发射这些Observables最近发射的数据 错误操作很多操作符可用于对Observable发射的onError通知做出响应或者从错误中恢复，例如，你可以： 吞掉这个错误，切换到一个备用的Observable继续发射数据 吞掉这个错误然后发射默认值 吞掉这个错误并立即尝试重启这个Observable 吞掉这个错误，在一些回退间隔后重启这个Observable 这是操作符列表： onErrorResumeNext( ) — 指示Observable在遇到错误时发射一个数据序列 onErrorReturn( ) — 指示Observable在遇到错误时发射一个特定的数据 onExceptionResumeNext( ) — instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)指示Observable遇到错误时继续发射数据 retry( ) — 指示Observable遇到错误时重试 retryWhen( ) — 指示Observable遇到错误时，将错误传递给另一个Observable来决定是否要重新给订阅这个Observable 辅助操作 materialize( ) — 将Observable转换成一个通知列表convert an Observable into a list of Notifications dematerialize( ) — 将上面的结果逆转回一个Observable timestamp( ) — 给Observable发射的每个数据项添加一个时间戳 serialize( ) — 强制Observable按次序发射数据并且要求功能是完好的 cache( ) — 记住Observable发射的数据序列并发射相同的数据序列给后续的订阅者 observeOn( ) — 指定观察者观察Observable的调度器 subscribeOn( ) — 指定Observable执行任务的调度器 doOnEach( ) — 注册一个动作，对Observable发射的每个数据项使用 doOnCompleted( ) — 注册一个动作，对正常完成的Observable使用 doOnError( ) — 注册一个动作，对发生错误的Observable使用 doOnTerminate( ) — 注册一个动作，对完成的Observable使用，无论是否发生错误 doOnSubscribe( ) — 注册一个动作，在观察者订阅时使用 doOnUnsubscribe( ) — 注册一个动作，在观察者取消订阅时使用 finallyDo( ) — 注册一个动作，在Observable完成时使用 delay( ) — 延时发射Observable的结果 delaySubscription( ) — 延时处理订阅请求 timeInterval( ) — 定期发射数据 using( ) — 创建一个只在Observable生命周期存在的资源 single( ) — 强制返回单个数据，否则抛出异常 singleOrDefault( ) — 如果Observable完成时返回了单个数据，就返回它，否则返回默认数据 toFuture( ), toIterable( ), toList( ) — 将Observable转换为其它对象或数据结构 条件和布尔操作条件操作符 amb( ) — 给定多个Observable，只让第一个发射数据的Observable发射全部数据 defaultIfEmpty( ) — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据 (rxjava-computation-expressions) doWhile( ) — 发射原始Observable的数据序列，然后重复发射这个序列直到不满足这个条件为止 (rxjava-computation-expressions) ifThen( ) — 只有当某个条件为真时才发射原始Observable的数据序列，否则发射一个空的或默认的序列 skipUntil( ) — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据 skipWhile( ) — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据 (rxjava-computation-expressions) switchCase( ) — 基于一个计算结果，发射一个指定Observable的数据序列 takeUntil( ) — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知 takeWhile( ) and takeWhileWithIndex( ) — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据 布尔操作符 all( ) — 判断是否所有的数据项都满足某个条件 contains( ) — 判断Observable是否会发射一个指定的值 exists( ) and isEmpty( ) — 判断Observable是否发射了一个值 sequenceEqual( ) — 判断两个Observables发射的序列是否相等 算数和聚合操作rxjava-math 模块的操作符 averageInteger( ) — 求序列平均数并发射 averageLong( ) — 求序列平均数并发射 averageFloat( ) — 求序列平均数并发射 averageDouble( ) — 求序列平均数并发射 max( ) — 求序列最大值并发射 maxBy( ) — 求最大key对应的值并发射 min( ) — 求最小值并发射 minBy( ) — 求最小Key对应的值并发射 sumInteger( ) — 求和并发射 sumLong( ) — 求和并发射 sumFloat( ) — 求和并发射 sumDouble( ) — 求和并发射 其它聚合操作符 concat( ) — 顺序连接多个Observables count( ) and countLong( ) — 计算数据项的个数并发射结果 reduce( ) — 对序列使用reduce()函数并发射最终的结果 collect( ) — 将原始Observable发射的数据放到一个单一的可变的数据结构中，然后返回一个发射这个数据结构的Observable toList( ) — 收集原始Observable发射的所有数据到一个列表，然后返回这个列表 toSortedList( ) — 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表 toMap( ) — 将序列数据转换为一个Map，Map的key是根据一个函数计算的 toMultiMap( ) — 将序列数据转换为一个列表，同时也是一个Map，Map的key是根据一个函数计算的 异步操作下面的这些操作符属于单独的rxjava-async模块，它们用于将同步对象转换为Observable。 start( ) — 创建一个Observable，它发射一个函数的返回值 toAsync( ) or asyncAction( ) or asyncFunc( ) — 将一个函数或者Action转换为已Observable，它执行这个函数并发射函数的返回值 startFuture( ) — 将一个返回Future的函数转换为一个Observable，它发射Future的返回值 deferFuture( ) — 将一个返回Observable的Future转换为一个Observable，但是并不尝试获取这个Future返回的Observable，直到有订阅者订阅它 forEachFuture( ) — 传递Subscriber方法给一个Subscriber，但是同时表现得像一个Future一样阻塞直到它完成 fromAction( ) — 将一个Action转换为Observable，当一个订阅者订阅时，它执行这个action并发射它的返回值 fromCallable( ) — 将一个Callable转换为Observable，当一个订阅者订阅时，它执行这个Callable并发射Callable的返回值，或者发射异常 fromRunnable( ) — convert a Runnable into an Observable that invokes the runable and emits its result when a Subscriber subscribes将一个Runnable转换为Observable，当一个订阅者订阅时，它执行这个Runnable并发射Runnable的返回值 runAsync( ) — 返回一个StoppableObservable，它发射某个Scheduler上指定的Action生成的多个actions 连接操作 ConnectableObservable.connect( ) — 指示一个可连接的Observable开始发射数据 Observable.publish( ) — 将一个Observable转换为一个可连接的Observable Observable.replay( ) — 确保所有的订阅者看到相同的数据序列，即使它们在Observable开始发射数据之后才订阅 ConnectableObservable.refCount( ) — 让一个可连接的Observable表现得像一个普通的Observable 转换操作阻塞操作要将普通的Observable 转换为 BlockingObservable，可以使用 Observable.toBlocking( )) 方法或者BlockingObservable.from( )) 方法。 forEach( ) — 对Observable发射的每一项数据调用一个方法，会阻塞直到Observable完成 first( ) — 阻塞直到Observable发射了一个数据，然后返回第一项数据 firstOrDefault( ) — 阻塞直到Observable发射了一个数据或者终止，返回第一项数据，或者返回默认值 last( ) — 阻塞直到Observable终止，然后返回最后一项数据 lastOrDefault( ) — 阻塞直到Observable终止，然后返回最后一项的数据，或者返回默认值 mostRecent( ) — 返回一个总是返回Observable最近发射的数据的iterable next( ) — 返回一个Iterable，会阻塞直到Observable发射了另一个值，然后返回那个值 latest( ) — 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值 single( ) — 如果Observable终止时只发射了一个值，返回那个值，否则抛出异常 singleOrDefault( ) — 如果Observable终止时只发射了一个值，返回那个值，否则否好默认值 toFuture( ) — 将Observable转换为一个Future toIterable( ) — 将一个发射数据序列的Observable转换为一个Iterable getIterator( ) — 将一个发射数据序列的Observable转换为一个Iterator 字符串操作 byLine( ) — 将一个字符串的Observable转换为一个行序列的Observable，这个Observable将原来的序列当做流处理，然后按换行符分割 decode( ) — 将一个多字节的字符流转换为一个Observable，它按字符边界发射字节数组 encode( ) — 对一个发射字符串的Observable执行变换操作，变换后的Observable发射一个在原始字符串中表示多字节字符边界的字节数组 from( ) — 将一个字符流或者Reader转换为一个发射字节数组或者字符串的Observable join( ) — 将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者用一个指定的字符串连接所有的字符串 split( ) — 将一个发射字符串的Observable转换为另一个发射字符串的Observable，后者使用一个指定的正则表达式边界分割前者发射的所有字符串 stringConcat( ) — 将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者连接前者发射的所有字符串 参考 reactivex.io https://github.com/ReactiveX https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Getting-Started.html","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"Rx","slug":"Rx","permalink":"http://shjlone.github.io/tags/Rx/"}]},{"title":"Redis笔记","slug":"技术开发/服务端/redis笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/服务端/redis笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/redis%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Docker笔记","slug":"技术开发/杂项/Docker笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/杂项/Docker笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"容器生态系统： 容器核心技术： 容器规范： OCI（Open Container Initiative）： runtime spec image format spec 容器runtime： lxc：Linux上老牌的容器runtime，Docker最初也是用lxc作为runtime runc：Docker自己开发的容器runtime，符合oci规范，也是现在Docker默认的runtime rkt：CoreOS开发的容器runtime 容器管理工具： lxd：lxc对应的管理工具 runc：docker engine，包含后台deamon和cli两部分。 rkt cli：rkt对应的管理工具 容器定义工具：允许用户定义容器的内容和属性，这样容器就能够被保存、共享和重建 docker image：Docker容器的模板，runtime依据docker image创建容器。 dockerfile：包含若干命令的文本文件，可以通过这些命令创建出docker image。 ACI(App Container Image)：CoreOS开发的rkt容器的image格式。 Registries：存放image的仓库 Docker Registry：企业可以用Docker Registry构建私有的Registry Docker Hub：Docker为公众提供的托管Registry Quay.io 容器OS：专门运行容器的操作系统，与常规OS相比，容器OS体积更小，启动更快。 coreos atomic ubuntu core 容器平台技术： 容器编排引擎： docker swarm：Docker开发的容器编排引擎。 kubernetes：Google领导开发的，同时支持Docker和CoreOS容器。 mesos+marathon：通用的集群资源调度平台，mesos与marathon一起提供容器编排引擎。 容器管理平台：在容器编排引擎之上的一个更为通用的平台。 Rancher ContainerShip 基于容器的Paas： Deis Flynn Dokku 容器支持技术： 容器网络： docker network: none host bridge joined container overlay macvian flannel weave calico 服务发现： etcd consul zookeeper 监控： docker ps/top/stats：Docker原生命令行监控工具 docker stats API sysdig cAvisor/Heapster Weave Scope 数据管理： Rex-Ray 日志管理： docker logs logspout 安全性： OpenSCAP 特性 集装箱 Docker 打包对象 几乎任何物品 任何软件及其依赖 标准形状和接口允许集装箱被卸载到 各种交通工具，整个运输过程无需打开 容器无需修改便可运行在几乎所有的平台 隔离性 可以重叠起来一起运输 资源、网络、库都是隔离的，不会出现依赖问题 自动化 标准接口使集装箱很容易自动装卸和移动 提供run、start、stop等标准化操作 高效性 无须开箱 轻量级 职责分工 货主只需要考虑把什么放到集装箱 开发人员只需要考虑怎么写代码，运维只需关心如何配置基础环境 Docker核心组件 Docker客户端：Client Docker服务器：Docker daemon，负责创建、运行、监控容器，构建、存储镜像。 Docker镜像：Image Registry：镜像仓库 Docker容器：Container 镜像（Image）一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后不会改变。 常用镜像 1234Docker 图形管理工具docker run -d -p 9001:9000 -v &quot;/var/run/docker.sock:/var/run/docker.sock&quot; portainer/portainer 容器（Container）镜像和容器的关系，就像是面对对象程序设计中的类和实例一一样，镜像是静态的定义，容器是镜像运行的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。 基本用法12345678910拉取最小的镜像docker pull hello-world查看镜像docker image ls运行镜像docker run hello-world hello-world镜像的内容 123FROM scratch # 从0开始构建COPY hello /CMD [&quot;/hello&quot;] base镜像：提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。 不依赖其他镜像，从scratch构建； 其他镜像可以以之为基础进行扩展。 能称为base镜像的通常是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。 构建镜像：docker commit包含三个步骤： 运行容器 修改容器 将容器保存为新的镜像 Dockerfile构建镜像的步骤： 从base镜像运行一个容器 执行一条指令，对容器做修改 执行类似docker commit的操作，生成一个新的镜像层 Docker再基于刚刚提交的镜像运行一个新容器 重复2-4步，直到Dockerfile中的所有指令执行完毕。 Dockerfile实例 12FROM ubuntuRUN apt-get update &amp;&amp; apt-get install -y vim Dockerfile常用命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051指定base镜像FROM设置镜像的作者MAINTSINER从src目录复制文件到容器的dest，其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL。如果src是归档文件，文件会被自动解压到destADD &lt;src&gt;... &lt;dest&gt;设置构建时的环境变量，在容器运行时是不会存在这些变量的。ARG &lt;name&gt;[=&lt;default value&gt;]CMD指令指定容器启动运行指定的命令，* 如果docker run指定了其他命令，CMD指定的默认命令将被忽略。* 每个Dockerfile可以有多个CMD，但只有最后一个生效。CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off&quot;]复制文件COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]设置容器启动时运行的命令，可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当做参数传递给ENTRYPOINT。ENTRYPOINT设置环境变量ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...声明在运行时容器提供服务的端口EXPOSE &lt;port&gt; [&lt;port&gt;...]LABEL 为镜像添加元数据LABEL version=&quot;1.0&quot;运行指定的命令，并创建新的镜像层，经常用于安装软件包。RUN &lt;command&gt;RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]USER设置用户VOLUME指定挂载点指定工作目录WORKDIR容器暴露端口EXPOSE 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104* attach：依附到一个正在运行的容器中；* build：从一个 Dockerfile 创建一个镜像；* commit：从一个容器的修改中创建一个新的镜像；* cp：在容器和本地宿主系统之间复制文件中；* create：创建一个新容器，但并不运行它；* diff：检查一个容器内文件系统的修改，包括修改和增加；* events：从服务端获取实时的事件；* exec：在运行的容器内执行命令；* export：导出容器内容为一个 tar 包；* history：显示一个镜像的历史信息；* images：列出存在的镜像；* import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；* info：显示一些相关的系统信息；* inspect：显示一个容器的具体配置信息；* kill：关闭一个运行中的容器 (包括进程和所有相关资源)；* load：从一个 tar 包中加载一个镜像；* login：注册或登录到一个 Docker 的仓库服务器；* logout：从 Docker 的仓库服务器登出；* logs：获取容器的 log 信息；* network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；* node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；* pause：暂停一个容器中的所有进程；* port：查找一个 nat 到一个私有网口的公共口；* ps：列出主机上的容器；* pull：从一个Docker的仓库服务器下拉一个镜像或仓库；* push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；* rename：重命名一个容器；* restart：重启一个运行中的容器；* rm：删除给定的若干个容器；* rmi：删除给定的若干个镜像；* run：创建一个新容器，并在其中运行给定命令；* save：保存一个镜像为 tar 包文件；* search：在 Docker index 中搜索一个镜像；* service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；* start：启动一个容器；* stats：输出（一个或多个）容器的资源使用统计信息；* stop：终止一个运行中的容器；* swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；* tag：为一个镜像打标签；* top：查看一个容器中的正在运行的进程信息；* unpause：将一个容器内所有的进程从暂停状态中恢复；* update：更新指定的若干容器的配置信息；* version：输出 Docker 的版本信息；* volume：管理 Docker volume，包括查看、创建、删除等；* wait：阻塞直到一个容器终止，然后输出它的退出符。进入容器的方式：docker attach：直接进入容器启动命令的终端，不会启动新的进程。docker exec -it &lt;container&gt; bash|shdocker run参数：-d：后台运行-P：随机端口映射-p：指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort-network:指定网络模式，有以下可选参数： -network=brigde 默认选项，表示连接默认的网桥。 -network=host 容器使用宿主主机的网络 -network=container:NAME_or_ID 告诉DOcker让新建的容器使用以有容器的网络配置 -network=none 不配置该容器的网络，用户可自定义网络配置查看运行的容器docker ps停止容器docker stop强制停止容器docker kill进入容器docker attach进入启动的容器交互界面docker exec -it container-id bash删除容器docker rm导出容器docker export red_panda &gt; lastest.tar导入容器docker import nignx2.tar nginxdocker rm $(docker ps -q -f status=exited)docker rmi $(docker images -q -f dangling=true)进入正在运行的容器，39表示容器id前面几位docker exec -it 39 /bin/bash","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"Git使用笔记","slug":"技术开发/杂项/Git使用笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-07-07T03:59:14.378Z","comments":true,"path":"wiki/技术开发/杂项/Git使用笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374git init # 输出 Initialized empty Git repository in .git/ 建立空仓库git add . #添加到仓库 把所有修改提交到暂存区(Stage)git commit -m &quot;提交注释&quot; #提交到仓库 把暂存区的所有修改提交到分支git push remote_branch local_branch #将本地库提交到远程库git status #查看修改状态git log #显示从最近到最远的提交日志git log -2： #查看最近几条记录git clone git@github.com:xxx/gitskills.git #克隆仓库#checkout 检查工作目录代码与本地仓库中的代码的差异git checkout -b dev #创建并切换分支，相当于下面的两句 git branch experimental #创建分支 git checkout experimental #切换到分支git fetch -u origin master #拉取远程仓库名为origin的master分支代码到本地仓库，并不修改本地工作目录的代码，如果要修改，则进行git merge变更合并#merge 将远程仓库的变更，更新到本地工作目录中git merge 分支名 #合并分支到当前分支上#git pull相当于git fetch + git merge#remote 用于管理远程仓库git remote -v #查看现有的远程仓库#添加一个远程仓库git remote add &lt;仓库名字&gt; &lt;仓库的URL&gt;git remote add pb git://github.com/paulboone/ticgit.git #添加一个远程仓库 并用pb命名。git remote rm paul #删除远程仓库git remote rename pb paul #重名远程仓库 本地也会跟着修改#git push -u &lt;远程仓库名字&gt; &lt;远程仓库的某一分支名字&gt;git push -u test mater #将本地仓库的变更推送远程仓库的master分支git push origin 标签名 推送标签到远程仓库git push origin --tags #推送所有标签到远程仓库git push origin :refs/tags/标签名 #从远程仓库中删除标签git push origin --delete &lt;branchname&gt; #删除远程分支git push origin :&lt;branchName&gt; #删除远程分支#暂存操作：git stash 暂存当前修改git stash apply 恢复最近的一次暂存git stash pop 恢复暂存并删除暂存记录git stash list 查看暂存列表git stash drop 暂存名(例：stash@&#123;0&#125;) 移除某次暂存git stash clear 清除暂存#回退操作：#Git服务有一个叫HEAD的版本指针，当用户申请还原数据时，其实就是将HEAD指针指向到某个特定的提交版本。git reset --hard HEAD^ #回退到上一个版本git reset --hard ahdhs1(commit_id) #回退到某个版本git checkout -- file #撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)git reset HEAD file #撤回暂存区的文件修改到工作区#标签操作：#tag的作用是方便用户回滚操作，只需要记住tag的名字就能迅速回滚git tag #列出所有标签列表，可以按照标签进行checkoutgit tag 标签名 #添加标签(默认对当前版本)git tag 标签名 commit_id #对某一提交记录打标签git tag -a 标签名 -m &#x27;描述&#x27; #创建新标签并增加备注git show 标签名 #查看标签信息git tag -d 标签名 #删除本地标签#git rm提交删除文件的变更到暂存区git diff test.txt 本地工作目录中到文件与本地仓库中的文件对比 Git分支管理master分支一般用于发布新版本，dev分支用于开发，每个人从dev分支创建自己的个人分支，开发完合并到dev分支，最后合并到master分支。 123456789101112git branch 查看所有已存在的分支git branch -a 查看远程分支git branch -v 查看所有分支的最后一次操作git branch -vv 查看当前分支git brabch -b 分支名 origin/分支名 //创建远程分支到本地git branch --merged //查看别的分支和当前分支合并过的分支git branch --no-merged //查看未与当前分支合并的分支git branch -d xxx 删除本地分支git branch -D crazy-idea 强制删除分支git merge 功能1 #合并功能1分支到当前分支git branch -d 功能1 # 删除功能1分支（当前不能在功能1分支、删除的是本地分支） gitignore文件用来存储不需要进行版本管理的文件 文件匹配规则12345*.log # 表示忽略项目中所有以.log结尾的文件123?.log # 忽略所有以123加任意一个字符，且以.log结尾的文件/error.log # 忽略根目录下的error.log文件**/java/ # 忽略所有java目录下的所有文件!/error.log # 表示在前面的匹配规则中，被忽略了的文件，你不想它被忽略，那么就可以在文件前面加叹号 拉取体积很大的仓库12345git clone --depth 1 仓库地址git branch -agit remote set-branches origin &#x27;远程分支名称’git fetch --depth 1 origin 远程分支名称git checkout ‘远程分支名称’ 仓库之间的迁移整个仓库迁移123git clone --bare 旧仓库地址git push --mirror 新仓库地址 迁移一个分支12git remote add 本地分支 新仓库地址 //关联远程分支git push 远程分支 本地分支 //提交分支","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://shjlone.github.io/tags/Git/"}]},{"title":"Linux常用操作","slug":"技术开发/杂项/Linux常用操作","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/杂项/Linux常用操作/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"添加用户并赋予权限#添加用户 adduser -m xxx vim /etc/sudoers 添加：%sudo ALL=(ALL:ALL) ALL 将用户添加到sudo组 gpasswd -a xxx sudo ssh操作配置 ssh -p 端口号 用户名@ip地址 ssh -p 22 root@192.168.1.1 #设置私钥的权限 chmod 666 id_rsa","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://shjlone.github.io/tags/linux/"}]},{"title":"Mac软件安装笔记","slug":"技术开发/杂项/Mac软件安装笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/杂项/Mac软件安装笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Mac%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/","excerpt":"","text":"brew命令1234567brew services list 查看服务状态brew services run mysql # 启动mysql 服务brew services start mysql # 启动 mysql 服务，并注册开机自启brew services stop mysql # 停止 mysql 服务，并取消开机自启brew services restart mysql # 重启 mysql 服务，并注册开机自启brew services cleanup # 清除已卸载应用的无用配置 mysql123456789101112131415161718brew install mysqlbrew services start mysqlbrew services stop mysqlmysql -urootSHOW VARIABLES LIKE &#x27;validate_password%&#x27;; //查看密码初始策略SET GLOBAL validate_password.policy=LOW; //设置某个属性SET GLOBAL validate_password.length=6; //修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;yourpasswd&#x27;;flush privileges;describe user; //查看表字段 使用mysql的配置脚本：/usr/local/opt/mysql/bin/mysql_secure_installation //mysql 提供的配置向导启动这个脚本后 重置密码123456$ brew services stop mysql$ pkill mysqld$ rm -rf /usr/local/var/mysql/ # NOTE: this will delete your existing database!!!$ brew postinstall mysql$ brew services restart mysql$ mysql -u root","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://shjlone.github.io/tags/mac/"}]},{"title":"Connection reset by peer) while reading response header from upstream","slug":"技术开发/服务端/Connection reset by peer","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/Connection reset by peer/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Connection%20reset%20by%20peer/","excerpt":"","text":"问题：Connection reset by peer) while reading response header from upstream描述：某些请求一直返回502 Bad Gateway的错误，查看服务端的error日志，显示Connection reset by peer。当时的场景是一个每隔一分钟的定时脚本每次运行时，获取需要处理的数据，同步请求某个服务端接口进行文件上传。猜测是这个接口请求响应很慢，一分钟后又再次请求同样的接口而出现问题。 处理：修改接口对应的逻辑，让这个接口能快速响应；此问题消失。查阅资料，Nginx的响应有几个参数设置： keepalive_timeout：设置客户端的长连接超时时间，如果超过这个时间客户端没有发起请求，则Nginx服务器会主动关闭长连接。 keepalive_requests：设置与客户端的建立的一个长连接可以处理的最大请求次数，如果超过这个值，则Nginx会主动关闭该长连接。 对于此类问题，也可以尝试将keepalive_timeout的时间设置的长一些。","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Linux常用命令","slug":"技术开发/服务端/Linux常用命令","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/Linux常用命令/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"grep常用命令12345678910111213141516171819202122232425# 查找进程中所有跟nginx匹配的ps -ef | grep nginx# 查看进程数ps -ef | grep nginx -c # 搜索某个文件夹下，哪些文件包含关键字grep -r &quot;关键字&quot; 文件夹# 根据字符串搜索grep “被查找的字符串” 文件名 # 根据正则搜索grep –e “正则表达式” 文件名# 搜索不区分大小写grep –i “被查找的字符串” 文件名# 显示搜索出来的信息所在的行数grep -c “被查找的字符串” 文件名 find常用命令1234567891011# 查看当前目录下所有php文件find . &quot;*.php&quot;find . -name &quot;*.php&quot;# 查找当前目录下，最近120分钟修改过的文件find . -mmin -120# 查看当前目录下，是否有名字叫“通讯录”的文件夹，-type：表示设定类型，d表示文件夹类型，可以替换为f(普通文件)、l(链接文件)find . -type d -name 通讯录","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"MySQL知识点","slug":"技术开发/服务端/MySQL知识点","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/MySQL知识点/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"explain 使用 列名 说明 id 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 select_type 显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT） table 访问引用哪个表（引用某个查询，如“derived3”） type 数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL） possible_keys 揭示哪一些索引可能有利于高效的查找 key 显示mysql决定采用哪个索引来优化查询 key_len 显示mysql在索引里使用的字节数 ref 显示了之前的表在key列记录的索引中查找值所用的列或常量 rows 为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数 Extra 额外信息，如using index、filesort等 select_type 类型 说明 simple 简单子查询，不包含子查询和union primary 包含union或者子查询，最外层的部分标记为primary subquery 一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询 derived 派生表——该临时表是从子查询派生出来的，位于form中的子查询 union 位于union中第二个及其以后的子查询被标记为union，第一个就被标记为primary如果是union位于from中则标记为derived union result 用来从匿名临时表里检索结果的select被标记为union result dependent union 顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询 subquery 子查询中第一个SELECT语句 dependent subquery 和DEPENDENT UNION相对UNION一样 type type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。 类型 说明 All 最坏的情况,全表扫描 index 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多 range 范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 &lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range ref 一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或&lt;=&gt;操作符的带索引的列。 eq_ref 最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效） const 当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效） system 这是const连接类型的一种特例，表仅有一行满足条件。 Null 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效） Extra Extra是EXPLAIN输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息。 类型 说明 Using filesort MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 Using temporary 用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。 Not exists MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了。 Using index 说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。 Using index condition 这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。 Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤。 Using join buffer 使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接 impossible where where子句的值总是false，不能用来获取任何元组 select tables optimized away 在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作 慢查询分析查询日志设置1234567show variables like &#x27;general_log&#x27;; #查询是否开启查询日志set global general_log = on; # 开启查询日志show variables like &#x27;log_output&#x27;; # 查看日志写入类型set global log_output = &#x27;table&#x27;; #修改日志写入类型select *from mysql.slow_loglimit 100; # 慢查询日志记录表 mysql.slow_log 表字段意义 123456query_time： SQL语句的查询时间(在 MySQL 中所有类型的 SQL 语句执行的时间都叫做 query_time,而在 Oracle 中则仅指 select)lock_time: 锁的时间rows_sent: 返回了多少行,如果做了聚合就不准确了rows_examined: #执行这条 SQL 处理了多少行数据db: 使用了哪个数据库sql_text： 执行的sql语句 存疑的点 什么情况下需要开启查询缓存？ 常见问题","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"RabbitMQ笔记","slug":"技术开发/服务端/RabbitMQ笔记","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/RabbitMQ笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/RabbitMQ%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装安装PHP扩展amqp12345678910111213141516PHP &lt; 7.3#install some base extensionsRUN apt-get install -y \\ libzip-dev \\ zip \\ &amp;&amp; docker-php-ext-configure zip --with-libzip \\ &amp;&amp; docker-php-ext-install zipPHP &gt;= 7.3#install some base extensionsRUN apt-get install -y \\libzip-dev \\zip \\&amp;&amp; docker-php-ext-install zip 安装RabbitMQdocker安装，使用localhost:5672访问其后台 123456789101112rabbitmq: image:rabbitmq:management restart: always environment: RABBITMQ_DEFAULT_USER: &quot;root&quot; RABBITMQ_DEFAULT_PASS: &quot;root&quot; volumes: - ./code/rabbitmq/rabbitmq:/var/lib/rabbitmq - ./code/rabbitmq/log:/log/rabbitmq/log ports: - 15672:15672 - 5672:5672 Symfony安装扩展https://github.com/php-amqplib/RabbitMqBundle Symfony中的composer中添加 1&quot;php-amqplib/rabbitmq-bundle&quot;: &quot;1.14.4&quot; 执行更新命令 1php composer update php-amqplib/rabbitmq-bundle 使用参考 https://rabbitmq.com https://blog.csdn.net/whoamiyang/article/details/54954780","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"高效的使用Mac","slug":"工具软件/高效的使用Mac","date":"2021-06-07T01:45:07.557Z","updated":"2021-07-07T06:53:14.890Z","comments":true,"path":"wiki/工具软件/高效的使用Mac/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8Mac/","excerpt":"","text":"Effective use of XXX系列 Effective use of Mac Effective use of iPhone Effective use of Windows Effective use of Firefox Effective use of Alfred 对于高效使用的理解 所谓的高效，在笔者看来就是可以一步完成的事情，一定不要花两步。虽然Mac本身的操作已经比较人性化了，但还是有很多地方可以值得我们优化的。下面列一些场景分析一下。 场景一：想在不同软件之间快速切换。一般的做法是使用Command+Tab进行已经打开的软件间切换，使用聚焦搜索软件名进行打开。其实可以使用快捷键进行切换，参考Alfred的用法。 场景二：比如当前在文本编辑器页面写文章，突然想到某个东西需要去百度搜索一下。一般的做法是，使用Command+Tab切换到浏览器，在浏览器中新建tab页，输入baidu.com，输入关键字，进行搜索。而使用Alfred，则可以优化为：Alt+space打开Alfred搜索框，输入bd+空格，输入关键字，回车，即可自动打开浏览器搜索页。 场景三：在做复制粘贴的时候，有时候想对以前复制过的内容进行粘贴。 场景四：有一些使用率非常高的词，比如QQ号、邮箱、手机号、身份证号等信息，需要不停的输入，如果可以做到输入几个关键字就能全部输出岂不是提升了很多时间？ 好了，下面正式开始动手吧！ 此文致力于提高使用效率，基本的操作请读者自行阅读官方文档或其他文档。 Mac的基本优化访达的优化显示隐藏文件方法一： 使用快捷键Command+Shift+. 方法二： 终端中输入下面的命令，这种方式会长久生效。 1234隐藏defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder显示defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder 顶部栏显示完整路径可以通过在访达中设置显示路径栏的方式显示，不过这种方式会在访达底部多一栏。可以通过终端输入以下命令。 123456显示完整路径defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE;killall Finder隐藏完整路径defaults delete com.apple.finder _FXShowPosixPathInTitle;killall Finder 标签的使用这是一个非常实用的功能，将文件/文件夹标记成不同的标签，然后通过点击标签来快速定位。对于目录层次很深的文件非常有用。 使用也很简单，右键某个文件或文件夹，点击某个标签即可。标签也可以进行管理，标签的图标也可以自定义，选中标签栏中某个标签，使用command+control+空格。 对于使用频率非常高的文件夹，可以直接拖拽到个人收藏栏，也可以拖拽到工具栏 开机启动脚本设置首先创建一个shell文件，根据自己的需求实现一些逻辑，比如： 123456789#开机启动脚本# 开机需要启动的程序open /Applications/DingTalk.appopen /Applications/QQ.app# 其他操作#exit 然后给这个文件添加执行权限，chmod +x 文件名。然后设置打开方式为终端。 然后打开系统偏好设置–&gt;用户与群组–&gt;登录项，添加新建的shell文件。 Mac上的提高效率的软件Alfred（神器）由于此软件非常强大，因此单独写一篇来介绍它，[点击查看]() switchhost（hosts切换）该软件是用来做hosts管理的，对于程序员来说非常友好，用法也很简单。可以建立一个个tab来分组管理，每个tab可以的显示隐藏互不影响。点击行号可以对该行进行快速注释或者取消注释。 [img] iTerm（终端的替代品）配置 资源管理器工具Commander One不完善的地方： 路径栏无法直接编辑，不方便直接跳转到某个路径。Total Commander的路径是可编辑的。 无法直接使用快捷键将当前页面显示到另外一测。Total Commander可以直接使用Ctrl+←→来操作。 不可配置编辑所使用的软件，只能用默认的。 BatterZip（文件解压压缩）Sublime Text（文件编辑器）轻量级文本编辑器，可配置性很强。 CleanMyMac（优化工具）Dash（程序员API查询工具）iShot（截图、录屏工具）Commander One（访达替代品）Mac常用命令12lsof -i:port 查询端口对应的进程idkill pid 杀死进程 参考","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://shjlone.github.io/tags/mac/"}]},{"title":"Firefox插件推荐","slug":"工具软件/Firefox插件推荐","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/Firefox插件推荐/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Firefox%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"AdGuard去广告神器 https://github.com/AdGuardTeam/AdGuardBrowserExtension In My Pocket将网页内容缓存起来，方便以后阅读，查看。 JSON Lite对json类型格式化显示 OctotreeGithub的文件目录用树形表示 Greasemonkey脚本管理器 Dark Reader设置黑色主题 印象笔记·剪藏保存网页内容到Evernote iCloud书签同步Firefox和Safira书签","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Proxifier使用","slug":"工具软件/Proxifier使用","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/Proxifier使用/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Proxifier%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Proxifier的作用：让电脑上的软件的网络请求先经过代理，可用于翻墙、接口抓取等。 设置Proxies设置Server设置为代理对应的IP地址，本地使用localhost/127.0.0.1 Protocol可设置为Socks或https Rules设置可以做一些个性化设置，比如某些应用不走代理 参考 https://xiandan.in/posts/mac-global-proxy.html https://www.hizxc.com/1546.html","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Windows优秀的工具软件","slug":"工具软件/Windows优秀的工具软件","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/Windows优秀的工具软件/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Windows%E4%BC%98%E7%A7%80%E7%9A%84%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"文件解锁工具 魔方解锁独立版 内存、CPU监控工具TrafficMonitor 介绍：https://www.appinn.com/trafficmonitor/ Github地址：https://github.com/zhongyang219/TrafficMonitor 文件管理工具TotalCommand 官网地址：https://www.ghisler.com/ 文件搜索工具Everything 官网地址：http://www.voidtools.com/ 剪切板增强工具Ditto 官网地址：https://ditto-cp.sourceforge.io/ 屏幕截图工具 Snagit FSCapture 相关介绍 颜色吸取工具getcolor! 下载地址： https://www.wincatalog.com/getcolor.html","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"屏幕截图工具","slug":"工具软件/屏幕截图工具","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/屏幕截图工具/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/","excerpt":"","text":"平时工作中有很多场景需要使用屏幕截图，原来一直使用QQ自带的截图功能。虽然功能不是很全，但也够了。但由于其是QQ的一个子功能，每次一定要启动QQ才能使用。于是想看有木有更加方便好用的截图软件。 这里推荐两款自认为不错的工具： Snagit主要功能： 捕获窗口截图 区域截图 全屏幕截图 抓取文字 屏幕录像 捕获滚动窗口 FSCapture主要功能： 捕获窗口截图 区域截图 全屏幕截图 抓取文字 屏幕录像 捕获滚动窗口 捕获手绘区域 QQ截屏独立版包含所需的基本功能，且可执行文件很小，不到800K。添加桌面快捷方式，配置好快捷键后，使用非常方便。 下载地址：","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"文本编辑工具Sublime Text","slug":"工具软件/文本编辑工具Sublime Text","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.557Z","comments":true,"path":"wiki/工具软件/文本编辑工具Sublime Text/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7Sublime%20Text/","excerpt":"","text":"Markdown环境搭建安装扩展MarkdownEditing下载地址： https://github.com/SublimeText-Markdown/MarkdownEditing 快捷键 Windows/Linux 描述 CtrlAltV Creates or pastes the contents of the clipboard as an inline link on selected text. CtrlAltR Creates or pastes the contents of the clipboard as a reference link. ShiftWinK Creates or pastes the contents of the clipboard as an inline image on selected text. AltB AltI These are bound to bold and italic. They work both with and without selections. If there is no selection, they will just transform the word under the cursor. These keybindings will unbold/unitalicize selection if it is already bold/italic. Ctrl1...6 These will add the corresponding number of hashmarks for headlines. Works on blank lines and selected text in tandem with the above headline tools. If you select an entire existing headline, the current hashmarks will be removed and replaced with the header level you requested. This command respects the mde.match_header_hashes preference setting. AltShift6 Inserts a footnote. ShiftTab Fold/Unfold current section. CtrlShiftTab Fold all sections under headings of a certain level. CtrlAltShiftPageUp CtrlAltShiftPageDown Go to the previous/next heading of the same or higher level CtrlShiftPageUp CtrlShiftPageDown Go to the previous/next heading CtrlShiftH Open home page CtrlShiftD Open wiki page under the cursor CtrlShiftJ Open journal page for today CtrlShiftB List back links 表格编辑插件下载地址： https://packagecontrol.io/packages/Table%20Editor PHP环境搭建Python环境搭建安装Anaconda插件(代码提示、自动补全、格式化)//快捷键配置 [ &#123; &quot;command&quot;: &quot;anaconda_goto&quot;, &quot;keys&quot;: [&quot;ctrl+alt+g&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_find_usages&quot;, &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_doc&quot;, &quot;keys&quot;: [&quot;ctrl+alt+d&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, //格式化 &#123; &quot;command&quot;: &quot;anaconda_auto_format&quot;, &quot;keys&quot;: [&quot;ctrl+alt+r&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_fill_funcargs&quot;, &quot;keys&quot;: [&quot;tab&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125;, &#123;&quot;key&quot;: &quot;anaconda_insert_funcargs&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_fill_funcargs&quot;, &quot;keys&quot;: [&quot;ctrl+tab&quot;], &quot;args&quot;: &#123;&quot;all&quot;: true&#125;, &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125;, &#123;&quot;key&quot;: &quot;anaconda_insert_funcargs&quot;&#125; ]&#125; ] 配置Python解释器打开Preferences--&gt;Package Settings--&gt;Anaconda--&gt;Settings-User &#123; //设置python解释器路径 &quot;python_interpreter&quot;: &quot;D:\\\\Python\\\\Python364-64\\\\python.exe&quot;, &quot;suppress_word_completions&quot;: true, &quot;suppress_explicit_completions&quot;: true, &quot;complete_parameters&quot;: true, &quot;anaconda_linting&quot;: false &#125; Sublime中console交互，安装SublimeREPL配置SUblimeREPL快捷键1. Preferences--&gt;Browse Packages--&gt;SublimeREPL文件夹--&gt;config文件夹--&gt;Python文件夹--&gt;Default.sublime-commands 2. 找到对应的command，添加到Preferences--&gt;Key Bindings User中。 &#123; &quot;keys&quot;: [&quot;f5&quot;], &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;, 如何设置快捷键打开Preferences--&gt;Key Bindings，对于向要定义自己喜好的快捷键的操作，复制左边默认的配置到用户栏，进行修改。 如何修改默认配置打开Preferences--&gt;Settings，重写默认配置即可。 Sublime 插件Anaconda:Python插件 CodeFormatter：代码提示插件 ConvertToUTF8 SublimeCodeIntel Markdown Preview：Markdown预览插件 Emmet：HTML/CSS代码快速编写插件 SublimeLinter：代码检测插件 SideBarEnhancements：侧边栏扩展 PackageResourceViewer：Sublime配置管理插件,选择Open Resource,选择对应的配置进行修改 Boxy Theme:样式插件 Terminal：在Sublime中打开终端 CTags：[代码跳转](https://my.oschina.net/u/1024767/blog/495282) http://ctags.sourceforge.net/ Sublime PHP Companion All Autocomplete DocBlockr SublimeAStyleFormatter：C, C++, C#, 和 Java文件格式化 如何备份插件备份Preferences–&gt;Browse Packages的内容 属性配置&#123; //默认字体大小 &quot;font_size&quot;: 10, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], //是否检查更新 &quot;update_check&quot;: &quot;false&quot;, //显示空格符号 // &quot;draw_white_space&quot;: &quot;all&quot;, &#125; 常用快捷键配置[ //跳转到定义 &#123; &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;goto_definition&quot; &#125;, //删除当前行 &#123; &quot;keys&quot;: [&quot;ctrl+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;, //back &#123; &quot;keys&quot;: [&quot;alt+left&quot;], &quot;command&quot;: &quot;jump_back&quot; &#125;, //forward &#123; &quot;keys&quot;: [&quot;alt+right&quot;], &quot;command&quot;: &quot;jump_forward&quot; &#125;, //移动当前行到上一行 &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;, //移动当前行到下一行 &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;, // 自动提示、补全 &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot;&#125;, //代码提示 &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;replace_completion_with_auto_complete&quot;, &quot;context&quot;: [&#123; &quot;key&quot;: &quot;last_command&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;insert_best_completion&quot; &#125;, &#123; &quot;key&quot;: &quot;auto_complete_visible&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: false &#125;, &#123; &quot;key&quot;: &quot;setting.tab_completion&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true &#125;] &#125;, //Ctrl+l 选中当前行 //编译当前脚本 &#123; &quot;keys&quot;: [&quot;ctrl+b&quot;], &quot;command&quot;: &quot;build&quot; &#125;, //隐藏Side Bar开关 &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;], &quot;command&quot;: &quot;toggle_side_bar&quot; &#125;, //向左缩进 &#123; &quot;keys&quot;: [&quot;ctrl+]&quot;], &quot;command&quot;: &quot;indent&quot; &#125;, //向右缩进 &#123; &quot;keys&quot;: [&quot;ctrl+[&quot;], &quot;command&quot;: &quot;unindent&quot; &#125;, //列出当前打开的文件 &#123; &quot;keys&quot;: [&quot;ctrl+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;command_palette&quot;&#125; &#125;, //跳转到符号 &#123; &quot;keys&quot;: [&quot;ctrl+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;, //跳转到行 &#123; &quot;keys&quot;: [&quot;ctrl+g&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+;&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;, //快速在起始括号和结尾括号间切换 &#123; &quot;keys&quot;: [&quot;ctrl+m&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;, //选择括号间的内容 &#123; &quot;keys&quot;: [&quot;ctrl+shift+m&quot;], &quot;command&quot;: &quot;expand_selection&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;, //当前行下面新增一行并跳至该行 &#123; &quot;keys&quot;: [&quot;ctrl+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;, //当前行上面新增一行并调至该行 &#123; &quot;keys&quot;: [&quot;ctrl+shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Add Line Before.sublime-macro&quot;&#125; &#125;, //进行逐词移动 &#123; &quot;keys&quot;: [&quot;ctrl+left&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;words&quot;, &quot;forward&quot;: false&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+right&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;word_ends&quot;, &quot;forward&quot;: true&#125; &#125;, //逐词选择 &#123; &quot;keys&quot;: [&quot;ctrl+shift+left&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;words&quot;, &quot;forward&quot;: false, &quot;extend&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+right&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;word_ends&quot;, &quot;forward&quot;: true, &quot;extend&quot;: true&#125; &#125;, //上下移动当前显示区域 &#123; &quot;keys&quot;: [&quot;ctrl+up&quot;], &quot;command&quot;: &quot;scroll_lines&quot;, &quot;args&quot;: &#123;&quot;amount&quot;: 1.0 &#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+down&quot;], &quot;command&quot;: &quot;scroll_lines&quot;, &quot;args&quot;: &#123;&quot;amount&quot;: -1.0 &#125; &#125;, //移动当前行 &#123; &quot;keys&quot;: [&quot;ctrl+shift+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;, //删除当前 &#123; &quot;keys&quot;: [&quot;ctrl+shift+k&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;, //Ctrl + D选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑。 &#123; &quot;keys&quot;: [&quot;ctrl+d&quot;], &quot;command&quot;: &quot;find_under_expand&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;, &quot;ctrl+d&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;, //打散所选区域 &#123; &quot;keys&quot;: [&quot;ctrl+shift+l&quot;], &quot;command&quot;: &quot;split_selection_into_lines&quot; &#125;, //将选中区域合并为一行 &#123; &quot;keys&quot;: [&quot;ctrl+j&quot;], &quot;command&quot;: &quot;join_&lt;l&gt;&lt;/l&gt;ines&quot; &#125;, //选择行 &#123; &quot;keys&quot;: [&quot;ctrl+l&quot;], &quot;command&quot;: &quot;expand_selection&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;line&quot;&#125; &#125;, //把选区分割 &#123; &quot;keys&quot;: [&quot;ctrl+shift+l&quot;], &quot;command&quot;: &quot;split_selection_into_lines&quot; &#125;, ] 如何自定义插件 如何自定义代码块 如何自定义语法 参考官方文档 Sublime Text非官方文档 Sublime Text3文档","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Alfred使用技巧","slug":"工具软件/Alfred使用技巧","date":"2021-06-07T01:45:07.555Z","updated":"2021-06-07T01:45:07.555Z","comments":true,"path":"wiki/工具软件/Alfred使用技巧/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Alfred%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"基本操作 使用Alt+空格启动，在输入框中输入相应命令进行操作。以下根据其设置界面的布局，按照相应的目录进行介绍。 General General界面主要是以下几个功能： Startup：是否在系统启动时自启动Alfred。 Alfred Hotkey：调出Alfred操作界面的热键。默认为Alt + 空格。 Where are you：你在哪个国家。Alfred内置了常用网站搜索功能，在搜索时打开对应国家的网站。 Features 这里包含了Alfred自己开发的功能，接下来一个一个介绍它们。有些功能在我们日常使用中非常有用！ Defalut Result 打开输入框后，按一下空格，即可在Finder中搜索相应文件。 Essentials： 基本的搜索设置 Extras： 额外的搜索设置 Search Scope： 搜索的范围，可以自定义一些常用文件夹 Fallbacks： 若上面的查询搜索不到结果时，就会调用这里设置的网站或搜索引擎来进行进一步的查询。 File Search SearchOpening Files open+文件名直接打开某个文件。 Revealing Files find+文件名则表示在Finder中打开该文件。 Inside Files in+内容可以把文件中包含内容的文件找出来。 File Tags tag+标签名字可以把打上标签的文件或文件夹搜索出来。 Don’t Show: 不显示某类型的文件 Result Limit： 搜索条数限制 NavigationBufferAdvancedActions顾名思义，Actions指你要对文件执行的动作。先搜索到你要处理的文件，然后点击Ctrl键。 Web Search 网络搜索，也可以自定义自己的搜索。比如使用百度搜索 Web Bookmarks搜索浏览器书签，目前只支持safari、chrome。 Clipboard History剪切板历史，可以自定义快捷键，打开历史面板。非常实用的一个功能。 Snippets短语设置，配置一些常用的短语，设置简短的关键字。还可以设置自动替换。 Calculator可以直接在aflred搜索框中使用计算功能 Workflows有了工作流，我们的效率会得到很大的提高。比如，可以迅速切换软件，快速查询自己想看的书评、电影评价，快速查询当前ip地址，快速查询当前股票的价格等。 AppLauncher设置快捷键快速打开软件 douban豆瓣搜索，dbb+书名和dbm+电影名进行相关搜索 Githubgithub搜索 Gitlabgitlab搜索 IP Address当前内网和外网ip查询 中国股票行情 进行股票查询，gp+股票号码进行实时股价查询，gp add xxxxxx把相应股票添加到自选股，gp list查看所有自选股的股价。 AppearanceAlfred主题 RemoteAdvanced","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Chrome插件推荐","slug":"工具软件/Chrome插件推荐","date":"2021-06-07T01:45:07.555Z","updated":"2021-07-12T02:42:26.742Z","comments":true,"path":"wiki/工具软件/Chrome插件推荐/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"Proxy SwitchyOmegaVPN代理 Clear Cache清理缓存 DJSON ViewerJSON格式化显示 Gitlab TreeViewGitlab文件夹树形显示 Last Pass记录密码 Extensity扩展显示管理 LighthouseLighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"tushare","slug":"Python/tushare","date":"2021-06-07T01:45:07.554Z","updated":"2021-06-07T01:45:07.554Z","comments":true,"path":"wiki/Python/tushare/","link":"","permalink":"http://shjlone.github.io/wiki/Python/tushare/","excerpt":"","text":"股票数据抓取框架使用TuShare。 http://tushare.org/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"sqlalchemy","slug":"Python/sqlalchemy","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/sqlalchemy/","link":"","permalink":"http://shjlone.github.io/wiki/Python/sqlalchemy/","excerpt":"","text":"为什么要使用ORM框架？ 为了方便，降低出错概率，可读性更好。 基本操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152连接数据#Unix/Mac - 4 initial slashes in totalengine = create_engine(&#x27;sqlite:////absolute/path/to/foo.db&#x27;)#Windowsengine = create_engine(&#x27;sqlite:///C:\\\\path\\\\to\\\\foo.db&#x27;)#Windows alternative using raw stringengine = create_engine(r&#x27;sqlite:///C:\\path\\to\\foo.db&#x27;)创建引擎engine = create_engine(&#x27;sqlite:///foo.db?check_same_thread=False&#x27;, echo=True)定义映射from sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()创建实体类from sqlalchemy import Column, Integer, String# 定义映射类User，其继承上一步创建的Baseclass User(Base): # 指定本类映射到users表 __tablename__ = &#x27;users&#x27; # 如果有多个类指向同一张表，那么在后边的类需要把extend_existing设为True，表示在已有列基础上进行扩展 # 或者换句话说，sqlalchemy允许类是表的字集 # __table_args__ = &#123;&#x27;extend_existing&#x27;: True&#125; # 如果表在同一个数据库服务（datebase）的不同数据库中（schema），可使用schema参数进一步指定数据库 # __table_args__ = &#123;&#x27;schema&#x27;: &#x27;test_database&#x27;&#125; # 各变量名一定要与表的各字段名一样，因为相同的名字是他们之间的唯一关联关系 # 从语法上说，各变量类型和表的类型可以不完全一致，如表字段是String(64)，但我就定义成String(32) # 但为了避免造成不必要的错误，变量的类型和其对应的表的字段的类型还是要相一致 # sqlalchemy强制要求必须要有主键字段不然会报错，如果要映射一张已存在且没有主键的表，那么可行的做法是将所有字段都设为primary_key=True # 不要看随便将一个非主键字段设为primary_key，然后似乎就没报错就能使用了，sqlalchemy在接收到查询结果后还会自己根据主键进行一次去重 # 指定id映射到id字段; id字段为整型，为主键，自动增长（其实整型主键默认就自动增长） id = Column(Integer, primary_key=True, autoincrement=True) # 指定name映射到name字段; name字段为字符串类形， name = Column(String(20)) fullname = Column(String(32)) password = Column(String(32)) # __repr__方法用于输出该类的对象被print()时输出的字符串，如果不想写可以不写 def __repr__(self): return &quot;&lt;User(name=&#x27;%s&#x27;, fullname=&#x27;%s&#x27;, password=&#x27;%s&#x27;)&gt;&quot; % ( self.name, self.fullname, self.password)# 查看映射对应的表User.__table__# 创建数据表。一方面通过engine来连接数据库，另一方面根据哪些类继承了Base来决定创建哪些表# checkfirst=True，表示创建表前先检查该表是否存在，如同名表已存在则不再创建。其实默认就是TrueBase.metadata.create_all(engine, checkfirst=True)# 上边的写法会在engine对应的数据库中创建所有继承Base的类对应的表，但很多时候很多只是用来则试的或是其他库的# 此时可以通过tables参数指定方式，指示仅创建哪些表# Base.metadata.create_all(engine,tables=[Base.metadata.tables[&#x27;users&#x27;]],checkfirst=True)# 在项目中由于model经常在别的文件定义，没主动加载时上边的写法可能写导致报错，可使用下边这种更明确的写法# User.__table__.create(engine, checkfirst=True)# 另外我们说这一步的作用是创建表，当我们已经确定表已经在数据库中存在时，我完可以跳过这一步# 针对已存放有关键数据的表，或大家共用的表，直接不写这创建代码更让人心里踏实创建会话# engine是2.2中创建的连接Session = sessionmaker(bind=engine)# 创建Session类实例session = Session()新增# 创建User类实例ed_user = User(name=&#x27;ed&#x27;, fullname=&#x27;Ed Jones&#x27;, password=&#x27;edspassword&#x27;)# 将该实例插入到users表session.add(ed_user)# 一次插入多条记录形式session.add_all( [User(name=&#x27;wendy&#x27;, fullname=&#x27;Wendy Williams&#x27;, password=&#x27;foobar&#x27;), User(name=&#x27;mary&#x27;, fullname=&#x27;Mary Contrary&#x27;, password=&#x27;xxg527&#x27;), User(name=&#x27;fred&#x27;, fullname=&#x27;Fred Flinstone&#x27;, password=&#x27;blah&#x27;)])# 当前更改只是在session中，需要使用commit确认更改才会写入数据库session.commit()查询our_user = session.query(User).filter_by(name=&#x27;ed&#x27;).first()our_user# 比较ed_user与查询到的our_user是否为同一条记录ed_user is our_user# 只获取指定字段# 但要注意如果只获取部分字段，那么返回的就是元组而不是对象了# session.query(User.name).filter_by(name=&#x27;ed&#x27;).all()# like查询# session.query(User).filter(User.name.like(&quot;ed%&quot;)).all()# 正则查询# session.query(User).filter(User.name.op(&quot;regexp&quot;)(&quot;^ed&quot;)).all()# 统计数量# session.query(User).filter(User.name.like(&quot;ed%&quot;)).count()# 调用数据库内置函数# 以count()为例，都是直接func.func_name()这种格式，func_name与数据库内的写法保持一致# from sqlalchemy import func# session.query(func.count(User3.name)).one()# 字段名为字符串形式# column_name = &quot;name&quot;# session.query(User).filter(User3.__table__.columns[column_name].like(&quot;ed%&quot;)).all()# 获取执行的sql语句# 获取记录数的方法有all()/one()/first()等几个方法，如果没加这些方法，得到的只是一个将要执行的sql对象，并没真正提交执行# from sqlalchemy.dialects import mysql# sql_obj = session.query(User).filter_by(name=&#x27;ed&#x27;)# sql_command = sql_obj.statement.compile(dialect=mysql.dialect(), compile_kwargs=&#123;&quot;literal_binds&quot;: True&#125;)# sql_result = sql_obj.all()修改# session.query(User).filter_by(name=&#x27;ed&#x27;).update(&#123;User.password: &#x27;modify_passwd&#x27;&#125;)# session.commit()删除# 要删除需要先将记录查出来del_user = session.query(User).filter_by(name=&#x27;ed&#x27;).first()# 打印一下，确认未删除前记录存在del_user# 将ed用户记录删除session.delete(del_user)# 确认删除session.commit()# 遍历查看，已无ed用户记录for user in session.query(User): print(user)# 但上边的写法，先查询再删除，相当于给mysql服务端发了两条语句，和我们印象中的delete语句不一致# 可直接使用下边的写法，传给服务端的就是delete语句# session.query(User).filter_by(name=&#x27;ed&#x27;).first().delete() 参考 github官方地址：https://github.com/sqlalchemy/sqlalchemy 官方文档地址：https://docs.sqlalchemy.org/en/13/ https://docs.sqlalchemy.org/en/13/orm/tutorial.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"win32模块","slug":"Python/pywin32模块","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/pywin32模块/","link":"","permalink":"http://shjlone.github.io/wiki/Python/pywin32%E6%A8%A1%E5%9D%97/","excerpt":"","text":"Python提供了调用系统级别API的功能，ctype、sip等都可以用来调用C++代码，以此来和系统交互。win32模块提供了调用本地win32 GUI API的接口，使得我们可以更方便的调用系统级别的API。可以做诸如监听全局快捷键、操作任务栏系统图标等功能。 在使用之前，先了解下WIndows常用的API。 1. WIndows API1.1 API之消息函数 函数 作用 BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口 GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置 GetMessageTime 取得消息队列中上一条消息处理完毕时的时间 PostMessage 将一条消息投递到指定窗口的消息队列 PostThreadMessage 将一条消息投递给应用程序 RegisterWindowMessage 获取分配给一个字串标识符的消息编号 ReplyMessage 答复一个消息 SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口 SendMessageCallback 将一条消息发给窗口 SendMessageTimeout 向窗口发送一条消息 SendNotifyMessage 向窗口发送一条消息 1.2 API之控件与消息函数 函数名 作用 AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小 AnyPopup 判断屏幕上是否存在任何弹出式窗口 ArrangeIconicWindows 排列一个父窗口的最小化子窗口 AttachThreadInput 连接线程输入函数 BeginDeferWindowPos 启动构建一系列新窗口位置的过程 BringWindowToTop 将指定的窗口带至窗口列表顶部 CascadeWindows 以层叠方式排列窗口 ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄 ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标 CloseWindow 最小化指定的窗口 CopyRect 矩形内容复制 DeferWindowPos 该函数为特定的窗口指定一个新窗口位置 DestroyWindow 清除指定的窗口以及它的所有子窗口 DrawAnimatedRects 描绘一系列动态矩形 EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入 EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态 EnumChildWindows 为指定的父窗口枚举子窗口 EnumThreadWindows 枚举与指定任务相关的窗口 EnumWindows 枚举窗口列表中的所有父窗口 EqualRect 判断两个矩形结构是否相同 FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口 FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口 FlashWindow 闪烁显示指定窗口 GetActiveWindow 获得活动窗口的句柄 GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收） GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息 GetClassLong 取得窗口类的一个Long变量条目 GetClassName 为指定的窗口取得类名 GetClassWord 为窗口类取得一个整数变量 GetClientRect 返回指定窗口客户区矩形的大小 GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄 GetFocus 获得拥有输入焦点的窗口的句柄 GetForegroundWindow 获得前台窗口的句柄 GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄 GetParent 判断指定窗口的父窗口 GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄 GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分 GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系 GetWindowContextHelpId 取得与窗口关联在一起的帮助场景ID GetWindowLong 从指定窗口的结构中取得信息 GetWindowPlacement 获得指定窗口的状态及位置信息 GetWindowRect 获得整个窗口的范围矩形,窗口的边框、标题栏、滚动条及菜单等都在这个矩形内 GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容 GetWindowTextLength 调查窗口标题文字或控件内容的长短 GetWindowWord 获得指定窗口结构的信息 InflateRect 增大或减小一个矩形的大小 IntersectRect 这个函数在 lpDestRect 里载入一个矩形, 它是lpSrc1Rect与lpSrc2Rect两个矩形的交集 InvalidateRect 屏蔽一个窗口客户区的全部或部分区域 IsChild 判断一个窗口是否为另一窗口的子或隶属窗口 IsIconic 判断窗口是否已最小化 IsRectEmpty 判断一个矩形是否为空 IsWindow 判断一个窗口句柄是否有效 IsWindowEnabled 判断窗口是否处于活动状态 IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字 IsWindowVisible 判断窗口是否可见 IsZoomed 判断窗口是否最大化 LockWindowUpdate 锁定指定窗口，禁止它更新 MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统 MoveWindow 改变指定窗口的位置和大小 OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来 OpenIcon 恢复一个最小化的程序，并将其激活 PtInRect 判断指定的点是否位于矩形内部 RedrawWindow 重画全部或部分窗口 ReleaseCapture 为当前的应用程序释放鼠标捕获 ScreenToClient 判断屏幕上一个指定点的客户区坐标 ScrollWindow 滚动窗口客户区的全部或一部分 ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分 SetActiveWindow 激活指定的窗口 SetCapture 将鼠标捕获设置到指定的窗口 SetClassLong 为窗口类设置一个Long变量条目 SetClassWord 为窗口类设置一个条目 SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口 SetForegroundWindow 将窗口设为系统的前台窗口 SetParent 指定一个窗口的新父 SetRect 设置指定矩形的内容 SetRectEmpty 将矩形设为一个空矩形 SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）ID SetWindowLong 在窗口结构中为指定的窗口设置信息 SetWindowPlacement 设置窗口状态和位置信息 SetWindowPos 为窗口指定一个新位置和状态 SetWindowText 设置窗口的标题文字或控件的内容 SetWindowWord 在窗口结构中为指定的窗口设置信息 ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口 ShowWindow 控制窗口的可见性 ShowWindowAsync 与ShowWindow相似 SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果 TileWindows 以平铺顺序排列窗口 UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果 UpdateWindow 强制立即更新窗口 ValidateRect 校验窗口的全部或部分客户区 WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口 1.3 API之文本和字体函数 函数名 作用 AddFontResource 在Windows系统中添加一种字体资源 CreateFont 用指定的属性创建一种逻辑字体 CreateFontIndirect 用指定的属性创建一种逻辑字体 CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统 DrawText 将文本描绘到指定的矩形中 DrawTextEx 与DrawText相似，只是加入了更多的功能 EnumFontFamilies 列举指定设备可用的字体 EnumFontFamiliesEx 列举指定设备可用的字体 EnumFonts 列举指定设备可用的字体 ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数 GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小 GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小 GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸 GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串 GetCharWidth 调查字体中一个或多个字符的宽度 GetFontData 接收一种可缩放字体文件的数据 GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息 GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息 GetKerningPairs 取得指定字体的字距信息 GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息 GetRasterizerCaps 了解系统是否有能力支持可缩放的字体 GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素 GetTextAlign 接收一个设备场景当前的文本对齐标志 GetTextCharacterExtra 判断额外字符间距的当前值 GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符 GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息 GetTextColor 判断当前字体颜色。通常也称为“前景色” GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息 GetTextExtentPoint 判断一个字串的大小（范围） GetTextFace 获取一种字体的字样名 GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息 GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态 PolyTextOut 描绘一系列字串 RemoveFontResource 从Windows系统中删除一种字体资源 SetMapperFlags Windows 对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体 SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置 SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距 SetTextColor 设置当前文本颜色。这种颜色也称为“前景色” SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理 TabbedTextOut 支持制表站的一个文本描绘函数 TextOut 文本绘图函数 1.4 API之位图、图标和光栅运算函数 函数名 作用 BitBlt 将一幅位图从一个设备场景复制到另一个 CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序 CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作 CreateBitmap 按照规定的格式创建一幅与设备有关位图 CreateBitmapIndirect 创建一幅与设备有关位图 CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容 CreateCursor 创建一个鼠标指针 CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图 CreateDIBSection 创建一个DIBSection CreateIcon 创建一个图标 CreateIconIndirect 创建一个图标 DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源 DestroyIcon 清除图标 DrawIcon 在指定的位置画一个图标 DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能 ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之 ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来 GetBitmapBits 将来自位图的二进制位复制到一个缓冲区 GetBitmapDimensionEx 取得一幅位图的宽度和高度 GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息 GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里 GetIconInfo 取得与图标有关的信息 GetStretchBltMode 判断StretchBlt 和 StretchDIBits函数采用的伸缩模式 LoadBitmap 从指定的模块或应用程序实例中载入一幅位图 LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针 LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针 LoadIcon 从指定的模块或应用程序实例中载入一个图标 LoadImage 载入一个位图、图标或指针 MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理 PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景 PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理 SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图 SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位 SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息 SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里 SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备 SetStretchBltMode 指定StretchBlt 和 StretchDIBits函数的伸缩模式 StretchBlt 将一幅位图从一个设备场景复制到另一个 StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景 1.5 API之菜单函数 函数名 作用 AppendMenu 在指定的菜单里添加一个菜单项 CheckMenuItem 复选或撤消复选指定的菜单条目 CheckMenuRadioItem 指定一个菜单条目被复选成“单选”项目 CreateMenu 创建新菜单 CreatePopupMenu 创建一个空的弹出式菜单 DeleteMenu 删除指定的菜单条目 DestroyMenu 删除指定的菜单 DrawMenuBar 为指定的窗口重画菜单 EnableMenuItem 允许或禁止指定的菜单条目 GetMenu 取得窗口中一个菜单的句柄 GetMenuCheckMarkDimensions 返回一个菜单复选符的大小 GetMenuContextHelpId 取得一个菜单的帮助场景ID GetMenuDefaultItem 判断菜单中的哪个条目是默认条目 GetMenuItemCount 返回菜单中条目（菜单项）的数量 GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息 GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息 GetMenuState 取得与指定菜单条目状态有关的信息 GetMenuString 取得指定菜单条目的字串 GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置 GetSystemMenu 取得指定窗口的系统菜单的句柄 HiliteMenuItem 控制顶级菜单条目的加亮显示状态 InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动 InsertMenuItem 插入一个新菜单条目 IsMenu 判断指定的句柄是否为一个菜单的句柄 LoadMenu 从指定的模块或应用程序实例中载入一个菜单 LoadMenuIndirect 载入一个菜单 MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点 ModifyMenu 改变菜单条目 RemoveMenu 删除指定的菜单条目 SetMenu 设置窗口菜单 SetMenuContextHelpId 设置一个菜单的帮助场景ID SetMenuDefaultItem 将一个菜单条目设为默认条目 SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√） SetMenuItemInfo 为一个菜单条目设置指定的信息 TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单 TrackPopupMenuEx 与TrackPopupMenu 相似，只是它提供了额外的功能 1.6 API之设备场景函数 函数名 作用 CombineRgn 将两个区域组合为一个新区域 CombineTransform 驱动世界转换。它相当于依顺序进行两次转换 CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景 CreateDC 为专门设备创建设备场景 CreateEllipticRgn 创建一个椭圆 CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域 CreateIC 为专用设备创建一个信息场景 CreatePolygonRgn 创建一个由一系列点围成的区域 CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的 CreateRectRgn 创建一个矩形区域 CreateRectRgnIndirect 创建一个矩形区域 CreateRoundRectRgn 创建一个圆角矩形 DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源 DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标 EqualRgn 确定两个区域是否相等 ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图 ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域 ExtCreateRegion 根据世界转换修改区域 ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区 FillRgn 用指定刷子填充指定区域 FrameRgn 用指定刷子围绕指定区域画一个外框 GetBoundsRect 获取指定设备场景的边界矩形 GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形 GetClipRgn 获取设备场景当前剪裁区 GetDC 获取指定窗口的设备场景 GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项 GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示） GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息 GetGraphicsMode 确定是否允许增强图形模式（世界转换） GetMapMode 为特定设备场景调入映象模式 GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区 GetRgnBox 获取完全包含指定区域的最小矩形 GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新 GetViewportExtEx 获取设备场景视口（viewport）范围 GetViewportOrgEx 获取设备场景视口起点 GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景 GetWindowExtEx 获取指定设备场景的窗口范围 GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点 GetWindowRgn 获取窗口区域 GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换 IntersectClipRect 为指定设备定义一个新的剪裁区 InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画 InvertRgn 通过颠倒每个像素值反转设备场景指定区域 LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标 ModifyWorldTransform 根据指定的模式修改世界转换 OffsetClipRgn 按指定量平移设备场景剪裁区 OffsetRgn 按指定偏移量平移指定区域 OffsetViewportOrgEx 平移设备场景视口区域 OffsetWindowOrgEx 平移指定设备场景窗口起点 PaintRgn 用当前刷子背景色填充指定区域 PtInRegion 确定点是否在指定区域内 PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内） RectInRegion 确定矩形是否有部分在指定区域内 RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内） ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景 RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景 SaveDC 将指定设备场景状态保存到Windows设备场景堆栈 ScaleViewportExtEx 缩放设备场景视口的范围 ScaleWindowExtEx 缩放指定设备场景窗口范围 ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形 SelectClipRgn 为指定设备场景选择新的剪裁区 SetBoundsRect 设置指定设备场景的边界矩形 SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换） SetMapMode 设置指定设备场景的映射模式 SetRectRgn 设置区域为指定的矩形 SetViewportExtEx 设置设备场景视口范围 SetViewportOrgEx 设置设备场景视口起点 SetWindowExtEx 设置指定设备场景窗口范围 SetWindowOrgEx 设置指定设备场景窗口起点 SetWindowRgn 设置窗口区域 SetWorldTransform 设置世界转换 ValidateRgn 激活窗口中指定区域，把它从刷新区移走 WindowFromDC 取回与某一设备场景相关的窗口的句柄 1.7 API之进程和线程函数 函数名 作用 CancelWaitableTimer 这个函数用于取消一个可以等待下去的计时器操作 CallNamedPipe 这个函数由一个希望通过管道通信的一个客户进程调用 ConnectNamedPipe 指示一台服务器等待下去，直至客户机同一个命名管道连接 CreateEvent 创建一个事件对象 CreateMailslot 创建一个邮路。返回的句柄由邮路服务器使用（收件人） CreateMutex 创建一个互斥体（MUTEX） CreateNamedPipe 创建一个命名管道。返回的句柄由管道的服务器端使用 CreatePipe 创建一个匿名管道 CreateProcess 创建一个新进程（比如执行一个程序） CreateSemaphore 创建一个新的信号机 CreateWaitableTimer 创建一个可等待的计时器对象 DisconnectNamedPipe 断开一个客户与一个命名管道的连接 DuplicateHandle 在指出一个现有系统对象当前句柄的情况下，为那个对象创建一个新句柄 ExitProcess 中止一个进程 FindCloseChangeNotification 关闭一个改动通知对象 FindExecutable 查找与一个指定文件关联在一起的程序的文件名 FindFirstChangeNotification 创建一个文件通知对象。该对象用于监视文件系统发生的变化 FindNextChangeNotification 重设一个文件改变通知对象，令其继续监视下一次变化 FreeLibrary 释放指定的动态链接库 GetCurrentProcess 获取当前进程的一个伪句柄 GetCurrentProcessId 获取当前进程一个唯一的标识符 GetCurrentThread 获取当前线程的一个伪句柄 GetCurrentThreadId 获取当前线程一个唯一的线程标识符 GetExitCodeProces 获取一个已中断进程的退出代码 GetExitCodeThread 获取一个已中止线程的退出代码 GetHandleInformation 获取与一个系统对象句柄有关的信息 GetMailslotInfo 获取与一个邮路有关的信息 GetModuleFileName 获取一个已装载模板的完整路径名称 GetModuleHandle 获取一个应用程序或动态链接库的模块句柄 GetPriorityClass 获取特定进程的优先级别 GetProcessShutdownParameters 调查系统关闭时一个指定的进程相对于其它进程的关闭早迟情况 GetProcessTimes 获取与一个进程的经过时间有关的信息 GetProcessWorkingSetSize 了解一个应用程序在运行过程中实际向它交付了多大容量的内存 GetSartupInfo 获取一个进程的启动信息 GetThreadPriority 获取特定线程的优先级别 GetTheardTimes 获取与一个线程的经过时间有关的信息 GetWindowThreadProcessId 获取与指定窗口关联在一起的一个进程和线程标识符 LoadLibrary 载入指定的动态链接库，并将它映射到当前进程使用的地址空间 LoadLibraryEx 装载指定的动态链接库，并为当前进程把它映射到地址空间 LoadModule 载入一个Windows应用程序，并在指定的环境中运行 MsgWaitForMultipleObjects 等侯单个对象或一系列对象发出信号。如返回条件已经满足，则立即返回 SetPriorityClass 设置一个进程的优先级别 SetProcessShutdownParameters 在系统关闭期间，为指定进程设置他相对于其它程序的关闭顺序 SetProcessWorkingSetSize 设置操作系统实际划分给进程使用的内存容量 SetThreadPriority 设定线程的优先级别 ShellExecute 查找与指定文件关联在一起的程序的文件名 TerminateProcess 结束一个进程 WinExec 运行指定的程序 1.7 API之网络函数 函数名 作用 WNetAddConnection 创建同一个网络资源的永久性连接 WNetAddConnection2 创建同一个网络资源的连接 WNetAddConnection3 创建同一个网络资源的连接 WNetCancelConnection 结束一个网络连接 WNetCancelConnection2 结束一个网络连接 WNetCloseEnum 结束一次枚举操作 WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接 WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接 WNetEnumResource 枚举网络资源 WNetGetConnection 获取本地或已连接的一个资源的网络名称 WNetGetLastError 获取网络错误的扩展错误信息 WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称 WNetGetUser 获取一个网络资源用以连接的名字 WNetOpenEnum 启动对网络资源进行枚举的过程 2. 安装和基本使用2.1 安装1python -m pip install pypiwin32 2.2 基本使用123456789101112131415161718192021hwnd = win32gui.FindWindow(&quot;类名&quot;, &quot;标题名&quot;) # 使用spy++查询窗口句柄的信息# 修改窗口大小win32gui.MoveWindow(hwnd, 100, 100, 200, 200, True) # 设置前台后台win32gui.SetForegroundWindow(hwnd)win32gui.SetBkMode(hwnd, win32con.TRANSPARENT)# 获取鼠标当前坐标win32api.GetCursorPos()# 将鼠标移动到某坐标处win32api.SetCursorPos((100,100))# 通过坐标获取句柄win32api.WindowFromPoint(win32api.GetCursorPos())# 根据窗口句柄id获取ClassNamewin32gui.GetClassName(hwnd)# 获取窗口标题win32gui.GetWindowText(hwnd)# 获取窗口坐标win32gui.GetWindowRect(hwnd)# 模拟点击win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 200, 200, 0, 0) 使用管理员权限启动python脚本12345678910111213141516171819202122232425262728def admin(func): def wrap(): def is_admin(): try: return ctypes.windll.shell32.IsUserAnAdmin() except: return False if is_script(): func() elif is_admin(): func() else: params = &#x27; &#x27;.join([&#x27;&quot;&#123;&#125;&quot;&#x27;.format(x) for x in sys.argv]) # 将启动参数传递给脚本 ctyps.windll.shell32.ShellExecuteW(None, &#x27;runas&#x27;, sys.executable, params, None, 1) return wrap### main.py@admindef main(): print(&#x27;init&#x27;)if __name__ == &#x27;__main__&#x27;: main() 参考 http://timgolden.me.uk/pywin32-docs/contents.html https://www.cnblogs.com/zoro-robin/p/5591185.html Shell_NotifyIcon Windows常用API","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"stockstats","slug":"Python/stockstats","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/stockstats/","link":"","permalink":"http://shjlone.github.io/wiki/Python/stockstats/","excerpt":"","text":"对pandas进行了封装 https://github.com/jealous/stockstats","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"struct模块","slug":"Python/struct模块","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/struct模块/","link":"","permalink":"http://shjlone.github.io/wiki/Python/struct%E6%A8%A1%E5%9D%97/","excerpt":"","text":"struct模块主要二进制和结构体之间的互相转化。在业务场景中，socket数据的处理会使用到。纯文本是无法进行传输到，因为不同系统硬件的存储方式是不一样的。这个时候使用struct可以按照某种规则进行pack处理成二进制数据，另一端接收到时按照约定进行unpack成相应数据。 常用API 函数 return explain pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回. pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块) unpack(fmt,v1,v2…..) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果 pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果 calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式 Hello Worldvalues = (1, b&#39;abc&#39;, 2.5) s = struct.Struct(&#39;I3sf&#39;) # 声明每个值的类型，I表示整型、3s表示长度为3的字符串、f表示浮点型 packed_data = s.pack(*values) print(packed_data) unpacked_data = s.unpack(packed_data) print(type(unpacked_data), unpacked_data) 字节顺序，大小，对齐默认情况下，C语言类型以机器的本地格式和字节顺序表示。 Character（字符） Byte order（字节顺序） Size Alignment @(默认) 本机 本机 本机,凑够4字节 = 本机 标准 none,按原字节数 &lt; 小端 标准 none,按原字节数 &gt; 大端 标准 none,按原字节数 ! network(大端) 标准 none,按原字节数 格式字符 文件格式 C 类型 Python数据类型 Standard size 注释 x pad byte no value c char bytes of length 1 1 b signed char integer 1 (1),(3) B unsigned char integer 1 (3) ? _Bool bool 1 (1) h short integer 2 (3) H unsigned short integer 2 (3) i int integer 4 (3) I unsigned int integer 4 (3) l long integer 4 (3) L unsigned long integer 4 (3) q long long integer 8 (2), (3) Q unsigned long long integer 8 (2), (3) n ssize_t integer (4) N size_t integer (4) e (7) float 2 (5) f float float 4 (5) d double float 8 (5) s char[] bytes p char[] bytes P void * integer (6) 实例：12 参考 https://docs.python.org/zh-cn/3.7/library/struct.html https://docs.python.org/3/library/struct.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"tornado","slug":"Python/tornado","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/tornado/","link":"","permalink":"http://shjlone.github.io/wiki/Python/tornado/","excerpt":"","text":"基本API使用Application RequestHandler 参考https://tornado-zh.readthedocs.io/zh/latest/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Python虚拟环境配置","slug":"Python/Python虚拟环境配置","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-10T10:10:09.623Z","comments":true,"path":"wiki/Python/Python虚拟环境配置/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"虚拟环境的用途不需要完整的安装一遍依赖库，类似gradle的版本管理。比如你需要同时使用Rx1.6和Rx3.1，要么整两份Python环境，要么使用Virtualenv。 PyCharm中使用 选择File-&gt;New Project 选择Pure Python，点击Project Interpreter：New Virtualenv environment 选择依赖的解释器，勾选Inherit global site-packages，这样会继承原来的第三方库，勾选Make available to all projects，所有的项目都可用。 使用Python命令12345678910111213安装virtualenvpip install virtualenv安装虚拟环境，同时将原有依赖添加到虚拟环境中virtualenv --system-site-packages venv安装虚拟环境，不添加任务依赖，默认值virtualenv --no-site-packages venv在Scripts目录中activate命令可进行交互模式deactivate退出交互模式 参考 https://www.jianshu.com/p/dcb281ee564e https://virtualenv.pypa.io/en/latest/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"RxPY学习笔记","slug":"Python/RxPy学习笔记","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/RxPy学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Python/RxPy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本概念参考这里，Python的版本也是根据这些概念，通过使用自己的特性实现。但由于种种原因，Python的不同版本间变化很大。可以参考这里。 基本的用法可以参考文档和源码中的test，这里只记录一些自己遇到的问题和解决方案 官方使用文档翻译 安装如果使用V3.x版本： 1pip install rx 如果使用1.6的版本 1pip install rx==1.6.1 基本概念RXPY，使用可观察序列，查询操作符组合，可异步化，基于事件的一套Python库。使用Rx，开发者可以使用Observables来表示异步数据流，使用operators查询异步数据流，使用Schedulers对数据/事件流进行异步参数化。 使用Rx，你可以表示多个异步数据流，使用观察者（Observer）对象来订阅（subscribe）事件流。当事件发生时可观察者（Observable）通知订阅者。你可以在Observable和Observer之间放置各种转换。 因为Observable队列是数据流，你可以使用相关操作符进行链式操作。你可以filter，map，reduce，compose，基于时间的操作，等等。除此之外，还有许多其他特定于响应流的操作符允许编写功能强大的查询。取消、异常和同步也可以通过专用的操作符处理。 开始Observable是ReactiveX的核心类型。它串行的添加元素，像排放系统一样，通过一系列的操作直到最后传递到Observer，在那里它们被消费。 基于推(而不是基于拉)的迭代为表达代码和并发提供了强大的新可能性。因为一个Observable将事件当作数据，也将数据当作事件。 有很多种方式创建Obserable，你可以使用create（）工厂方法，传递一个函数给他。 - on_next在Observable发射一个元素时被调用 - on_completed在Obserable完成时被调用 - on_error在Obserable发生错误时被调用 这三个回调是可选的。 让我们看一个例子： 123456789101112131415161718from rx import createdef push_five_strings(observer, scheduler): observer.on_next(&quot;Alpha&quot;) observer.on_next(&quot;Beta&quot;) observer.on_next(&quot;Gamma&quot;) observer.on_next(&quot;Delta&quot;) observer.on_next(&quot;Epsilon&quot;) observer.on_completed()source = create(push_five_strings)source.subscribe( on_next = lambda i: print(&quot;Received &#123;0&#125;&quot;.format(i)), on_error = lambda e: print(&quot;Error Occurred: &#123;0&#125;&quot;.format(e)), on_completed = lambda: print(&quot;Done!&quot;),) Observable通过create创建，push_five_strings被调用。这个函数发射了五个元素。subscribe中实现了三个回调函数。输出结果为： 123456Received AlphaReceived BetaReceived GammaReceived DeltaReceived EpsilonDone! of工厂函数，接收list参数，会依此发射它们，如果忽略completion和error，subscribe可以支传一个参数 12345678910111213141516from rx import ofsource = of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;)source.subscribe( on_next = lambda i: print(&quot;Received &#123;0&#125;&quot;.format(i)), on_error = lambda e: print(&quot;Error Occurred: &#123;0&#125;&quot;.format(e)), on_completed = lambda: print(&quot;Done!&quot;),)输出结果：Received AlphaReceived BetaReceived GammaReceived DeltaReceived Epsilon 操作符和链接你可以使用超过130个操作符来导出新的Observables，每个操作符会生产一个Observable，它会以管道的形式改变原来的Observable。比如，我们使用map()处理每个字符串的长度，然后filter()来过滤长度超过5的元素。 123456789101112131415from rx import of, operators as opsource = of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;)composed = source.pipe( op.map(lambda s: len(s)), op.filter(lambda i: i &gt;= 5))composed.subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value)))Received 5Received 5Received 5Received 7 还可以使用以下方式将整个操作链接起来，还能减少临时变量的产生 123456from rx import of, operators as opof(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( op.map(lambda s: len(s)), op.filter(lambda i: i &gt;= 5)).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 自定义操作符随着操作符链的发展，为了提高代码的可读性，须对链进行拆分。新的操作符被实现为函数，可以直接在管道操作符中使用。当一个操作符被实现为其他操作符的组合时，由于管道函数的存在，实现非常简单 123456789101112import rxfrom rx import operators as opsdef length_more_than_5(): return rx.pipe( ops.map(lambda s: len(s)), ops.filter(lambda i: i &gt;= 5), )rx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( length_more_than_5()).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 也可以自己创建一个操作符，以下操作符实现了将字符串转换为小写的功能 12345678910111213141516171819import rxdef lowercase(): def _lowercase(source): def subscribe(observer, scheduler = None): def on_next(value): observer.on_next(value.lower()) return source.subscribe( on_next, observer.on_error, observer.on_completed, scheduler) return rx.create(subscribe) return _lowercaserx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( lowercase() ).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 并发控制为了实现并发，你要使用两个操作符：subscribe_on和observe_on。两者都需要Scheduler来提供线程给订阅者工作。ThreadPoolScheduler是一个重用线程的好选择。 GIL可能会破坏并发性能，因为它阻止多个线程同时访问同一行代码。像NumPy这样的库可以在释放GIL时减轻这种并行密集计算的负担。RxPy还可以在某种程度上减少线程重叠。一定要用并发性测试您的应用程序，并确保有性能增益. subscribe_on()指示链开始处的源Observable序使用哪个调度器(不管您将该操作符放在哪里)。不过，observe_on()会在这个时候切换到不同的调度程序，有效地将发射从一个线程转移到另一个线程。一些工厂函数和操作符，如interval()和delay()，已经有了默认的调度程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import multiprocessingimport randomimport timefrom threading import current_threadimport rxfrom rx.scheduler import ThreadPoolSchedulerfrom rx import operators as opsdef intense_calculation(value): # sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation time.sleep(random.randint(5, 20) * 0.1) return value# calculate number of CPUs, then create a ThreadPoolScheduler with that number of threadsoptimal_thread_count = multiprocessing.cpu_count()pool_scheduler = ThreadPoolScheduler(optimal_thread_count)# Create Process 1rx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( ops.map(lambda s: intense_calculation(s)), ops.subscribe_on(pool_scheduler)).subscribe( on_next=lambda s: print(&quot;PROCESS 1: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, s)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;PROCESS 1 done!&quot;),)# Create Process 2rx.range(1, 10).pipe( ops.map(lambda s: intense_calculation(s)), ops.subscribe_on(pool_scheduler)).subscribe( on_next=lambda i: print(&quot;PROCESS 2: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, i)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;PROCESS 2 done!&quot;),)# Create Process 3, which is infiniterx.interval(1).pipe( ops.map(lambda i: i * 100), ops.observe_on(pool_scheduler), ops.map(lambda s: intense_calculation(s)),).subscribe( on_next=lambda i: print(&quot;PROCESS 3: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, i)), on_error=lambda e: print(e),)input(&quot;Press any key to exit\\n&quot;) IO异步 许多异步框架都支持IO异步，RxPY中使用相关连的schedulers。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from collections import namedtupleimport asyncioimport rximport rx.operators as opsfrom rx.subject import Subjectfrom rx.scheduler.eventloop import AsyncIOSchedulerEchoItem = namedtuple(&#x27;EchoItem&#x27;, [&#x27;future&#x27;, &#x27;data&#x27;])def tcp_server(sink, loop): def on_subscribe(observer, scheduler): async def handle_echo(reader, writer): print(&quot;new client connected&quot;) while True: data = await reader.readline() data = data.decode(&quot;utf-8&quot;) if not data: break future = asyncio.Future() observer.on_next(EchoItem( future=future, data=data )) await future writer.write(future.result().encode(&quot;utf-8&quot;)) print(&quot;Close the client socket&quot;) writer.close() def on_next(i): i.future.set_result(i.data) print(&quot;starting server&quot;) server = asyncio.start_server(handle_echo, &#x27;127.0.0.1&#x27;, 8888, loop=loop) loop.create_task(server) sink.subscribe( on_next=on_next, on_error=observer.on_error, on_completed=observer.on_completed) return rx.create(on_subscribe)loop = asyncio.get_event_loop()proxy = Subject()source = tcp_server(proxy, loop)aio_scheduler = AsyncIOScheduler(loop=loop)source.pipe( ops.map(lambda i: i._replace(data=&quot;echo: &#123;&#125;&quot;.format(i.data))), ops.delay(5.0)).subscribe(proxy, scheduler=aio_scheduler)loop.run_forever()print(&quot;done&quot;)loop.close() 默认的Scheduler 有多种方式选额scheduler。第一种是给操作符提供scheduler。但当有多个操作符时，可能会被忽略。所以第二种方式时提供默认的scheduler。 123source.pipe( ...).subscribe(proxy, scheduler=my_default_scheduler) 操作符选择scheduler的方式如下： 如果给操作符提供了scheduler，选择它 如果默认scheduler有提供，选择它 否则选择自带的 迁移https://rxpy.readthedocs.io/en/latest/migration.html 从RxPY v1迁移到v3 操作符创建Observable 操作符 | 描述|— | —|create | 创建一个Observableempty | 创建空的Obserbale，发射空元素，马上结束never |throw | 创建一个立马抛出错误的Observablefrom_ | 转换其他数据或对象给Observableinterval | 创建一个间隔执行的Observablejust |range | 创建一个整数队列的Observablerepeat_value | 重复发送特殊元素或队列元素start |timer | 转换Observables 操作符 | 描述|— | —|buffer |flat_map |group_by |map |scan |window | 过滤Observables 操作符 描述 debounce distinct element_at filter first ignore_elements last sample skip skip_last take take_last 结合Observables 操作符 描述 combine_latest join merge start_with switch_latest zip 错误处理 操作符 描述 catch retry 实用操作符 操作符 描述 delay do materizlize dematerialize observe_on subscribe subscribe_on time_interval timeout timestamp 条件和布尔操作符 操作符 描述 all amb contains default_if_empty sequence_equal skip_until skip_while take_until take_while 数学相关操作符 操作符 描述 average concat count max min reduce sum 可连接Observable操作符 操作符 描述 connect publish ref_count replay 额外的阅读RxPY源码仓库包含实例notebooks ReactiveX官方地址和文档： Introduction Tutorials Operators 一些商业内容可以免费获得它们相关联的示例代码 Packt Reactive Programming in Python RxPY 3.0.0取消了对backpressure的支持，以下是已知的支持backpress的社区项目 rxbackpressure rxpy extension rxpy_backpressure observer decorators 商业资源 O’Reilly Video O’Reilly has published the video Reactive Python for Data Science which is available on both the O’Reilly Store as well as O’Reilly Safari. This video teaches RxPY from scratch with applications towards data science, but should be helpful for anyone seeking to learn RxPY and reactive programming. Packt Video Packt has published the video Reactive Programming in Python, available on Packt store. This video teaches how to write reactive GUI and network applications. 如何在PyQt5中使用scheduler，在非主线程中执行某个操作，然后回到UI线程执行另一个操作。12345rx.from_list([1, 2, 3, 4]).pipe(operators.map(add), operators.subscribe_on(pool_scheduler), operators.observe_on(QtThreadSafeScheduler(QtCore))).subscribe( on_next=lambda i: print(&quot;PROCESS 3: &#123;0&#125; &#123;1&#125;&quot;.format(threading.current_thread().name, i)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;Done!&quot;) ) 其中的QtThreadScheduler来自于https://github.com/jcafhe/RxPY 参考 Github官方地址 文档 https://rxmarbles.com","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"CFFI笔记","slug":"Python/cffi笔记","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/cffi笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Python/cffi%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"ctypes模块","slug":"Python/ctypes","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/ctypes/","link":"","permalink":"http://shjlone.github.io/wiki/Python/ctypes/","excerpt":"","text":"ctypes 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。 Hello World 编写C文件 编译C文件 编写Python文件、测试 1. 编写C文件1234567#include &lt;stdio.h&gt;int hello(const char* name) &#123; printf(&quot;~~~hello %s ! \\n&quot;, name); return 0;&#125; 2. 编译C文件不同平台生成不同格式的动态库，windows下为dll，linux下为so gcc -fPIC -shared hello_module.c -o hello_module.dylib 3. 编写Python文件123456import ctypesfrom ctypes import c_char_plib = ctypes.cdll.LoadLibrary(&quot;hello_module.dylib&quot;)lib.hello(c_char_p(bytes(&quot;world&quot;, &quot;utf-8&quot;))) 类型映射关系 ctypes C 类型 Python类型 c_bool _Bool bool (1) c_char char 单字符字节对象 c_wchar wchar_t 单字符字符串 c_byte char int c_ubyte unsigned char int c_short short int c_ushort unsigned short int c_int int int c_uint unsigned int int c_long long int c_ulong unsigned long int c_longlong __int64 或 long long int c_ulonglong unsigned __int64 或 unsigned long long int c_size_t size_t int c_ssize_t ssize_t 或 Py_ssize_t int c_float float float c_double double float c_longdouble long double float c_char_p char * (NUL terminated) 字节串对象或 None c_wchar_p wchar_t * (NUL terminated) 字符串或 None c_void_p void * int 或 None 回调函数1234567891011121314151617181920212223242526272829############## main.c ###############include &lt;stdint.h&gt;#include &lt;stdio.h&gt;struct mes_t&#123; uint32_t field1; uint32_t field2; void* data;&#125;;typedef int function_callback(struct mes_t* message );function_callback* my_callback;int function_one(function_callback fcb)&#123; //Set to a global variable for later use my_callback = fcb; //Declare object in stack struct mes_t mes; mes.field1 = 132; mes.field2 = 264; mes.data = NULL; //Pass pointer of object in stack, and print the return value printf(&quot;Got from python: %d\\n&quot;, my_callback( &amp;mes ) );&#125; 123456789101112131415161718192021222324252627282930313233############ main.py ################import ctypestestlib = ctypes.CDLL(&#x27;./testlib.so&#x27;)#Declare the data structureclass mes_t(ctypes.Structure): _fields_ = ( (&#x27;field1&#x27;, ctypes.c_uint32), (&#x27;field2&#x27;, ctypes.c_uint32), (&#x27;data&#x27;, ctypes.c_void_p))#Declare the callback type, since that is not stored in the librarycallback_type = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(mes_t) )def the_callback(mes_p): #dereference the pointer my_mes = mes_p[0] print &quot;I got a mes_t object! mes.field1=%r, mes.field2=%r, mes.data=%r&quot; \\ % (my_mes.field1, my_mes.field2, my_mes.data) #Return some random value return 999#Let the library know about the callback function by calling &quot;function_one&quot;result = testlib.function_one(callback_type(the_callback) )#########################gcc -shared -o testlib.so -fPIC main.cpython main.py 参考：http://blog.sina.com.cn/s/blog_6e22d8fb0102y462.html 线程状态和GILPython解释器不是完全线程安全的。为了支持多线程Python程序，有一个全局锁，称为global interpreter lock或GIL，它必须由当前线程持有才能安全访问Python对象。没有锁，即使最简单的操作也可能导致多线程程序中的问题：例如，当两个线程同时增加同一对象的引用计数时，引用计数可能最终只增加一次而不是两次。 释放GIL123Py_BEGIN_ALLOW_THREADS... Do some blocking I/O operation ...Py_END_ALLOW_THREADS 非Python创建的线程当使用专用的Python API（例如threading模块）创建线程时，线程状态会自动关联到它们，因此上面显示的代码是正确的。但是，当从C创建线程时（例如由具有自己的线程管理的第三方库），它们不持有GIL，也没有线程状态结构。 如果你需要从这些线程调用Python代码（通常这将是上述第三方库提供的回调API的一部分），你必须首先通过创建线程状态数据结构来注册这些线程和解释器，然后获取GIL，最后存储他们的线程状态指针，然后才能开始使用Python / C API。当你完成后，你应该重置线程状态指针，释放GIL，最后释放线程状态数据结构。 123456789PyGILState_STATE gstate;gstate = PyGILState_Ensure();/* Perform Python actions here. */result = CallSomeFunction();/* evaluate result or handle exception *//* Release the thread. No Python API allowed beyond this point. */PyGILState_Release(gstate); 释放GIL和非python创建的线程中调用python函数都没有测试成功… 参考 http://icejoywoo.github.io/2018/12/10/intro-python-ctyps.html https://anribras.github.io/tech/2019/01/03/python-ctypes%E6%80%BB%E7%BB%93/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"json解析库选择和使用","slug":"Python/json解析库选择和使用","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/json解析库选择和使用/","link":"","permalink":"http://shjlone.github.io/wiki/Python/json%E8%A7%A3%E6%9E%90%E5%BA%93%E9%80%89%E6%8B%A9%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"比较 simplejson：django的内置模块，如果没有C扩展加速，效率极其低下。 rapidjson： ujson：使用C语言实现 orjson：使用Rust语言实现 测试代码 12345678910111213141516171819202122232425262728from time import timeimport sysimport string num = int(sys.argv[1])lib = sys.argv[2] items = []for i in range(num): items.append(&#123;c:c for c in string.ascii_letters&#125;) start = time()if lib == &#x27;ujson&#x27;: import ujson ujson.dumps(items)elif lib == &#x27;rapidjson&#x27;: import rapidjson rapidjson.dumps(items)elif lib == &#x27;orjson&#x27;: import orjson orjson.dumps(items)else: import json json.dumps(items) print(time() - start)&gt;&gt;python 1000|10000|100000|1000000 json|ujson|rapidjson|orjson orjsongithub地址 安装 首先安装rust，从rust官网下载rustup-init.exe安装程序。选择安装nightly类型。参考。 安装orjson，pip install orjson 注意 orjson is tested for amd64 and aarch64 on Linux, macOS, and Windows. It may not work on 32-bit targets. ujson安装需要依赖C&amp;C++编译环境，参考https://github.com/statsmodels/statsmodels/issues/4160 参考 https://yanbin.blog/python-json-choose-ujson-if-necessary/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"pandas","slug":"Python/pandas","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/pandas/","link":"","permalink":"http://shjlone.github.io/wiki/Python/pandas/","excerpt":"","text":"数据分析清洗使用pandas，numpy。 http://pandas.pydata.org/ https://www.pypandas.cn/ Series 是带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。轴标签统称为索引。调用 pd.Series 函数即可创建 Series 1s = pd.Series(data, index=index) 上述代码中，data 支持以下数据类型： Python 字典 多维数组 标量值（如，5） index 是轴标签列表。不同数据可分为以下几种情况： 多维数组 data 是多维数组时，index 长度必须与 data 长度一致。没有指定 index 参数时，创建数值型索引，即 [0, …, len(data) - 1]。 12345678910111213141516171819202122In [3]: s = pd.Series(np.random.randn(5), index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])In [4]: sOut[4]: a 0.469112b -0.282863c -1.509059d -1.135632e 1.212112dtype: float64In [5]: s.indexOut[5]: Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], dtype=&#x27;object&#x27;)In [6]: pd.Series(np.random.randn(5))Out[6]: 0 -0.1732151 0.1192092 -1.0442363 -0.8618494 -2.104569dtype: float64 字典 12345678In [7]: d = &#123;&#x27;b&#x27;: 1, &#x27;a&#x27;: 0, &#x27;c&#x27;: 2&#125;In [8]: pd.Series(d)Out[8]: b 1a 0c 2dtype: int64 标量值 data 是标量值时，必须提供索引。Series 按索引长度重复该标量值。 12345678In [12]: pd.Series(5., index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])Out[12]: a 5.0b 5.0c 5.0d 5.0e 5.0dtype: float64 Series类似多维数组 1234567891011121314151617181920212223242526272829303132In [13]: s[0]Out[13]: 0.4691122999071863In [14]: s[:3]Out[14]: a 0.469112b -0.282863c -1.509059dtype: float64In [15]: s[s &gt; s.median()]Out[15]: a 0.469112e 1.212112dtype: float64In [16]: s[[4, 3, 1]]Out[16]: e 1.212112d -1.135632b -0.282863dtype: float64In [17]: np.exp(s)Out[17]: a 1.598575b 0.753623c 0.221118d 0.321219e 3.360575dtype: float64 矢量操作与对齐 Series 标签 名称属性 12345678910111213In [32]: s = pd.Series(np.random.randn(5), name=&#x27;something&#x27;)In [33]: sOut[33]: 0 -0.4949291 1.0718042 0.7215553 -0.7067714 -1.039575Name: something, dtype: float64In [34]: s.nameOut[34]: &#x27;something&#x27; DataFrame 是由多种类型的列构成的二维标签数据结构，类似于 Excel 、SQL 表，或 Series 对象构成的字典。DataFrame 是最常用的 Pandas 对象，与 Series 一样，DataFrame 支持多种类型的输入数据： 一维 ndarray、列表、字典、Series 字典 二维 numpy.ndarray 结构多维数组或记录多维数组 Series DataFrame 除了数据，还可以有选择地传递 index（行标签）和 columns（列标签）参数。传递了索引或列，就可以确保生成的 DataFrame 里包含索引或列。Series 字典加上指定索引时，会丢弃与传递的索引不匹配的所有数据。 没有传递轴标签时，按常规依据输入数据进行构建。","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"资源处理","slug":"PyQt/资源处理","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/PyQt/资源处理/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"Pillow","slug":"Python/Pillow","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/Python/Pillow/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Pillow/","excerpt":"","text":"Pillow是用于图像处理的库，可用于图像存储、图像显示、图像处理（改变大小、旋转等）。 基本使用123456789from PIL import Imageim = Image.open(&quot;test.png&quot;)print(im.format, im.size, im.mode)# format 这个属性标识了图像来源。如果图像不是从文件读取它的值就是None。# size属性是一个二元tuple，包含width和height（宽度和高度，单位都是px）。 # mode 属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes 有 “L” (luminance) 表示灰度图像, “RGB” 表示真彩色图像, and “CMYK” 表示出版图像。im.show() # 显示图像 转换文件格式到JPEG12345678910111213from __future__ import print_functionimport os, sysfrom PIL import Imagefor infile in sys.argv[1:]: f, e = os.path.splitext(infile) outfile = f + &quot;.jpg&quot; if infile != outfile: try: Image.open(infile).save(outfile) # save方法第二个参数可以指定文件格式 except IOError: print(&quot;cannot convert&quot;, infile) 创建 JPEG 缩略图12345678910111213141516from __future__ import print_functionimport os, sysfrom PIL import Imagesize = (128, 128)for infile in sys.argv[1:]: outfile = os.path.splitext(infile)[0] + &quot;.thumbnail&quot; if infile != outfile: try: im = Image.open(infile) im.thumbnail(size) im.save(outfile, &quot;JPEG&quot;) except IOError: print(&quot;cannot create thumbnail for&quot;, infile) 重要的一点是这个库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图片大小和压缩方式无关。 剪切，粘贴，合并图像1234567891011121314151617181920212223242526272829303132# 从图像中复制出一个矩形选区¶box = (100, 100, 400, 400)region = im.crop(box)# 矩形选区有一个4元元组定义，分别表示左、上、右、下的坐标。这个库以左上角为坐标原点，单位是px，所以上诉代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。# 处理复制的矩形选区并粘贴到原图region = region.transpose(Image.ROTATE_180)im.paste(region, box)# 分离和合并颜色通道r, g, b = im.split()im = Image.merge(&quot;RGB&quot;, (b, g, r))out = im.resize((128, 128)) # 缩放out = im.rotate(45) # 旋转# 过滤器from PIL import ImageFilterout = im.filter(ImageFilter.DETAIL)# 读取多帧im = Image.open(&quot;animation.gif&quot;)im.seek(1) # skip to the second frametry: while 1: im.seek(im.tell()+1) # 这里seek后，可显示当前帧，可转换成Qt中的QPixmap或者QIamge # do something to imexcept EOFError: pass # end of sequence 概念Bands（通道）每张图像都是由一个或者多个数据通道构成，PIL可以在单张图片中合成相同维数和深度的多个通道，如RGB有三个通道，而灰度图像则只有一个通道。getbands方法返回通道名字。 Mode（模式）图像的模式定义了图像中像素的类型和深度，它在图像中定义mode模式的概念，如： 1:1位像素，表示黑和白，占8bit，在图像表示中称为位图 L：表示黑白之间的灰度，占8bit像素 p：8位像素，使用调色版映射 RGB：为真彩色，占用3x8位像素，其中R为red红色，G为green绿色，B为blue蓝色，三原色叠加形成的色彩变化，如三通道都为0则代表黑色，都为255则代表白色 RGBA：为带透明蒙版的真彩色，其中的A为alpha透明度，占用4x8位像 CMYK (4x8-bit 像素, color separation) YCbCr (3x8-bit 像素, color video format) I (32-bit signed integer 像素) F (32-bit floating point 像素) Size（大小）size属性表达大小，返回一个元祖，分别为高、宽值。 Coordinates System（坐标系统）PIL使用笛卡尔像素坐标系统，图像的坐标从左上角开始（0,0），坐标值表示像素的角，它实际上位于（0.5,0.5）；python中坐标通常以2元组(X,Y)的形式传递，矩形表示为4元组（l_x,t_y,r_x,b_y），X轴从左到右，Y轴从上到下，顺序是从左上右下表示，从左上角开始，如一个800X600像素的图像矩形表示为（0,0,800,600），它实际上时左上角锁定，向右下延伸的。 Palatte（调色板）定义每一个像素的真实颜色 Info（信息）info属性包含了图片的一些信息，是一个字典对象。如果是一个动画类型的图片，则里面可包含duration，表示一帧画面的现实时间。 Filters（过滤器）提供不同类型的过滤器 NEAREST Pick the nearest pixel from the input image. Ignore all other input pixels. 最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR Use linear interpolation over a 2x2 environment in the input image. Note that in the current version of PIL, this filter uses a fixed input environment when downsampling. 双线性滤波。在输入图像的2x2矩阵上进行线性插值，，做下采样时该滤波器使用了固定输入模板 BICUBIC Use cubic interpolation over a 4x4 environment in the input image. Note that in the current version of PIL, this filter uses a fixed input environment when downsampling. 双立方滤波。在输入图像的4x4矩阵上进行立方插值，做下采样时该滤波器使用了固定输入模板 ANTIALIAS Calculate the output pixel value using a high-quality resampling filter (a truncated sinc) on all pixels that may contribute to the output value. In the current version of PIL, this filter can only be used with the resize and thumbnail methods. 平滑滤波，对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值，这个滤波器只用于改变尺寸和缩略图方法。ANTIALIAS滤波器是下采样，将大图转换为小图或左缩略图时唯一正确的滤波器，BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的 解析动画Gif、Webp12345678910image = Image.open(path)while image.tell() &lt; image.n_frames: image.seek(image.tell() + 1) # image.toqpixmap() 获取当前画面 # duration 表示一帧的显示时间 if &#x27;duration&#x27; in image.info.keys(): duration = image.info[&#x27;duration&#x27;] else: duration = 100 time.sleep(duration/1000) 参考 https://github.com/python-pillow/Pillow https://www.osgeo.cn/pillow/handbook/tutorial.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Python扩展","slug":"Python/Python Extending","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/Python/Python Extending/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python%20Extending/","excerpt":"","text":"官方文档：https://docs.python.org/zh-cn/3/extending/extending.html ** 什么时候要用扩展 性能瓶颈：比如某些计算在Python中很慢，比如GIL导致CPU只能使用单核。 代码保护：将核心代码放到更低层，增加反编译难度。 ** Hello World 步骤 编写C文件 编写包装文件 编写setup文件 编译、测试 1. 编写C文件12345678910//fib.c文件long long _fib(long long n)&#123; if(n &lt; 2) return n; else return _fib(n-1) + _fib(n-2);&#125;; 2. 编写包装文件12345678910111213141516171819202122232425262728293031323334353637383940414243//speedup_fib.c#include &lt;Python.h&gt; //导入基础的头文件//封装函数static PyObject *fib(PyObject *self, PyObject *args) &#123; // Arguments long long n; long long res; if (!PyArg_ParseTuple(args, &quot;l&quot;, &amp;n)) //转换输入参数类型给C return NULL; res = _fib(n);//调用函数 return Py_BuildValue(&quot;l&quot;, res);//结果转换成Python类型&#125;;//模块方法表static PyMethodDef SpeedupFibMethods[] = &#123; &#123;&quot;speedup_fib&quot;, (PyCFunction) fib, METH_VARARGS, &quot;fast fib&quot;&#125;, &#123;NULL, NULL, 0, NULL&#125;&#125;;static struct PyModuleDef speedup_fib_module = &#123; PyModuleDef_HEAD_INIT, &quot;speedup_fib&quot;,//模块名字 &quot;A module containing methods with faster fib.&quot;, -1, SpeedupFibMethods&#125;;//创建模块PyMODINIT_FUNC PyInit_speedup_fib() &#123; return PyModule_Create(&amp;speedup_fib_module);&#125; 3. 编写setup.py文件12345678910from distutils.core import setup, Extensionspeedup_fib_module = Extension(&#x27;speedup_fib&#x27;, sources=[&#x27;speedup_fib.c&#x27;])setup( name=&#x27;SpeedupFoo&#x27;, description=&#x27;A package containing modules for speeding up fib.&#x27;, ext_modules=[speedup_fib_module],) 4. 编译、测试 python setup.py build 编译成功后会在build文件夹生成动态库，windows下为pyd，linux下为so 编写测试脚本 123456789101112131415161718import timedef fib_recursive(n): if n &lt;= 1: return n return fib_recursive(n - 1) + fib_recursive(n - 2)start_ts = time.time()print(fib_recursive(35))print(time.time() - start_ts)from speedup_fib import speedup_fibstart_ts = time.time()print(speedup_fib(35))print(time.time() - start_ts) 基本概念实例代码","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Pyhon2跟Python3的区别","slug":"Python/Python2跟Python3的区别","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/Python/Python2跟Python3的区别/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python2%E8%B7%9FPython3%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"str和bytes基本概念 字节（Byte ）：是计算机信息技术用于计量存储容量的一种计量单位，作为一个单位来处理的一个二进制数字串，是构成信息的一个小单位。最常用的字节是八位的字节，即它包含八位的二进制数; 位(bit)：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数; 字节(byte)：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B(byte,字节)= 8bit(位); 字符：指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。 字符串：字符串是字符序列，它是一种抽象的概念，不能直接存储在硬盘 – 字节串是给计算机看的 ，给计算机传输或者保存的， 在Python中，程序中的文本都用字符串表示。 字节串：字节串是字节序列，它可以直接存储在硬盘， 字节串是给计算机看的 。它们之间的映射被称为编码/解码 – 字符串是给人看的，用来操作的。 字符集：为每一个字符分配一个唯一的ID（码位/码点/Code Point）。Unicode是字符集。 编码规则：将码位转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）。utf-8是编码规则。 12341 KB = 1024 B(字节)；1 MB = 1024 KB; (2^10 B)1 GB = 1024 MB; (2^20 B)1 TB = 1024 GB; (2^30 B) Python2中的str和unicode str:表示由bytes序列的字符串。 unicode:表示unicode码点序列的字符串。 12345678910111213141516171819202122&gt;&gt;&gt; a=&#x27;你好&#x27;&gt;&gt;&gt; a&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; b=u&#x27;你好&#x27;&gt;&gt;&gt; bu&#x27;\\u4f60\\u597d&#x27;&gt;&gt;&gt; print(a)你好&gt;&gt;&gt; print(b)你好&gt;&gt;&gt; a.__class__&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; b.__class__&lt;type &#x27;unicode&#x27;&gt;&gt;&gt;&gt; len(a)6&gt;&gt;&gt; len(b)2&gt;&gt;&gt; a.decode(&#x27;utf-8&#x27;)u&#x27;\\u4f60\\u597d&#x27;&gt;&gt;&gt; b.encode(&#x27;utf-8&#x27;)&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27; 总结： string直接用引号来表示，unicode在引号前加一个u。 直接输入的string常量会用系统缺省编码方式来编码。 len(string)返回string的字节数，len(unicode)返回的是字符数。 encode和decode使得str和unicode之间进行相互转换。 Python3中的str和byte str：str格式的定义变更为”Unicode类型的字符串“，也就是说在默认情况下，被引号框起来的字符串，是使用Unicode编码的。也就是说unicode类型在python3中没有了，python3中的str就相当于python2中的unicode。 bytes：bytes 函数返回一个新的 bytes 对象，该对象是一个 0 &lt;= x &lt; 256 区间内的整数不可变序列。它是 bytearray 的不可变版本。bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。 bytearray：可变的子节数组。 1234567891011121314&gt;&gt;&gt; a=&#x27;你好&#x27;&gt;&gt;&gt; a&#x27;你好&#x27;&gt;&gt;&gt; type(a)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; b = bytes(a, encoding=&#x27;utf-8&#x27;)&gt;&gt;&gt; bb&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; type(b)&lt;class &#x27;bytes&#x27;&gt;&gt;&gt;&gt; a.encode()b&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; b.decode()&#x27;你好&#x27;","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Python多线程","slug":"Python/Python多线程编程","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/Python多线程编程/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Python代码的执行由虚拟机来控制。Python再主循环中，同时只有一个线程再执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序再CPU中运行。 对Python虚拟机的访问由全局解释器锁（global interpreter lock）来控制，正是这个锁能保证同一时刻只有一个线程在运行。 参考 https://docs.python.org/zh-cn/3/library/threading.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"编译PyQt5","slug":"PyQt/编译PyQt5","date":"2021-06-07T01:45:07.547Z","updated":"2021-06-07T01:45:07.547Z","comments":true,"path":"wiki/PyQt/编译PyQt5/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E7%BC%96%E8%AF%91PyQt5/","excerpt":"","text":"目录： 官方文档翻译 编译MinGW版本 编译VS版本 下载SIPSIP必现在编译和使用PyQt5之前安装。你可以从https://www.riverbankcomputing.com/software/sip/download使用最新的发布版本的源码。 SIP的安装说明请参阅http://pyqt.sourceforge.net/Docs/sip4/installation.html 当编译v5.11或以上的版本时，你必须配饰SIP来创建私有的备份。可以使用下面的命令： python configure.py –sip-module PyQt5.sip –no-tools 下载PyQt5你可以从https://www.riverbankcomputing.com/software/pyqt/download5下载最新的源码 如果你使用商业版的PyQt5，则需要购买商业授权，并下载属于你的pyqt-commercial.sip授权文件 配置PyQt5解压后，你应该阅读相应平台的README文件。 如果你使用商业版的PyQt5，你必须复制你的pyqt-commercial.sip授权文件到sip文件夹，或者使用–license-dir参数指定。 你需要确定你的环境变量是否正确。 为了配置构建PyQt5，你需要运行以下脚本： 1python3 configure.py 脚本完整的参数属性如下： -h, --help 展示帮助信息 --allow-sip-warnings 5.9.1版本的新特性。 Normally any warning message generated by sip is treated as an error. This option causes warning messages to be considered non-fatal. It is normally only required if a later version of sip is being used that has deprecated a feature used by this version of PyQt5. --assume-shared Normally Qt is checked to see if it has been built as shared libraries. Some Linux distributions configure their Qt builds to make this check unreliable. This option ignores the result of the check and assumes that Qt has been built as shared libraries. --bindir pyuic5, pyrcc5 and pylupdate5工具将会安装到的目录。 --concatenate The C++ source files for a Python module will be concatenated. This results in significantly reduced compilation times. Most, but not all, C++ compilers can handle the large files that result. See also the –concatenate-split option. --concatenate-split If the –concatenate option is used to concatenate the C++ source files then this option determines how many files are created. The default is 1. --configuration 指定配置文件 contains the configuration of the PyQt5 build to be used instead of dynamically introspecting the system and is typically used when cross-compiling. See Configuring with Configuration Files. --confirm-license 使用授权证书 Using this confirms that you accept the terms of the PyQt5 license. If it is omitted then you will be asked for confirmation during configuration. --dbus 根据/dbus目录找到dbus-python.h头文件 The dbus-python.h header file of the dbus-python package can be found in the directory/dbus. --debug The PyQt5 modules will be built with debugging symbols. On Windows configure.py must be run using a debug version of Python. --designer-plugindir 指定Qt Designer安装目录 --destdir 指定PyQt5安装目录。默认安装在Python的site-packages目录。如果你使用这个属性，则PYTHONPATH必须指定在 The PyQt5 Python package will be installed in the directory. The default is the Python installation’s site-packages directory. If you use this option then the PYTHONPATH environment variable must include. --disable 5.5.1新特性 Normally all PyQt5 modules are enabled and are built if the corresponding Qt library can be found. This option will suppress the check for &gt;. The option may be specified any number of times. --disable-feature 5.10.1新特性 A PyQt5 module may be configured differently depending on the corresponding Qt configuration. This takes the form of a set of features that may be disabled. Normally this is determined automatically. This option will explicitly disable the &gt; feature. The option may be specified any number of times. --enable Normally all PyQt5 modules are enabled and are built if the corresponding Qt library can be found. Using this option only those modules specifically enabled will be built. The option may be specified any number of times. Note that using this option suppresses the checks that are normally made to determine how the module should be configured, i.e. which features should be disabled. --license-dir 指定授权证书的目录 The license files needed by the commercial version of PyQt5 can be found in the directory. --link-full-dll 5.8版本新特性 On Windows the full Python API and the limited API (as used by PyQt) are implemented in different DLLs. Normally the limited DLL is linked (unless a debug version of the Python interpreter is being used to run configure.py). This option forces the full API DLL to be linked instead. --no-designer-plugin Qt Designer 插件将不会被编译 --no-dist-info 5.11新特性 This disables the creation of the PEP 376 .dist-info directory. Starting with this version a .dist-info directory is created. This contains meta-data about the installation including version information for dependent packages. It also means that pip can be used to uninstall the package. --no-docstrings PyQt5模块不会包含自动产生的文档字符串 The PyQt5 modules will not contain automatically generated docstrings. --no-python-dbus The Qt support for the standard Python DBus bindings is disabled. --no-qml-plugin qmlscene 插件不会被编译 --no-qsci-api The PyQt5.api QScintilla API file is not installed even if QScintilla does appear to be installed. --no-sip-files The .sip files for the PyQt5 modules will not be installed. --no-stubs New in version 5.6. The PEP 484 type hint stub files for the PyQt5 modules will not be installed. This option is ignored (and the stub files are not installed) for versions of Python earlier than v3.5. --no-tools New in version 5.3. The pyuic5, pyrcc5 and pylupdate5 tools will not be built. --no-timestamp Normally the header comments of each generated C/C++ source file includes a timestamp corresponding to when the file was generated. This option suppresses the inclusion of the timestamp. --protected-is-public On certain platforms the size of PyQt5 modules can be significantly reduced by redefining the C++ protected keyword as public during compilation. This option enables this behaviour and is the default on Linux and macOS. --protected-not-public The default redefinition of protected to public during compilation on Linux and macOS is disabled. --pyuic5-interpreter is the name of the Python interpreter used in the pyuic5 wrapper. The default is platform dependent. --qmake Qt’s qmake program is used to determine how your Qt installation is laid out. Normally qmake is found on your PATH. This option can be used to specify a particular instance of qmake to use. --qml-debug New in version 5.8. Enable the QML debugging infrastructure. This should not be enabled in a production environment. --qml-plugindir The Python plugin for qmlscene will be installed in the directory. --qsci-api The PyQt5.api QScintilla API file is installed even if QScintilla does not appear to be installed. This option is implied if the –qsci-api-destdir option is specified. --qsci-api-destdir The QScintilla API file will be installed in the python subdirectory of the api subdirectory of the directory. --qtconf-prefix New in version 5.6. A qt.conf file is embedded in the PyQt5.QtCore module with Prefix set to which is assumed to be relative to the directory that the PyQt5.QtCore module will be installed in. --sip The sip program is used to generate PyQt5’s C++ source code. Normally sip is found on your PATH. This option can be used to specify a particular instance of sip to use. --sip-incdir The sip.h header file can be found in the directory. --sipdir The .sip files for the PyQt5 modules will be installed in the directory. --spec The argument -spec SPEC will be passed to qmake. The default behaviour is platform specific. On Windows configure.py will choose the value that is correct for the version of Python that is being used. (However if you have built Python yourself then you may need to explicitly specify .) On macOS configure.py will try and avoid macx-xcode if possible.) --static The PyQt5 modules will be built as static libraries. This is useful when building a custom interpreter with the PyQt5 modules built in to the interpreter. --stubsdir New in version 5.6. The PEP 484 type hint stub files for the PyQt5 modules will be installed in the directory. By default they will be stored in the same directory where (by default) the corresponding extension modules would be installed. This option is ignored (and the stub files are not installed) for versions of Python earlier than v3.5. --sysroot New in version 5.3. is the name of an optional directory that replaces sys.prefix in the names of other directories (specifically those specifying where the various PyQt5 components will be installed and where the Python include and library directories can be found). It is typically used when cross-compiling or when building a static version of PyQt5. See Configuring with Configuration Files. --target-py-version New in version 5.3. is the major and minor version (e.g. 3.4) of the version of Python being targetted. By default the version of Python being used to run the configure.py script is used. It is typically used when cross-compiling. See Configuring with Configuration Files. --trace The generated PyQt5 modules contain additional tracing code that is enabled using SIP’s sip.settracemask() function. --verbose Compiler commands and any output issued during configuration is displayed instead of being suppressed. Use this if configure.py is having problems to see what exactly is going wrong. --version 显示版本号 编译PyQt5make make install 配置配置文件配置文件的格式如下： 使用[]来表示一部分的名字 配置的条目为单一的行，用=分开的键值对 在值中可以使用%(name)的方式来嵌套其他的值 注释需要以#开头 空白行被忽略 配置文件通过定义不同的[]部分来使用不同的版本。configure.py将会选择对应的Qt版本。比如，如果配置文件包含Qt v5.1和Qt v5.3，你使用Qt v5.2.1，则会选择Qt v5.1的版本。 configure.py提供了以下预制变量： py_major 对应Python安装最大的版本 py_minor 对应Python安装最小的版本 sysroot 系统根目录，可以使用–sysroot选项指定 下面是一个配置文件的实例： # The target Python installation. py_platform = linux py_inc_dir = %(sysroot)/usr/include/python%(py_major).%(py_minor) py_pylib_dir = %(sysroot)/usr/lib/python%(py_major).%(py_minor)/config py_pylib_lib = python%(py_major).%(py_minor)mu # The target PyQt installation. pyqt_module_dir = %(sysroot)/usr/lib/python%(py_major)/dist-packages pyqt_bin_dir = %(sysroot)/usr/bin pyqt_sip_dir = %(sysroot)/usr/share/sip/PyQt5 pyuic_interpreter = /usr/bin/python%(py_major).%(py_minor) pyqt_disabled_features = PyQt_Desktop_OpenGL PyQt_qreal_double # Qt configuration common to all versions. qt_shared = True [Qt 5.1] pyqt_modules = QtCore QtDBus QtDesigner QtGui QtHelp QtMultimedia QtMultimediaWidgets QtNetwork QtOpenGL QtPrintSupport QtQml QtQuick QtSensors QtSerialPort QtSql QtSvg QtTest QtWebKit QtWebKitWidgets QtWidgets QtXmlPatterns _QOpenGLFunctions_ES2 下面的值可以在配置文件中指定： qt_shared 设置Qt是否是动态共享文件，默认值为False py_platform Python目标平台 py_debug is set if a debug version of the target Python is being used. py_inc_dir is the target Python include directory, i.e. the directory containing the Python.h file. py_pylib_dir is the target Python library directory. py_pylib_lib is the target Python interpreter library. It should not include any platform-specific prefix or suffix. pyqt_disabled_features is the space separated list of features (as defined by SIP’s %Feature directive) that should be disabled. pyqt_module_dir is the target directory where the PyQt5 modules will be installed. It can be overridden by the –destdir option. pyqt_modules is the space separated list of PyQt5 modules that will be built. It can be overridden by the –enable option. pyqt_bin_dir is the name of the target directory where the PyQt5 related executables will be installed. It can be overridden by the –bindir option. pyqt_sip_dir is the name of the target directory where the PyQt5 .sip files will be installed. It can be overridden by the –sipdir option. pyuic_interpreter is the name of the Python interpreter (as it would be called from the target system) that will be used to run pyuic5. It can be overridden by the –pyuic5-interpreter option. 参考 http://pyqt.sourceforge.net/Docs/PyQt5/installation.html","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://shjlone.github.io/tags/PyQt5/"}]},{"title":"编译QtWebEngine","slug":"PyQt/编译QtWebEngine","date":"2021-06-07T01:45:07.547Z","updated":"2021-06-07T01:45:07.547Z","comments":true,"path":"wiki/PyQt/编译QtWebEngine/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E7%BC%96%E8%AF%91QtWebEngine/","excerpt":"","text":"由于QtWebEngine本身并不支持H.264编码的音视频，现自行编译，整个过程如下： 依赖准备VS2015 Update3 下载地址 安装Qt 5.10.1：安装的时候选择带源码 下载地址 安装Python 2.7.5以上版本 下载地址 Perl 下载地址 Bison和Flex 下载地址 Gperf 下载地址 Windows SDK 要求10.0.10586版本以上 环境准备如果出现以下问题，则将系统语言设置为英文 1ninja: build stopped: subcommand failed. NMAKE : fatal error U1077: &#x27;call&#x27; : return code &#x27;0x1&#x27; Stop. NMAKE : fatal error U1077: &#x27;&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.14.26428\\bin\\HostX64\\x64\\nmake.exe&quot;&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;(&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop 编译rem 运行VC环境 &quot;D:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\vcvars32.bat&quot; set PYTHON_PATH=D:\\Python\\Python27-32 set PERL_PATH=E:\\Perl\\bin set Bison_Flex_PATH=D:\\Qt\\Qt5.10.1\\5.10.1\\build_depends\\win_flex_bison set Gperf_PATH=D:\\Qt\\Qt5.10.1\\5.10.1\\build_depends\\gperf-3.0.1-bin\\bin set PATH=%PYTHON_PATH%;%PERL_PATH%;%Bison_Flex_PATH%;%Gperf_PATH%;%PATH% rem 配置 &quot;D:\\Qt\\Qt5.10.1\\5.10.1\\msvc2015\\bin\\qmake.exe&quot; -- -webengine-proprietary-codecs rem 编译、安装 nmake &amp;&amp; namek install 参考 https://wiki.qt.io/Building_Qt_5_from_Git http://doc.qt.io/qt-5/build-sources.html http://doc.qt.io/qt-5/windows-requirements.html https://www.pressc.cn/1044.html https://blog.afach.de/?page_id=399","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt QtWebEngine","slug":"Qt-QtWebEngine","permalink":"http://shjlone.github.io/tags/Qt-QtWebEngine/"}]},{"title":"Qt视图模型","slug":"PyQt/视图模型","date":"2021-06-07T01:45:07.547Z","updated":"2021-06-07T01:45:07.547Z","comments":true,"path":"wiki/PyQt/视图模型/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"数据（Data）：是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。 视图或视图组件（View）：是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。 模型或数据模型（Model）：与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。 委托（Delegate）：根据数据绘制UI 模型、视图和代理之间使用信号和槽通信。当源数据发生变化时，数据模型发射信号通知视图组件；当用户在界面上操作数据时，视图组件发射信号表示这些操作信息；当编辑数据时，代理发射信号告知数据模型和视图组件编辑器的状态。 视图视图组件（View）就是显示数据模型的数据的界面组件，Qt 提供的视图组件如下： QListView：用于显示单列的列表数据，适用于一维数据的操作。 QTreeView：用于显示树状结构数据，适用于树状结构数据的操作。 QTableView：用于显示表格状数据，适用于二维表格型数据的操作。 QColumnView：用多个QListView显示树状层次结构，树状结构的一层用一个QListView显示。 QHeaderView：提供行表头或列表头的视图组件，如QTableView的行表头和列表头。 模型在 model/view架构中，model提供一种标准接口，供视图和委托访问数据。在Qt中，这个接口由QAbstractItemModel类进行定义。不管底层数据是如何存储的，只要是QAbstractItemModel的子类，都提供一种表格形式的层次结构。视图利用统一的转换来访问模型中的数据。 下面是各种model的组织示意图。我们利用此图来理解什么叫“一种表格形式的层次结构”。 List Model虽然是线性的列表，也有一个 Root Item（根节点），之下才是呈线性的一个个数据，而这些数据实际可以看作是一个只有一列的表格，但是它是有层次的，因为有一个根节点。Table Model 就比较容易理解，只是也存在一个根节点。Tree Model 主要面向层次数据，而每一层次都可以都很多列，因此也是一个带有层次的表格。 为了能够使得数据的显示同存储分离，我们引入模型索引（model index）的概念。通过索引，我们可以访问模型的特定元素的特定部分。视图和委托使用索引来请求所需要的数据。由此可以看出，只有模型自己需要知道如何获得数据，模型所管理的数据类型可以使用通用的方式进行定义。索引保存有创建的它的那个模型的指针，这使得同时操作多个模型成为可能。 1QAbstractItemModel *model = index.model(); 模型索引提供了所需要的信息的临时索引，可以用于通过模型取回或者修改数据。由于模型随时可能重新组织其内部的结构，因此模型索引很可能变成不可用的，此时，就不应该保存这些数据。如果你需要长期有效的数据片段，必须创建持久索引。持久索引保证其引用的数据及时更新。临时索引（也就是通常使用的索引）由QModelIndex类提供，持久索引则是QPersistentModelIndex类。 为了定位模型中的数据，我们需要三个属性：行号、列号以及父索引。 我们前面介绍过模型的基本形式：数据以二维表的形式进行存储。此时，一个数据可以由行号和列号进行定位。注意，我们仅仅是使用“二维表”这个名词，并不意味着模型内部真的是以二维数组的形式进行存储；所谓“行号”“列号”，也仅仅是为方便描述这种对应关系，并不真的是有行列之分。通过指定行号和列号，我们可以定位一个元素项，取出其信息。此时，我们获得的是一个索引对象： 123456QModelIndex index = model-&gt;index(row, column, ...);QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex &amp;parent=QModelIndex()) const 在一个简单的表格中，每一个项都可以由行号和列号确定。因此，我们只需提供两个参数即可获取到表格中的某一个数据项： 123QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());QModelIndex indexB = model-&gt;index(1, 1, QModelIndex());QModelIndex indexC = model-&gt;index(2, 1, QModelIndex()); 函数的最后一个参数始终是 QModelIndex() 在类似表格的视图中，比如列表和表格，行号和列号足以定位一个数据项。但是，对于树型结构，仅有两个参数就不足够了。这是因为树型结构是一个层次结构，而层次结构中每一个节点都有可能是另外一个表格。所以，每一个项需要指明其父节点。前面说过，在模型外部只能用过索引访问内部数据，因此，index()函数还需要一个 parent 参数： 1QModelIndex index = model-&gt;index(row, column, parent); 图中，A 和 C 都是模型中的顶级项： 12QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());QModelIndex indexC = model-&gt;index(2, 1, QModelIndex()); A 还有自己的子项。那么，我们就应该使用下面的代码获取 B 的索引： 1QModelIndex indexB = model-&gt;index(1, 0, indexA); 由此我们看到，如果只有行号和列号两个参数，B 的行号是 1，列号是 0，这同与 A 同级的行号是 1，列号是 0 的项相同，所以我们通过 parent 属性区别开来。 以上我们讨论了有关索引的定位。现在我们来看看模型的另外一个部分：数据角色。模型可以针对不同的组件（或者组件的不同部分，比如按钮的提示以及显示的文本等）提供不同的数据。例如，Qt::DisplayRole用于视图的文本显示。通常来说，数据项包含一系列不同的数据角色，这些角色定义在Qt::ItemDataRole枚举中。 我们可以通过指定索引以及角色来获得模型所提供的数据： 1QVariant value = model-&gt;data(index, role); 通过为每一个角色提供恰当的数据，模型可以告诉视图和委托如何向用户显示内容。不同类型的视图可以选择忽略自己不需要的数据。当然，我们也可以添加我们所需要的额外数据。 总结一下： 模型使用索引来提供给视图和委托有关数据项的位置的信息，这样做的好处是，模型之外的对象无需知道底层的数据存储方式； 数据项通过行号、列号以及父项三个坐标进行定位； 模型索引由模型在其它组件（视图和委托）请求时才会被创建； 如果使用index()函数请求获得一个父项的可用索引，该索引会指向模型中这个父项下面的数据项。这个索引指向该项的一个子项；如果使用index()函数请求获得一个父项的不可用索引，该索引指向模型的最顶级项； 角色用于区分数据项的不同类型的数据。 下面回到前面我们曾经见过的模型QFileSystemModel，看看如何从模型获取数据。 123QFileSystemModel *model = new QFileSystemModel;QModelIndex parentIndex = model-&gt;index(QDir::currentPath());int numRows = model-&gt;rowCount(parentIndex); 在这个例子中，我们创建了QFileSystemModel的实例，使用QFileSystemModel重载的index()获取索引，然后使用rowCount()函数计算当前目录下有多少数据项（也就是行数）。前面一章中迷迷糊糊的代码，现在已经相当清楚了。 为简单起见，下面我们只关心模型第一列。我们遍历所有数据，取得第一列索引： 12for (int row = 0; row &lt; numRows; ++row) &#123; QModelIndex index = model-&gt;index(row, 0, parentIndex); 我们使用index()函数，第一个参数是每一行行号，第二个参数是 0，也就是第一列，第三个参数是parentIndex，也就是当前目录作为父项。我们可以使用模型的data()函数获取每一项的数据。注意，该函数返回值是QVariant，实际是一个字符串，因此我们直接转换成QString： 1QString text = model-&gt;data(index, Qt::DisplayRole).toString();// 使用 text 数据 上面的代码片段显示了从模型获取数据的一些有用的函数： 模型的数目信息可以通过rowCount()和columnCount()获得。这些函数需要制定父项； 索引用于访问模型中的数据。我们需要利用行号、列号以及父项三个参数来获得该索引； 当我们使用QModelIndex()创建一个空索引使用时，我们获得的就是模型中最顶级项； 数据项包含了不同角色的数据。为获取特定角色的数据，必须指定这个角色。 QStringListModel、QDirModel、QFileSystemModel等预定义model QStandardItemModel 可当作列表模型、表格模型、树模型来使用的通用模型 QAbstractItemModel自定义模型 QStandardItemModel常用API flags(const QModelIndex &amp;index):返回被给模型索引index的标志 data(const QModelIndex &amp;index, int role = Qt::DisplayRole):返回模型索引index的底层数据（一个模型索引包括某一元素的信息，包括行，列，以及数据），用于视图和委托访问数据 headerData(int selection, Qt::Orientation orientation, int role =Qt::DisplayRole):返回某部分对应方向上的表头 ，为Views提供显示在Views顶部（即最上方和最左边）的标识 rowCount(const QModelIndex &amp;parent=QModelIndex()):返回被给的模型索引下有多少行，返回的是parent的孩子数。而不是整个行数。如果没有子元素，则返回0。 columnCount(const QModelIndex &amp;parent=QModelIndex()):这个函数通常与给定的parent无关，所涉及的类有几列就返回几 setData(const QModelIndex &amp;index, const QVariant &amp;value, int role=Qt::EditRole):用来设置模型索引index中存储的数据 setHeaderData(int section, Qt::Orientation orientation, const QVariant &amp;value, int role = Qt::EditRole): insertRows(int position, int rows, const QModelIndex &amp;index = QModelIndex()):进行插入操作时，前后分别需要调用beginInsertRows()和endInsertRows()函数 委托（Delegate）代理就是在视图组件上为编辑数据提供编辑器，如在表格组件中编辑一个单元格的数据时，缺省是使用一个 QLineEdit 编辑框。代理负责从数据模型获取相应的数据，然后显示在编辑器里，修改数据后，又将其保存到数据模型中。 QAbstractltemDelegate 是所有代理类的基类，作为抽象类，它不能直接使用。它的一个子类 QStyledltemDelegate，是 Qt 的视图组件缺省使用的代理类。 QStyledItemDelegate常用API updateEditorGeometry：设置编辑器editor的尺寸和位置 painter： 绘制给定模型索引index所对应的项 setEditorData： 使用给定模型索引index所对应的模型项的数据来填充编辑器editor setModelData：从编辑器editor中获取数据并设置为给定模型索引index所对应的模型项的数据 setHint： 返回委托需要的、显示或编辑给定模型索引index所代表的项的尺寸 updateEditorGeometry： 设置编辑器editor的尺寸和位置 实例参考 https://doc.qt.io/qt-5/model-view-programming.html","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/tags/PyQt/"}]},{"title":"PyQt5开发心得","slug":"PyQt/PyQt5开发心得","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/PyQt5开发心得/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/PyQt5%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/","excerpt":"","text":"其实大部分的客户端开发都有共通性。一套GUI API，Button、Text、Dialog等等，绘制机制，事件传递机制，都是根据不同平台的特性做了封装。但开发的时候，用法是类似的。而Python由于语法的简易性，开发效率比使用C++版的Qt高很多。所谓的性能损耗其实在大部分的应用中是可以忽略的。 基础结构的搭建不管是做一个项目还是多个项目，准备一套基础框架，对开发效率是非常有帮助的。这个基础框架通常包括： 基础结构 基础工具类、工具函数：字符串处理、时间处理、日期处理、线程处理、网络请求、拖拽工具、缩放工具、资源下载工具、 基础控件：弹窗提示、确认框、webview的封装和通讯模块、loading框、全局样式处理 日志工具： 数据模拟工具：mock 单元测试框架： 性能分析工具：分析代码质量 打包工具：分发安装包 更新工具 异常捕获分析工具：分析线上可能存在的问题 项目框架的搭建：分层、抽象、解耦、MVC思想的体现。随着业务的增长，在重构代码的时候要遵循高内聚、低耦合的思想。 关于线程的使用随着业务的增长，项目会越来越复杂，不可避免的会使用到多线程。使用的过程中，要注意以下几点： 线程要及时释放 比如有一个场景，用户点击某个按钮，需要向服务器请求数据，然后将数据更新到文本框中。你需要在非UI线程中请求http接口，收到服务器响应后，切换回UI线程更新。但有时候由于网络原因，响应的时间较长，在收到响应结果时，UI已经被销毁了。所以要注意在UI销毁的同时，对应的线程都要进行释放。同样的场景还有下载器，各种定时操作。都要进行及时的清理。 最好能封装几个工具类、工具函数，统一管理。 QTimer初始化时带上parent，创建和start在同一个线程 Model初始化的时候需要传入parent 关于性能虽然前面说性能问题可以忽略，但如果你很随意的在主线程中做一些频繁的复杂的运算，UI也是会卡顿的。这里介绍一点自己的经验。 非UI操作尽量全部放到非UI线程处理。 对于非常频繁的操作使用间隔，比如1秒中调用一次。直白说就是降低UI刷新的频率。 由于python GIL的存在，当某些计算需要消耗较多CPU时，需要考虑是否将其移到C/C++中处理。 使用更优秀的json处理库 关于程序崩溃http://enki-editor.org/2014/08/23/Pyqt_mem_mgmt.html https://stackoverflow.com/questions/11945183/what-are-good-practices-for-avoiding-crashes-hangs-in-pyqt http://python-camelot.s3.amazonaws.com/gpl/release/pyqt/doc/advanced/development.html 常见问题汇总libpng warning: iCCP: known incorrect sRGB profile UpdateLayeredWindowIndirect failed for ptDst= 程序使用一段时间后，关闭某个窗口，会造成整个程序崩溃。crashrpt捕获到的dump指向的是Qt的某个函数。可无法定位到业务层的代码。后打包成debug模式，在崩溃的时候控制台输出了以上信息，google进行搜索，看到了这里，想起来边框阴影的实现就是使用了QGraphicsDropShadowEffect滤镜。去掉后，果然没有再出现了。 如何彻底销毁QWidget close() 在Qt中，每个 QObject 内部都有一个list，用来保存所有的 children，还有一个指针，保存自己的parent。当它自己析构时，它会将自己从parent的列表中删除，并且析构掉所有的children。 调用close()方法后首先它会向widget发送一个关闭事件（QCloseEvent）。如果widget接受了关闭事件（QCloseEvent），窗口将会隐藏（实际上调用hide()）。如果widget不接受关闭事件，那么窗口将什么也不做。默认情况下widget会接受关闭事件,我们可以重写QCloseEvent事件，可以选择接受或者不接受。 如果widget设置了Qt::WA_DeleteOnClose属性，widget将会被释放。不管widget是否可见，关闭事件都会传递给widget。即接收到QCloseEvent事件后，除了调用hide()方法将窗口隐藏，同时会调用deleteLater()方法将窗口释放掉，不会再占用资源。 所以说调用close()并不一定就会将窗口对象销毁。而只有设置了 Qt::WA_DeleteOnClose属性才会删除销毁。如果这个属性没有设置，close()的作用和hide（），setvisible（false）一样，只会隐藏窗口对象而已，并不会销毁该对象。 deleteLater() 走Qt的事件循环，延迟删除。 sip.delete(widget) 调用了Qt的delete来删除对象 QWidget的Qt.WA_TranslucentBackground默认值是False。 123456789101112131415class FooWidget(QWidget): def __init__(self): super(FooWidget, self).__init__() self.setAttribute(Qt.WA_TranslucentBackground, True) def closeEvent(self, event): # accept退出，ingore取消退出，默认值为accept print(&#x27;closeEvent&#x27;)self.foo = FooWidget()self.foo.close()self.foo = None 参考 https://blog.csdn.net/GoForwardToStep/article/details/53647146 https://doc.qt.io http://c.biancheng.net/view/1864.html","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"QListWidget","slug":"PyQt/QListWidget","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/QListWidget/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/QListWidget/","excerpt":"","text":"一些技巧让QListWidget的高度跟着内容的高度变化12345678910111213141516from PySide import QtGui, QtCoreapp = QtGui.QApplication([])window = QtGui.QWidget()layout = QtGui.QVBoxLayout(window)list = QtGui.QListWidget()list.addItems([&#x27;Winnie Puh&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Minnesota&#x27;, &#x27;Dracula Calista Flockhart Meningitis&#x27;, &#x27;Once&#x27;, &#x27;123345&#x27;, &#x27;Fin&#x27;])list.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)list.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)list.setFixedSize(list.sizeHintForColumn(0) + 2 * list.frameWidth(), list.sizeHintForRow(0) * list.count() + 2 * list.frameWidth())layout.addWidget(list)window.show()app.exec_() 参考 https://stackoverflow.com/questions/6337589/qlistwidget-adjust-size-to-content","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"Qt中圆形头像","slug":"PyQt/圆形头像","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/圆形头像/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F/","excerpt":"","text":"业务需求中经常需要头像是圆形的，一些数字底部有圆形背景，于是将其整理出来，以便以后方便的使用。 123456789101112131415161718192021class CircleThumbWiget(QWidget): def __init__(self, parent=None, radius=40): &quot;&quot;&quot; radius 表示这个圆形控件的大小 &quot;&quot;&quot; super(CircleThumbWiget, self).__init__(parent) self.imageLabel = QLabel(self) self.imageLabel.setScaledContents(True) self.imageLabel.setGeometry(0, 0, radius, radius) defaultPixmap = QPixmap(&quot;resources/icon/default_user.png&quot;) self.imageLabel.setPixmap(defaultPixmap) # 这里使用一张周边透明的圆形的png图片 img = QImage(&quot;resources/icon/default_user_mask.png&quot;) bg = QPixmap.fromImage(img.scaled(QSize(radius, radius), Qt.IgnoreAspectRatio)) palette = self.palette() palette.setBrush(QPalette.Background, QBrush(bg)) self.setPalette(palette) self.setMask(bg.mask()) def setPixmap(self, pixmap): self.imageLabel.setPixmap(pixmap) 平滑的圆形头像1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from PyQt5.QtCore import Qt, QRectfrom PyQt5.QtGui import QBrush, QImage, QPainter, QPixmap, QWindowfrom PyQt5.QtWidgets import QLabel, QVBoxLayout, QWidgetdef mask_image(imgdata, imgtype=&#x27;png&#x27;, size=64): &quot;&quot;&quot;Return a ``QPixmap`` from *imgdata* masked with a smooth circle. *imgdata* are the raw image bytes, *imgtype* denotes the image type. The returned image will have a size of *size* × *size* pixels. &quot;&quot;&quot; # Load image and convert to 32-bit ARGB (adds an alpha channel): image = QImage.fromData(imgdata, imgtype) image.convertToFormat(QImage.Format_ARGB32) # Crop image to a square: imgsize = min(image.width(), image.height()) rect = QRect( (image.width() - imgsize) / 2, (image.height() - imgsize) / 2, imgsize, imgsize, ) image = image.copy(rect) # Create the output image with the same dimensions and an alpha channel # and make it completely transparent: out_img = QImage(imgsize, imgsize, QImage.Format_ARGB32) out_img.fill(Qt.transparent) # Create a texture brush and paint a circle with the original image onto # the output image: brush = QBrush(image) # Create texture brush painter = QPainter(out_img) # Paint the output image painter.setBrush(brush) # Use the image texture brush painter.setPen(Qt.NoPen) # Don&#x27;t draw an outline painter.setRenderHint(QPainter.Antialiasing, True) # Use AA painter.drawEllipse(0, 0, imgsize, imgsize) # Actually draw the circle painter.end() # We are done (segfault if you forget this) # Convert the image to a pixmap and rescale it. Take pixel ratio into # account to get a sharp image on retina displays: pr = QWindow().devicePixelRatio() pm = QPixmap.fromImage(out_img) pm.setDevicePixelRatio(pr) size *= pr pm = pm.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation) return pmclass Window(QWidget): &quot;&quot;&quot;Simple window that shows our masked image and text label.&quot;&quot;&quot; def __init__(self): super().__init__() imgpath = &quot;U:/xxx/logo.png&quot; imgdata = open(imgpath, &#x27;rb&#x27;).read() ext = imgpath.split(&quot;.&quot;)[-1] pixmap = mask_image(imgdata, ext) ilabel = QLabel() ilabel.setScaledContents(True) ilabel.setFixedWidth(26) ilabel.setFixedHeight(26) ilabel.setPixmap(pixmap) layout = QVBoxLayout() layout.addWidget(ilabel, 0, Qt.AlignCenter) self.setLayout(layout)if __name__ == &#x27;__main__&#x27;: import sys from PyQt5.QtWidgets import QApplication app = QApplication(sys.argv) w = Window() w.show() sys.exit(app.exec_()) 参考 https://stefan.sofa-rockers.org/2018/05/04/how-to-mask-an-image-with-a-smooth-circle-in-pyqt5/","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"快捷键处理","slug":"PyQt/快捷键处理","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/快捷键处理/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%84%E7%90%86/","excerpt":"","text":"屏蔽alt+F4等快捷键12345678910111213141516171819202122232425262728class GlobalEventFilter(QAbstractNativeEventFilter): def __init__(self): super(GlobalEventFilter, self).__init__() def nativeEventFilter(self, event_type, sip_voidptr): if event_type == &quot;windows_generic_MSG&quot; or event_type == &quot;windows_dispatcher_MSG&quot;: msg = MSG.from_address(sip_voidptr.__init__()) if msg.message in [WM_KEYDOWN, WM_SYSKEYDOWN]: if VK_F4 == msg.wParam and win32api.GetKeyState(VK_MENU) &amp; 0xF000: return True, 1 # True 代表我处理了消息，不需要Qt处理 elif VK_ESCAPE == msg.wParam: return True, 1 # 屏蔽esc键 return False, 1class App(QApplication): def __init__(self, *args): super(App, self).__init__(*args) self.global_event_filter = GlobalEventFilter() self.intallNativeEventFilter(self.global_event_filter) def exit_app(self): self.removeNativeEventFilter(self.global_event_filter)","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/tags/PyQt/"}]},{"title":"Android逆向之脱壳","slug":"Android/逆向/Android逆向之脱壳","date":"2021-06-07T01:45:07.545Z","updated":"2021-06-07T01:45:07.545Z","comments":true,"path":"wiki/Android/逆向/Android逆向之脱壳/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/","excerpt":"","text":"有些App为了安全，会使用相关加壳工具来提高破解难度。但其实意义不大，通过hook，应该是很容易获取内存dump出dex文件的。还记得以前进行flash游戏破解的时候，当时使用一个技巧，通过flash的运行机制，在swf启动的时候将自己写的swfload进来并运行，运行的代码就是将内存中的swf导出来。破解成功的概率非常高。而个人认为，通过代码混淆来增加阅读难度比加壳的作用更有用。 最近看到某款竟品，于是想学习学习，直接放到Jadx中，嗯哼，竟然使用了腾讯乐固。了解了大致破壳的原理，其实就算自己实现也是可行的。不过自己能想到的事情，可能有人早就想到了。搜一搜吧，果然有很多破解工具。有些文章可以参考参考、学习学习： https://crifan.github.io/android_app_security_crack/website/ 我们的目的是为了快速获取dex，阅读源码，所以就不折腾每个工具是怎么实现的了。找到文章说的工具，一个一个试吧。最终发现ReflectMaster可以dump出来dex。使用如下： 安装ReflectMaster，下载地址：https://www.lanzous.com/i6x1kaf 在xposed环境中，安装并激活。 启动对应带壳的App，点击”中间的图标”，点击”当前Activity”，点击”导出dex”。 确认使用腾讯乐固： 导出的dex如下： 参考 https://github.com/FormatFa/ReflectMaster https://www.kanxue.com/chm.htm?id=9948&amp;pid=node1000000 https://blog.csdn.net/qq_41855420/article/details/106276824 https://www.kanxue.com/chm.htm?id=9948&amp;pid=node1000000","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android逆向之Xposed","slug":"Android/逆向/Android逆向之Xposed","date":"2021-06-07T01:45:07.544Z","updated":"2021-06-07T01:45:07.544Z","comments":true,"path":"wiki/Android/逆向/Android逆向之Xposed/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/Android%E9%80%86%E5%90%91%E4%B9%8BXposed/","excerpt":"","text":"Xposed的作用非常强大，以前虽然也大致了解，但没有自己实践过。最近在做其他App分析的时候，发现其限制了模拟器的使用，于是想着逆向破解一下，于是开启了Xposed之旅。 首先阅读下官网，嗯，版本很久没有更新了，后面又出现了”太极”之类的新的工具。就不折腾那么多了，先以快速解决问题为目标。下载雷电模拟器，其版本为Android7.1.2。进入”雷电游戏中心”搜索xposed，下载对应的App，打开后点击安装，重启。 Hello World下一步完成一个最简单的Hello World，网上搜有一大把。总结下： 添加依赖，目前最新的版本为82： 12compileOnly &#x27;de.robv.android.xposed:api:82&#x27;compileOnly &#x27;de.robv.android.xposed:api:82:sources&#x27; 修改AndroidManifest.xml文件，添加相应标识，用于Xposed识别。 1234567891011&lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt;&lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;这是一个Xposed例程&quot; /&gt;&lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;53&quot; /&gt; 新建assets文件夹，添加xposed_init文件，添加hook启动入口，文件内容为你的hook类。 添加hook类，实现IXposedHookLoadPackage，实现handleLoadPackage方法。 熟悉API https://api.xposed.info/reference/packages.html 12345/**当App装载的时候会被调用，被调用的非常早，比Application.onCreate还早。*/public abstract void handleLoadPackage (XC_LoadPackage.LoadPackageParam lpparam) xposed工具开发者助手:下载地址：https://github.com/WrBug/DeveloperHelper 可以直接在界面上看到UI的名字，可以查看log Inspeckage：下载地址：https://repo.xposed.info/module/mobi.acpm.inspeckage 在网页上看相关信息：包信息，Shared Preferences，使用了Crypto、Hash的记录，抓包信息等 JustTrustMe：https://github.com/Fuzion24/JustTrustMe UCrack：https://gitee.com/virjar/ucrack 一个基于Xposed写的辅助工具，集成了自动网络抓包、网络堆栈爆破、文件日志、WebView调试环境、自动脱壳、Native函数注册监控、记录程序自杀堆栈等功能。 ReflectMaster（反射大师）：https://github.com/FormatFa/ReflectMaster 可以从当前页面提取dex，对于加壳的App很有用。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Apk打包流程","slug":"Android/性能优化/APK打包流程","date":"2021-06-07T01:45:07.543Z","updated":"2021-06-07T01:45:07.543Z","comments":true,"path":"wiki/Android/性能优化/APK打包流程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/APK%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"native crash 分析","slug":"Android/性能优化/native crash分析","date":"2021-06-07T01:45:07.543Z","updated":"2021-07-21T01:44:40.620Z","comments":true,"path":"wiki/Android/性能优化/native crash分析/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/native%20crash%E5%88%86%E6%9E%90/","excerpt":"","text":"Crash类型： Framework/App Crash：Java层崩溃 Native Crash：C/C++层崩溃 Kernel Crash：内核崩溃 tombstone文件的组成部分： Build fingerprint Crashed process and PIDS Terminated signal and fault address CPU registers Call stack Stack content of each call 12345678910111213--logversion:utraceaProcess Name: &#x27;com.feiteng.lieyou&#x27;Thread Name: &#x27;RenderThread&#x27;pid: 25031, tid: 25237 &gt;&gt;&gt; com.feiteng.lieyou &lt;&lt;&lt;killed by pid: 25031, comm: .feiteng.lieyou, uid: 10125.signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------r0 00000000 r1 00006295 r2 00000006 r3 00000008r4 c587c978 r5 00000006 r6 c587c920 r7 0000010cr8 bf249bc8 r9 00000000 10 bf249bbc fp bf249bb8ip 00000004 sp c587c3b0 lr eba21907 pc eba24188 cpsr 20070010d0 0000000000000000 d1 0000000000000000d2 0000000000000000 d3 0000000000000000 signal指定异常类型。如果pid等于tid，则说明程序是在主线程中崩溃。 信号类型:软中断信号（signal，又简称为信号）用来通知进程发生了事件。进程之间可以通过调用kill库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。 信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种： 第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。 第二种是设置中断的处理函数，收到信号后，由该函数来处理。 第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//信号监听sighandler_t signal(int signum, sighandler_t handler);/*参数signum表示信号的编号。参数handler表示信号的处理方式，有三种情况：1）SIG_IGN：忽略参数signum所指的信号。2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。3）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。*///发送信号int kill(pid_t pid, int sig);/*kill函数将参数sig指定的信号给参数pid 指定的进程。参数pid 有几种情况：1）pid&gt;0 将信号传给进程号为pid 的进程。2）pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。3）pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。EINVAL：指定的信号码无效（参数 sig 不合法）。EPERM：权限不够无法传送信号给指定进程。ESRCH：参数 pid 所指定的进程或进程组不存在。*/#define SIGHUP 1 // 终端连接结束时发出(不管正常或非正常)#define SIGINT 2 // 程序终止(例如Ctrl-C)#define SIGQUIT 3 // 程序退出(Ctrl-\\)#define SIGILL 4 // 执行了非法指令，或者试图执行数据段，堆栈溢出#define SIGTRAP 5 // 断点时产生，由debugger使用#define SIGABRT 6 // 调用abort函数生成的信号，表示程序异常#define SIGIOT 6 // 同上，更全，IO异常也会发出#define SIGBUS 7 // 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数#define SIGFPE 8 // 计算错误，比如除0、溢出#define SIGKILL 9 // 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略#define SIGUSR1 10 // 未使用，保留#define SIGSEGV 11 // 非法内存操作，与SIGBUS不同，他是对合法地址的非法访问，比如访问没有读权限的内存，向没有写权限的地址写数据#define SIGUSR2 12 // 未使用，保留#define SIGPIPE 13 // 管道破裂，通常在进程间通信产生#define SIGALRM 14 // 定时信号,#define SIGTERM 15 // 结束程序，类似温和的SIGKILL，可被阻塞和处理。通常程序如果终止不了，才会尝试SIGKILL#define SIGSTKFLT 16 // 协处理器堆栈错误#define SIGCHLD 17 // 子进程结束时, 父进程会收到这个信号。#define SIGCONT 18 // 让一个停止的进程继续执行#define SIGSTOP 19 // 停止进程,本信号不能被阻塞,处理或忽略#define SIGTSTP 20 // 停止进程,但该信号可以被处理和忽略#define SIGTTIN 21 // 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号#define SIGTTOU 22 // 类似于SIGTTIN, 但在写终端时收到#define SIGURG 23 // 有紧急数据或out-of-band数据到达socket时产生#define SIGXCPU 24 // 超过CPU时间资源限制时发出#define SIGXFSZ 25 // 当进程企图扩大文件以至于超过文件大小资源限制#define SIGVTALRM 26 // 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.#define SIGPROF 27 // 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间#define SIGWINCH 28 // 窗口大小改变时发出#define SIGIO 29 // 文件描述符准备就绪, 可以开始进行输入/输出操作#define SIGPOLL SIGIO // 同上，别称#define SIGPWR 30 // 电源异常#define SIGSYS 31 // 非法的系统调用 tombstone 文件位于路径 /data/tombstones/下 调用栈信息调用栈信息是分析程序崩溃的非常重要的一个信息，它主要记录了程序在 Crash 前的函数调用关系以及当前正在执行函数的信息，它对应的是我们tombstone文件中 backtrace 符号开始的信息，上面例子中的 backtrace 的信息如下所示 12345678910backtrace: #00 pc 00006639 /system/lib/libui.so (android::Fence::waitForever(char const*)+41) #01 pc 00034b86 /system/lib/libsurfaceflinger.so #02 pc 0003229e /system/lib/libsurfaceflinger.so #03 pc 0002cb9c /system/lib/libgui.so (android::BufferQueue::ProxyConsumerListener::onFrameAvailable(android::BufferItem const&amp;)+652) #04 pc 000342f4 /system/lib/libgui.so (android::BufferQueueProducer::queueBuffer(int, android::IGraphicBufferProducer::QueueBufferInput const&amp;, android::IGraphicBufferProducer::QueueBufferOutput*)+2580) ##00 等表示函数调用栈中栈帧的编号 pc 后面的16进制数表示当前函数正在执行语句在共享链接库或可执行文件的位置 最后一行表示当前指令在哪个文件 如何定位崩溃位置常用工具nm12查看动态库的符号表nm -D libName.so | grep symbel symbolName addr2line12345678910111213141516171819Usage: /Users/loneqd/Android/sdk/ndk-bundle/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line [option(s)] [addr(s)] Convert addresses into line number/file name pairs. If no addresses are specified on the command line, they will be read from stdin The options are: @&lt;file&gt; Read options from &lt;file&gt; -a --addresses Show addresses -b --target=&lt;bfdname&gt; Set the binary file format -e --exe=&lt;executable&gt; Set the input file name (default is a.out) -i --inlines Unwind inlined functions -j --section=&lt;name&gt; Read section-relative offsets instead of addresses -p --pretty-print Make the output easier to read for humans -s --basenames Strip directory names -f --functions Show function names -C --demangle[=style] Demangle function names -h --help Display this information -v --version Display the program&#x27;s version实例：(需使用带symbol的动态库)addr2line -f -e libui.so 00006639 _ZN7android5Fence11waitForeverE ndk-stack将崩溃时的调用内存地址和C++代码对应起来 123456789101112131415usage: ndk-stack.py [-h] -sym SYMBOL_DIR [-i INPUT]Symbolizes Android crashes.optional arguments: -h, --help show this help message and exit -sym SYMBOL_DIR, --sym SYMBOL_DIR directory containing unstripped .so files -i INPUT, -dump INPUT, --dump INPUT input filenameSee &lt;https://developer.android.com/ndk/guides/ndk-stack&gt;.sym指项目编译成功之后，obj目录dump指崩溃文件 xCrash的使用 https://github.com/iqiyi/xCrash native异常日志文件的格式 12345678910111213日志分为： 头部信息（为应用的基本信息） 异常信号部分。（哪个异常信号导致异常，信号参见Linux信号） backtrace so库的编译信息，build id 堆栈信息 内存信息 内存映射 logcat日志输出部分，包括main,system,event app应用进程打开的文件描述符 内存信息 app应用进程信息 异常回调填充信息 一般根据backtrace，再使用addr2line命令定位具体的错误代码位置。 参考 http://gityuan.com/2016/06/25/android-native-crash/ https://toutiao.io/posts/jflx6c/preview https://source.android.google.cn/devices/tech/debug/native-crash?hl=zh-cn http://www.droidsec.cn/%E5%B8%B8%E8%A7%81android-native%E5%B4%A9%E6%BA%83%E5%8F%8A%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0/ https://github.com/iqiyi/xCrash https://source.android.com/devices/tech/debug xCrash日志文件格式","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android的消息机制","slug":"Android/基础/Android的消息机制","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-07T01:45:07.542Z","comments":true,"path":"wiki/Android/基础/Android的消息机制/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"BroadcastReceiver工作过程","slug":"Android/基础/BroadcastReceiver工作过程","date":"2021-06-07T01:45:07.542Z","updated":"2021-07-09T06:42:52.557Z","comments":true,"path":"wiki/Android/基础/BroadcastReceiver工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/BroadcastReceiver%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"概述BroadcastReceiver是一种消息型组件。由于BroadcastReceiver可以在不同的组件甚至不同的应用之间传递消息，所以其可以脱离Activity实现，除了要在AndroidManifest.xml中注册广播类名外，还需要添加intentfilter，这样就可以让receiver选择性的接收广播。当注册完成之后，即使没有Activity启动，也可以接收广播。在实现 BroadcastReceiver时，需要继承 BroadcastReceiver抽象类，但是不需要重写onCreat()方法，只需重写onReceive()方法，因此，Service没有启动和停止的概念，更像是一个系统级的监听器。 流程分析广播的注册分为静态注册和动态注册，其中静态注册的广播在应用安装时由系统自动完成注册，具体来说是由PMS(PackageManagerService)来完成整个注册过程的。 注册过程动态注册的过程是从ContextWrapper的registerReceiver方法开始的。 我们从该方法开始 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ContextWrapper.javapublic Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter);&#125;//ContextImpl.javaprivate Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context, int flags) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; //返回ReceiverDispatcher rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; //ActivityManagerService注册 final Intent intent = ActivityManager.getService().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId, flags); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 在上面的代码中，系统首先从mPackageInfo获取IIntentReceiver对象，然后再采用跨进程的方式向AMS发送广播注册的请求。之所以采用IIntentReceiver而不是直接采用BroadcastReceiver，这是因为上述注册过程是一个进程间通信的过程，而BroadcastReceiver作为Android的一个组件是不能直接跨进程传递的，所以需要通过IIntentReceiver来中转一下。毫无疑问，IIntentReceiver必须是一个Binder接口，它的具体实现是LoadedApk.ReceiverDispatcher.InnerReceiver，ReceiverDispatcher的内部同时保存了BroadcastReceiver和InnerReceiver，这样当接收到广播时，ReceiverDispatcher可以很方便地调用BroadcastReceiver的onReceive方法。 12345678ActivityManagerService.javapublic Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId, int flags) &#123; &#125; 发送和接收过程广播类型： 普通广播(Normal Broadcast) 系统广播(System Broadcast) 有序广播(Ordered Broadcast) 粘性广播(Sticky Broadcast) App应用内广播(Local Broadcast) 发送广播从sendBroadcast开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253//ContextImpl.javapublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(this); ActivityManager.getService().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;//ActivityManagerServicepublic final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller(&quot;broadcastIntent&quot;); synchronized(this) &#123; intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); try &#123; return broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, callingUid, callingPid, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125;&#125;final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int realCallingUid, int realCallingPid, int userId, boolean allowBackgroundActivityStarts) &#123; intent = new Intent(intent); final boolean callerInstantApp = isInstantApp(callerApp, callerPackage, callingUid); // Instant Apps cannot use FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS if (callerInstantApp) &#123; intent.setFlags(intent.getFlags() &amp; ~Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS); &#125; // By default broadcasts do not go to stopped apps. intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); // If we have not finished booting, don&#x27;t allow this to launch new processes. if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123; intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); &#125;... final BroadcastRecord oldRecord = replacePending ? queue.replaceOrderedBroadcastLocked(r) : null; if (oldRecord != null) &#123; // Replaced, fire the result-to receiver. if (oldRecord.resultTo != null) &#123; final BroadcastQueue oldQueue = broadcastQueueForIntent(oldRecord.intent); try &#123; oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo, oldRecord.intent, Activity.RESULT_CANCELED, null, null, false, false, oldRecord.userId); &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Failure [&quot; + queue.mQueueName + &quot;] sending broadcast result of &quot; + intent, e); &#125; &#125; &#125; else &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; ... &#125;//BroadcastQueue.javapublic void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot; + mQueueName + &quot;]: current=&quot; + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125;//处理BROADCAST_INTENT_MSGfinal void processNextBroadcast(boolean fromMsg) &#123; synchronized (mService) &#123; processNextBroadcastLocked(fromMsg, false); &#125;&#125;final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;...performReceiveLocked(r.callerApp, r.resultTo, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, false, false, r.userId);...&#125;void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null) &#123; if (app.thread != null) &#123; // If we have an app thread, do the call through that so it is // correctly ordered with other one-way calls. try &#123; //ActivityThread.ApplicationThread app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.getReportedProcState()); // TODO: Uncomment this when (b/28322359) is fixed and we aren&#x27;t getting // DeadObjectException when the process isn&#x27;t actually dead. //&#125; catch (DeadObjectException ex) &#123; // Failed to call into the process. It&#x27;s dying so just let it die and move on. // throw ex; &#125; catch (RemoteException ex) &#123; // Failed to call into the process. It&#x27;s either dying or wedged. Kill it gently. synchronized (mService) &#123; Slog.w(TAG, &quot;Can&#x27;t deliver broadcast to &quot; + app.processName + &quot; (pid &quot; + app.pid + &quot;). Crashing it.&quot;); app.scheduleCrash(&quot;can&#x27;t deliver broadcast&quot;); &#125; throw ex; &#125; &#125; else &#123; // Application has died. Receiver doesn&#x27;t exist. throw new RemoteException(&quot;app.thread must not be null&quot;); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125;//ActivityThread.ApplicationThreadpublic void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); //实际调用LoadedApk.ReceiverDispatcher.InnerReceiver receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125;//LoadedApk.ReceiverDispatcher.InnerReceiverpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final LoadedApk.ReceiverDispatcher rd; if (intent == null) &#123; Log.wtf(TAG, &quot;Null intent received&quot;); rd = null; &#125; else &#123; rd = mDispatcher.get(); &#125; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra(&quot;seq&quot;, -1); Slog.i(ActivityThread.TAG, &quot;Receiving broadcast &quot; + intent.getAction() + &quot; seq=&quot; + seq + &quot; to &quot; + (rd != null ? rd.mReceiver : null)); &#125; if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system&#x27;s broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, &quot;Finishing broadcast to unregistered receiver&quot;); IActivityManager mgr = ActivityManager.getService(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125;&#125;public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); if (intent == null) &#123; Log.wtf(TAG, &quot;Null intent received&quot;); &#125; else &#123; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra(&quot;seq&quot;, -1); Slog.i(ActivityThread.TAG, &quot;Enqueueing broadcast &quot; + intent.getAction() + &quot; seq=&quot; + seq + &quot; to &quot; + mReceiver); &#125; &#125; //会创建一个Args对象并通过mActivityThread的post方法来执行Args中的逻辑，而Args实现了Runnable接口。mActivityThread是一个Handler， //它其实就是ActivityThread中的mH，mH的类型是 ActivityThread的内部类H if (intent == null || !mActivityThread.post(args.getRunnable())) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManager.getService(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, &quot;Finishing sync broadcast to &quot; + mReceiver); args.sendFinished(mgr); &#125; &#125;&#125;//LoaderApk.ReceiverDispatcher.Argsfinal class Args extends BroadcastReceiver.PendingResult &#123; public final Runnable getRunnable() &#123; return () -&gt; &#123; ... ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); intent.prepareToEnterProcess(); setExtrasClassLoader(cl); receiver.setPendingResult(this); receiver.onReceive(mContext, intent);//接收到消息了 ... &#125; &#125;&#125; 在broadcastIntentLocked的内部，会根据intent-filter查找出匹配的广播接收者并经过一系列的条件过滤，最终会将满足条件的广播接收者添加到BroadcastQueue中，接着BroadcastQueue就会将广播发送给相应的广播接收者。 流程图 参考 《Android开发艺术探索》","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ContentProvider工作过程","slug":"Android/基础/ContentProvider工作过程","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-26T07:26:53.106Z","comments":true,"path":"wiki/Android/基础/ContentProvider工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/ContentProvider%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"概要ContentProvider主要用来给不同应用提供数据，当其所在进程启动时，ContentProvider会同时启动并发布到AMS中。 当android:multiprocess为true时，ContentProvider为多实例。 其提供了query、update、delete、insert等接口，方便我们进行数据操作。 启动流程我们要使用ContentProvider，需要通过getContentResolver()，实际是ApplicationContentResolver对象。 我们从query方法入手 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//开始查询Cursor cursor = getContentResolver().query(Uri.parse(&quot;content://com.lqd.androidpractice.provider.UsersProvider/users&quot;), null, null, null, null);//ContentResolver.javapublic final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal cancellationSignal) &#123; Preconditions.checkNotNull(uri, &quot;uri&quot;); try &#123; if (mWrapped != null) &#123; return mWrapped.query(uri, projection, queryArgs, cancellationSignal); &#125; &#125; catch (RemoteException e) &#123; return null; &#125; IContentProvider unstableProvider = acquireUnstableProvider(uri);//调用子类ApplicationContentResolver if (unstableProvider == null) &#123; return null; &#125;.... &#125;//ContextImpl的静态内部类ApplicationContentResolver@Overrideprotected IContentProvider acquireUnstableProvider(Context c, String auth) &#123; //ActivityThread return mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), false);&#125;//ActivityThread.java//存储Provider对象final ArrayMap&lt;IBinder, ProviderRefCount&gt; mProviderRefCountMap = new ArrayMap&lt;IBinder, ProviderRefCount&gt;(); public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; // There is a possible race here. Another thread may try to acquire // the same provider at the same time. When this happens, we want to ensure // that the first one wins. // Note that we cannot hold the lock while acquiring and installing the // provider since it might take a long time to run and it could also potentially // be re-entrant in the case where the provider is in the same process. ContentProviderHolder holder = null; try &#123; synchronized (getGetProviderLock(auth, userId)) &#123; holder = ActivityManager.getService().getContentProvider( getApplicationThread(), c.getOpPackageName(), auth, userId, stable); &#125; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; if (holder == null) &#123; Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth); return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125;private ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; .. mProviderRefCountMap.put(jBinder, prc);//添加到Map中 ...&#125; 由以上代码可知，没有就创建Provider，创建完后会添加到mProviderRefCountMap中。如果Provider对应到进程有启动，则在Application启动时同时初始化了Provider。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980ActivityThread.javapublic static void main(String[] args) &#123;...ActivityThread thread = new ActivityThread();thread.attach(false, startSeq);...&#125;private void attach(boolean system, long startSeq) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try &#123; mgr.attachApplication(mAppThread, startSeq);//ActivityManagerService &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; .... &#125;&#125;//ActivityManagerService.java@Overridepublic final void attachApplication(IApplicationThread thread, long startSeq) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); &#125;&#125;private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; .... if (app.isolatedEntryPoint != null) &#123; // This is an isolated process which should just call an entry point instead of // being bound to an application. thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs); &#125; else if (instr2 != null) &#123; //ApplicationThread thread.bindApplication(processName, appInfo, providers, instr2.mClass, profilerInfo, instr2.mArguments, instr2.mWatcher, instr2.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions); &#125; else &#123; thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions); &#125; ... &#125; &#125; AMS的attachApplication方法调用了attachApplicationLocked方法，attachApplicationLocked中又调用了ApplicationThread的bindApplication，注意这个过程也是进程间调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184ActivityThread的内部类ApplicationThreadpublic final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, AutofillOptions autofillOptions, ContentCaptureOptions contentCaptureOptions) &#123; if (services != null) &#123; if (false) &#123; // Test code to make sure the app could see the passed-in services. for (Object oname : services.keySet()) &#123; if (services.get(oname) == null) &#123; continue; // AM just passed in a null service. &#125; String name = (String) oname; // See b/79378449 about the following exemption. switch (name) &#123; case &quot;package&quot;: case Context.WINDOW_SERVICE: continue; &#125; if (ServiceManager.getService(name) == null) &#123; Log.wtf(TAG, &quot;Service &quot; + name + &quot; should be accessible by this app&quot;); &#125; &#125; &#125; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; data.buildSerial = buildSerial; data.autofillOptions = autofillOptions; data.contentCaptureOptions = contentCaptureOptions; sendMessage(H.BIND_APPLICATION, data);&#125;private void handleBindApplication(AppBindData data) &#123;...//Context初始化final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); ...//Instrumentation初始化 try &#123; final ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException( &quot;Unable to instantiate instrumentation &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); &#125; final ComponentName component = new ComponentName(ii.packageName, ii.name); mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection);....//Application初始化 try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. app = data.info.makeApplication(data.restrictedBackupMode, null); // Propagate autofill compat state app.setAutofillOptions(data.autofillOptions); // Propagate Content Capture options app.setContentCaptureOptions(data.contentCaptureOptions); mInitialApplication = app; if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers);//初始化Provider，添加到Map中 &#125; &#125; ... try &#123; mInstrumentation.callApplicationOnCreate(app);//调用Application的onCreate，由此可知，ContentProvider的onCreate要先调用 &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); &#125; &#125; ...&#125;private ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; ... try &#123; final java.lang.ClassLoader cl = c.getClassLoader(); LoadedApk packageInfo = peekPackageInfo(ai.packageName, true); if (packageInfo == null) &#123; // System startup case. packageInfo = getSystemContext().mPackageInfo; &#125; localProvider = packageInfo.getAppFactory() .instantiateProvider(cl, info.name); provider = localProvider.getIContentProvider(); if (provider == null) &#123; Slog.e(TAG, &quot;Failed to instantiate class &quot; + info.name + &quot; from sourceDir &quot; + info.applicationInfo.sourceDir); return null; &#125; if (DEBUG_PROVIDER) Slog.v( TAG, &quot;Instantiating local provider &quot; + info.name); // XXX Need to create the correct context for this provider. localProvider.attachInfo(c, info);//进入ContentProvider&#125; catch (java.lang.Exception e) &#123; if (!mInstrumentation.onException(null, e)) &#123; throw new RuntimeException( &quot;Unable to get provider &quot; + info.name + &quot;: &quot; + e.toString(), e); &#125; return null; ...&#125; //ContentProvider.javaprivate void attachInfo(Context context, ProviderInfo info, boolean testing) &#123; mNoPerms = testing; mCallingPackage = new ThreadLocal&lt;&gt;(); /* * Only allow it to be set once, so after the content service gives * this to us clients can&#x27;t change it. */ if (mContext == null) &#123; mContext = context; if (context != null &amp;&amp; mTransport != null) &#123; mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService( Context.APP_OPS_SERVICE); &#125; mMyUid = Process.myUid(); if (info != null) &#123; setReadPermission(info.readPermission); setWritePermission(info.writePermission); setPathPermissions(info.pathPermissions); mExported = info.exported; mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0; setAuthorities(info.authority); &#125; ContentProvider.this.onCreate();//调用生命周期函数 &#125;&#125; 由以上代码可知，Provider的创建步骤如下： 创建ContextImpl和Instrumentation 创建Application对象 启动当前进程的ContentProvider并调用其onCreate 调用Application的onCreate方法 流程图 参考 《Android开发艺术探索》","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Service工作过程","slug":"Android/基础/Service工作过程","date":"2021-06-07T01:45:07.542Z","updated":"2021-07-09T06:53:26.093Z","comments":true,"path":"wiki/Android/基础/Service工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Service%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"概述Service是一种计算型组件，其生命是嵌套在主线程中的。Service有两种状态：启动状态和绑定状态，并且只能显示启动，因此在AndroidManifest.xml中注册Service时，只需要注册服务的类名即可。启动状态和绑定状态的区别在于：启动之后，Service的动作不受Activity的控制；而绑定之后，Service的动作是由Activity控制的。在实现Service时，需要继承Service抽象类，并且重写onCreat()方法，因此，Service也具有启动和停止的概念。 Service是Android四大组件之一，用于执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。组件可通过绑定到服务与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可在后台处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序进行交互。 Service分为以下几种不同的类型： 前台：前台服务必须显示通知（Notification），可以跟用户交互，比如播放音乐。 后台：用户无感知，可以做一些数据存储之类的事情。 绑定：使用bindService进行绑定。此种类型方便与其他组件进行交互。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 服务既可以是启动服务（以无限期运行），也支持绑定。唯一的问题在于是否实现一组回调方法：onStartCommand()（让组件启动服务）和 onBind()（实现服务绑定）。 基本使用Service的使用跟Activity类似，需要先在清单文件中声明，然后使用Context启动（startService(Intent)）或绑定服务。服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非在清单文件中配置）。如果有耗时操作，则可以在服务内创建线程来处理。 API 方法 描述 onStartCommand() 其他组件(如活动)通过调用startService()来请求启动服务时，系统调用该方法。如果你实现该方法，你有责任在工作完成时通过stopSelf()或者stopService()方法来停止服务。 onBind 当其他组件想要通过bindService()来绑定服务时，系统调用该方法。如果你实现该方法，你需要返回IBinder对象来提供一个接口，以便客户来与服务通信。你必须实现该方法，如果你不允许绑定，则直接返回null。 onUnbind() 当客户中断所有服务发布的特殊接口时，系统调用该方法。 onRebind() 当新的客户端与服务连接，且此前它已经通过onUnbind(Intent)通知断开连接时，系统调用该方法。 onCreate() 当服务通过onStartCommand()和onBind()被第一次创建的时候，系统调用该方法。该调用要求执行一次性安装。 onDestroy() 当服务不再有用或者被销毁时，系统调用该方法。你的服务需要实现该方法来清理任何资源，如线程，已注册的监听器，接收器等。 如果组件通过调用 startService() 启动服务（这会引起对 onStartCommand() 的调用），则服务会一直运行，直到其使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 将其停止为止。 如果组件通过调用 bindService() 来创建服务，且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。当该服务与其所有组件取消绑定后，系统便会将其销毁。 onStartCommand的注意事项1public @StartResult int onStartCommand(Intent intent, @StartArgFlags int flags, int startId)&#123;&#125; 参数 intent 启动时传入的参数，当Service重启时可能为空 flags 0：正常创建 START_FLAG_REDELIVERY：onStartCommand返回的是START_REDELIVER_INTENT，并且Service被系统清理掉了，那么重新创建Service，调用onStartCommand的时候，传入的intent不为null，而传入的flags就是START_FLAG_REDELIVERY START_FLAG_RETRY：如果Service创建过程中，onStartCommand方法未被调用或者没有正常返回的异常情况下， 再次尝试创建，传入的flags就为START_FLAG_RETRY 。 startId 用来代表这个唯一的启动请求。我们可以在stopSelfResult(int startId)中传入这个startId，用来终止Service。 返回值 START_STICKY：如果Service所在的进程，在执行了onStartCommand方法后，被清理了，那么这个Service会被保留在已开始的状态，但是不保留传入的Intent，随后系统会尝试重新创建此Service，由于服务状态保留在已开始状态，所以创建服务后一定会调用onStartCommand方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null，需要我们小心处理。 START_NOT_STICKY：如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service。 START_REDELIVER_INTENT：如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则结果和START_STICKY一样，也会重新创建此Service并调用onStartCommand方法。不同之处在于，如果是返回的是START_REDELIVER_INTENT ，则重新创建Service时onStartCommand方法会传入之前的intent。 START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但是不能保证被清理后onStartCommand方法一定会被重新调用。 生命周期 源码分析Service的启动方式是Context.startService(Intent service)。而Context的实现类为ContextImpl 12345678910111213141516171819202122232425262728293031323334@Overridepublic ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, false, mUser);&#125;private ComponentName startServiceCommon(Intent service, boolean requireForeground, UserHandle user) &#123; try &#123; validateServiceIntent(service); service.prepareToLeaveProcess(this); ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); if (cn != null) &#123; if (cn.getPackageName().equals(&quot;!&quot;)) &#123; throw new SecurityException( &quot;Not allowed to start service &quot; + service + &quot; without permission &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123; throw new SecurityException( &quot;Unable to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123; throw new IllegalStateException( &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 由以上代码可知，调用了AMS中的startService方法 1234567891011121314151617181920212223242526272829303132@Overridepublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(&quot;startService&quot;); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;); &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res; try &#123; res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, requireForeground, callingPackage, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return res; &#125;&#125; 这里的mServices为ActiveServices，它是用来对Service进行管理的。我们进去看看startServiceLocked 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId) throws TransactionTooLargeException &#123; return startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired, callingPackage, userId, false);&#125;ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId, boolean allowBackgroundActivityStarts) throws TransactionTooLargeException &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; args=&quot; + service.getExtras()); ... if (allowBackgroundActivityStarts) &#123; r.whitelistBgActivityStartsOnServiceStart(); &#125; ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); return cmp;&#125;ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; ServiceState stracker = r.getTracker(); ... String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); if (error != null) &#123; return new ComponentName(&quot;!!&quot;, error); &#125; ... return r.name;&#125;private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; ... if (!isolated) &#123; app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid + &quot; app=&quot; + app); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats); realStartServiceLocked(r, app, execInFg); return null; &#125; catch (TransactionTooLargeException e) &#123; throw e; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortInstanceName, e); &#125; &#125; &#125; else &#123; app = r.isolatedProc; if (WebViewZygote.isMultiprocessEnabled() &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123; hostingRecord = HostingRecord.byWebviewZygote(r.instanceName); &#125; if ((r.serviceInfo.flags &amp; ServiceInfo.FLAG_USE_APP_ZYGOTE) != 0) &#123; hostingRecord = HostingRecord.byAppZygote(r.instanceName, r.definingPackageName, r.definingUid); &#125; &#125; ... return null;&#125; private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; r.setProcess(app);//绑定进程...try &#123; if (LOG_SERVICE_START_STOP) &#123; String nameTerm; int lastPeriod = r.shortInstanceName.lastIndexOf(&#x27;.&#x27;); nameTerm = lastPeriod &gt;= 0 ? r.shortInstanceName.substring(lastPeriod) : r.shortInstanceName; EventLogTags.writeAmCreateService( r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid); &#125; StatsLog.write(StatsLog.SERVICE_LAUNCH_REPORTED, r.appInfo.uid, r.name.getPackageName(), r.name.getClassName()); synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo), app.getReportedProcState()); r.postNotification(); created = true;&#125; catch (DeadObjectException e) &#123; Slog.w(TAG, &quot;Application dead when creating service &quot; + r); mAm.appDiedLocked(app); throw e;&#125; finally &#123; &#125;... sendServiceArgsLocked(r, execInFg, true);//执行onStartCommand过程&#125;private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) throws TransactionTooLargeException &#123; ... Exception caughtException = null; try &#123; r.app.thread.scheduleServiceArgs(r, slice); //调用ActivityThread &#125; catch (TransactionTooLargeException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Transaction too large for &quot; + args.size() + &quot; args, first: &quot; + args.get(0).args); Slog.w(TAG, &quot;Failed delivering service starts&quot;, e); caughtException = e; &#125; catch (RemoteException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while sending args: &quot; + r); Slog.w(TAG, &quot;Failed delivering service starts&quot;, e); caughtException = e; &#125; catch (Exception e) &#123; Slog.w(TAG, &quot;Unexpected exception&quot;, e); caughtException = e; &#125; ...&#125; 由以上代码可知，startServiceLocked调用了startServiceInnerLocked，startServiceInnerLocked调用了bringUpServiceLocked，bringUpServiceLocked调用了realStartServiceLocked，realStartServiceLocked调用了ActivityThread的scheduleCreateService。且realStartServiceLocked还会调用sendServiceArgsLocked，sendServiceArgsLocked调用ActivityThread的scheduleServiceArgs，这里会启动onStartCommand 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125;public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; ... case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SERVICE_ARGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj))); handleServiceArgs((ServiceArgsData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...&#125;private void handleCreateService(CreateServiceData data) &#123; //创建对象 LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; ClassLoader cl = packageInfo.getClassLoader(); //创建service对象 service = packageInfo.getAppFactory() .instantiateService(cl, data.info.name, data.intent); &#125; catch (Exception e) &#123;&#125; try &#123; //创建上下文 ContextImpl context = ContextImpl.createAppContext(this, packageInfo); //关联service对象 context.setOuterContext(service); //获取Application对象 Application app = packageInfo.makeApplication(false, mInstrumentation); //关联上下文和Application对象 service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); service.onCreate(); //data.token都是ServiceRecord，它是binder对象，token与service建立映射关系存储在mServices的map中 mServices.put(data.token, service); &#125; catch (Exception e) &#123;&#125;&#125; //onStartCommand流程 public final void scheduleServiceArgs(IBinder token, ParceledListSlice args) &#123; List&lt;ServiceStartArgs&gt; list = args.getList(); for (int i = 0; i &lt; list.size(); i++) &#123; ServiceStartArgs ssa = list.get(i); ServiceArgsData s = new ServiceArgsData(); s.token = token; s.taskRemoved = ssa.taskRemoved; s.startId = ssa.startId; s.flags = ssa.flags; s.args = ssa.args; sendMessage(H.SERVICE_ARGS, s); &#125;&#125; private void handleServiceArgs(ServiceArgsData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; if (data.args != null) &#123; data.args.setExtrasClassLoader(s.getClassLoader()); data.args.prepareToEnterProcess(); &#125; int res; if (!data.taskRemoved) &#123; res = s.onStartCommand(data.args, data.flags, data.startId);//运行了onStartCommand方法 &#125; else &#123; s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; QueuedWork.waitToFinish(); try &#123; ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_START, data.startId, res); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( &quot;Unable to start service &quot; + s + &quot; with &quot; + data.args + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125;&#125; 由以上代码可知 scheduleCreateService发送了CREATE_SERVICE消息。ActivityThread的内部类H处理此消息，在handleCreateService方法中，运行了Service的onCreate方法。 scheduleServiceArgs发送了SERVICE_ARGS的消息。在handleServiceArgs中处理，调用了onStartCommand方法 流程图 关于Service保活应该是利用service的机制，当service下一次重新创建时判断应用中的某些场景是否也可以跟着一起恢复。比如直播房间。 参考 Android 10 Service 工作过程 《Android开发艺术探索》 https://developer.android.com/guide/components/services?hl=zh-cn","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"View的事件分发机制","slug":"Android/基础/View的事件分发机制","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-29T02:15:52.364Z","comments":true,"path":"wiki/Android/基础/View的事件分发机制/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","excerpt":"","text":"分发过程事件分发过程由三个方法共同完成： dispatchTouchEvent方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。 onInterceptTouchEvent方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给子View 处理, 此时相当于return false。 如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。 onTouchEvent方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况： 如果该View是clickable或者longclickable的,则会返回true, 表示消费 了该事件, 与返回true一样; 如果该View不是clickable或者longclickable的,则会返回false, 表示不 消费该事件,将会向上传递,与返回false一样。 注意：在Android系统中，拥有事件传递处理能力的类有以下三种： Activity：拥有分发和消费两个方法。 ViewGroup：拥有分发、拦截和消费三个方法。 View：拥有分发、消费两个方法。 三个方法的关系用伪代码表示如下： 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; coonsume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 通过上面的伪代码，我们可以大致了解点击事件的传递规则：对应一个根ViewGroup来说，点击事件产生后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会返回true消耗这个事件。如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。 一些重要的结论： 事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。 正常情况下，一个时间序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。特例：通过将重写View的onTouchEvent返回false可强行将事件转交给其他View处理。 如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件（返回false）。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。 View的enable属性不影响onTouchEvent的默认返回值。 通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 ACTION_CANCEL什么时候触发，触摸button然后滑动到外部抬起会触发点击事件吗，再滑动回去抬起会么？ 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。 点击事件被拦截，但是想传到下面的View，如何操作？ 重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。如何解决View的事件冲突？举个开发中遇到的例子？ 常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。 滑动冲突的处理规则： 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。 滑动冲突的实现方法： 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"View的基本概念","slug":"Android/基础/View的基本概念","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-07T01:45:07.542Z","comments":true,"path":"wiki/Android/基础/View的基本概念/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"View的工作流程","slug":"Android/基础/View的工作流程","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-29T01:50:45.208Z","comments":true,"path":"wiki/Android/基础/View的工作流程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"DecorView是视图的顶级View，我们添加的布局文件是它的一个子布局，而ViewRootImpl则负责渲染视图，它调用了一个performTraveals方法使得ViewTree开始三大工作流程，然后使得View展现在我们面前。 绘制的流程概要 注意：这里的三个步骤是每次从根视图到最上层视图依次执行完，再进行下一步骤。 三个步骤： 测量（measure）：测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。 布局（layout）：确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。 绘制（draw）：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤： 绘制视图的背景； 保存画布的图层（Layer）； 绘制View的内容； 绘制View子视图，如果没有就不用； 还原图层（Layer）； 绘制滚动条 绘制从ViewRootImpl的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。 12345678910111213141516private void performTraversals() &#123; ... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... //执行测量流程 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... //执行布局流程 performLayout(lp, desiredWindowWidth, desiredWindowHeight); ... //执行绘制流程 performDraw();&#125; measureMeasureSpecMeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。 mode的模式分为： EXACTLY：对应LayoutParams中的match_parent和具体数值这两种模式。检测到View所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值， AT_MOST ：对应LayoutParams中的wrap_content。View的大小不能大于父容器的大小。 UNSPECIFIED ：不对View进行任何限制，要多大给多大，一般用于系统内部，如ListView，ScrollView 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * UNSPECIFIED 模式： * 父View不对子View有任何限制，子View需要多大就多大 */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * EXACTYLY 模式： * 父View已经测量出子Viwe所需要的精确大小，这时候View的最终大小 * 就是SpecSize所指定的值。对应于match_parent和精确数值这两种模式 */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * AT_MOST 模式： * 子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值， * 即对应wrap_content这种模式 */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //将size和mode打包成一个32位的int型数值 //高2位表示SpecMode，测量模式，低30位表示SpecSize，某种测量模式下的规格大小 public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; //将32位的MeasureSpec解包，返回SpecMode,测量模式 public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //将32位的MeasureSpec解包，返回SpecSize，某种测量模式下的规格大小 public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; //... &#125; ViewGroup的measure由于DecorView继承自FrameLayout，是PhoneWindow的一个内部类，而FrameLayout没有measure方法，因此调用的是父类View的measure方法。 View的measurelayoutView的layout流程123456789101112131415161718192021222324// ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125;// View.javapublic void layout(int l, int t, int r, int b) &#123; ... // 通过setFrame方法来设定View的四个顶点的位置，即View在父容器中的位置 boolean changed = isLayoutModeOptical(mParent) ? set OpticalFrame(l, t, r, b) : setFrame(l, t, r, b); ... onLayout(changed, l, t, r, b); ...&#125;// 空方法，子类如果是ViewGroup类型，则重写这个方法，实现ViewGroup// 中所有View控件布局流程protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; Layout的onLayout12345678910111213141516171819202122232425262728293031323334353637383940414243protected void onlayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l,) &#125;&#125;// layoutVertical核心源码void layoutVertical(int left, int top, int right, int bottom) &#123; ... final int count = getVirtualChildCount(); for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasureWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); ... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; // 为子元素确定对应的位置 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); // childTop会逐渐增大，意味着后面的子元素会被 // 放置在靠下的位置 childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child,i) &#125; &#125;&#125;private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; draw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void performDraw() &#123; ... draw(fullRefrawNeeded); ...&#125;private void draw(boolean fullRedrawNeeded) &#123; ... if (!drawSoftware(surface, mAttachInfo, xOffest, yOffset, scalingRequired, dirty)) &#123; return; &#125; ...&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scallingRequired, Rect dirty) &#123; ... mView.draw(canvas); ...&#125;// 绘制基本上可以分为六个步骤public void draw(Canvas canvas) &#123; ... // 步骤一：绘制View的背景 drawBackground(canvas); ... // 步骤二：如果需要的话，保持canvas的图层，为fading做准备 saveCount = canvas.getSaveCount(); ... canvas.saveLayer(left, top, right, top + length, null, flags); ... // 步骤三：绘制View的内容 onDraw(canvas); ... // 步骤四：绘制View的子View dispatchDraw(canvas); ... // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层 canvas.drawRect(left, top, right, top + length, p); ... canvas.restoreToCount(saveCount); ... // 步骤六：绘制View的装饰(例如滚动条等等) onDrawForeground(canvas)&#125; 常见问题如何在onCreate中获取View的高宽12345678910111213141516171819202122//方法1：view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getWidth(); int measuredWidth = view.getMeasuredWidth(); Log.i(TAG, &quot;width: &quot; + width); Log.i(TAG, &quot;measuredWidth: &quot; + measuredWidth); &#125; &#125;);//方法2：ViewTreeObserver vto = view.getViewTreeObserver(); vto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeGlobalOnLayoutListener(this); Log.i(TAG, &quot;width: &quot; + view.getWidth()); Log.i(TAG, &quot;height: &quot; + view.getHeight()); &#125; &#125;); 参考 https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Binder","slug":"Android/进阶知识/Binder","date":"2021-06-07T01:45:07.542Z","updated":"2021-07-09T08:56:52.450Z","comments":true,"path":"wiki/Android/进阶知识/Binder/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/Binder/","excerpt":"","text":"一个进程空间分为: 用户空间：数据不可共享，所以用户空间 = 不可共享空间 内核空间：数据可共享，所以内核空间 = 可共享空间 Binder 的作用则是:连接两个进程，实现了mmap()系统调用，主要负责创建数据接收的缓存空间 &amp; 管理数据接收缓存。传统的跨进程通信需拷贝数据2次，但 Binder 机制只需1次，主要是使用到了内存映射 Android中IPC的不同方式比较 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件间的进程间通信 文件共享 简单易用 不适合高并发场景，并且无法做到进程间的即时通信 无并发访问场景 AIDL 功能强大，支持一对多并发通信，支持实时通信 无 一对多通信且有RPC需求 Messager 功能一般，支持一对多并发通信，支持实时通信 不能很好处理高并发场景，不支持RPC 低并发的一对多通信，无RPC需求 ContentProvider 在数据源访问方面功能强大 Socket 功能强大 参考 https://www.jianshu.com/p/719fc4758813","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Activity工作过程","slug":"Android/基础/Activity工作过程","date":"2021-06-07T01:45:07.541Z","updated":"2021-07-09T07:13:32.080Z","comments":true,"path":"wiki/Android/基础/Activity工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Activity%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"概述Activity是一种展示型组件，具有两种启动方式，一种是显示的，通过intent实现；另一种是隐式的，也需要intent，但还需要在AndroidManifest.xml中添加intentfilter。在实现Activity时，需要继承Activity抽象类，并且重写onCreat()方法，因此，Activity具有启动和停止的概念。 流程分析类介绍 Activity：startActivity方法的真正实现在Activity中。 Instrumentation:用来辅助Activity完成启动Activity的过程。 ActivityThread(包含ApplicationThread + ApplicationThreadNative + IApplicationThread):真正启动Activity的实现都在这里。 ApplicationThread ActivityTaskManager ActivityStarter RootActivityContainer ActivityStack ActivityStackSupervisor ClientLifecycleManager ClientTransaction ActivityRecord： service（ActivityManager）：AMS的引用 info（ActivityInfo）： 节点信息，比如lanuchMode state：当前状态 task（TaskRecord） 流程图 Activity的启动从startActivity开始，代码会运行到Activity的startActivityForResult方法。 123456789101112131415161718192021222324252627282930313233343536373839Activity.javapublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; mParent代表的是ActivityGroup，ActivityGroup最开始被用来在一个界面中嵌入多个子Activity，但是其在API 13中已经被废弃了，系统推荐采用Fragment来代替ActivityGroup。 mMainThread.getApplicationThread()这个参数，它的类型是ApplicationThread，ApplicationThread是ActivityThread的内部类，继承IApplicationThread.Stub，也是个Binder对象。 接下来看看execStartActivity方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Instrumentation.java@UnsupportedAppUsagepublic ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityTaskManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查Activity启动的结果 //比如如果没有注册，则会抛出ActivityNotFoundException checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125;public static void checkStartActivityResult(int res, Object intent) &#123; if (!ActivityManager.isStartResultFatalError(res)) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( &quot;Unable to find explicit activity class &quot; + ((Intent)intent).getComponent().toShortString() + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;); throw new ActivityNotFoundException( &quot;No Activity found to handle &quot; + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(&quot;Not allowed to start activity &quot; + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( &quot;PendingIntent is not an activity&quot;); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( &quot;Starting under voice control not allowed for: &quot; + intent); case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startVoiceActivity does not match active session&quot;); case ActivityManager.START_VOICE_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start voice activity on a hidden session&quot;); case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startAssistantActivity does not match active session&quot;); case ActivityManager.START_ASSISTANT_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start assistant activity on a hidden session&quot;); case ActivityManager.START_CANCELED: throw new AndroidRuntimeException(&quot;Activity could not be started for &quot; + intent); default: throw new AndroidRuntimeException(&quot;Unknown error code &quot; + res + &quot; when starting &quot; + intent); &#125;&#125; 这里使用了ActivityTaskManager来启动Activity。ActivityTaskManager是一个Binder。ActivityTaskManager.getService()会返回Activity服务管理器ActivityManagerService(Android10返回ActivityTaskManagerService)。 ATMS是在Android10中新增的，分担了之前ActivityManagerService（AMS）的一部分功能（activity task相关）。在Android10 之前 ，这个地方获取的是服务是AMS。查看Android10的AMS，你会发现startActivity方法内也是调用了ATMS的startActivity方法。所以在理解上，ATMS就隶属于AMS。 接下来要去ActivityTaskManagerService看看了 Activity的管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ActivityTaskManagerService.java@Overridepublic final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) &#123; final String reason = &quot;startActivities&quot;; enforceNotIsolatedCaller(reason); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, reason); // TODO: Switch to user app stacks here. return getActivityStartController().startActivities(caller, -1, 0, -1, callingPackage, intents, resolvedTypes, resultTo, SafeActivityOptions.fromBundle(bOptions), userId, reason, null /* originatingPendingIntent */, false /* allowBackgroundActivityStart */);&#125;@Overridepublic int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; enforceNotIsolatedCaller(&quot;startActivityAsUser&quot;); userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;); // TODO: Switch to user app stacks here. return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;) .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute();&#125; getActivityStartController().obtainStarter方法获取ActivityStarter实例，进去看看execute。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596ActivityStarter.java/** * Starts an activity based on the request parameters provided earlier. * @return The starter result. */int execute() &#123; try &#123; // TODO(b/64750076): Look into passing request directly to these methods to allow // for transactional diffs and preprocessing. if (mRequest.mayWait) &#123; //也会执行到startActivity方法 return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); &#125; else &#123; return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); &#125; &#125; finally &#123; onExecutionComplete(); &#125;&#125;private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123; int result = START_CANCELED; final ActivityStack startedActivityStack; try &#123; mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity, restrictedBgActivity); ... &#125; private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123;...if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTaskRecord().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // If the activity is not focusable, we can&#x27;t resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don&#x27;t want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. mTargetStack.ensureActivitiesVisibleLocked(mStartActivity, 0, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mTargetStack.getDisplay().mDisplayContent.executeAppTransition(); &#125; else &#123; // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isFocusable() &amp;&amp; !mRootActivityContainer.isTopDisplayFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;); &#125; mRootActivityContainer.resumeFocusedStacksTopActivities( mTargetStack, mStartActivity, mOptions); &#125;&#125; else if (mStartActivity != null) &#123; mSupervisor.mRecentTasks.add(mStartActivity.getTaskRecord());&#125;mRootActivityContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);...&#125; startActivityMayWait最终也是会进入startActivity，startActivity调用了startActivityUnchecked，startActivityUnchecked调用了mRootActivityContainer.resumeFocusedStacksTopActivities(mTargetStack, mStartActivity, mOptions);。mRootActivityContainer是RootActivityContainer，Android10新增到API，分担了ActivityStackSupervisor部分功能。接着看看RootActivityContainer 12345678910111213141516RootActivityContainer.javaboolean resumeFocusedStacksTopActivities( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (!mStackSupervisor.readyToResume()) &#123; return false; &#125; boolean result = false; if (targetStack != null &amp;&amp; (targetStack.isTopStackOnDisplay() || getTopDisplayFocusedStack() == targetStack)) &#123; result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; ... &#125; 接着跳转到了ActivityStack的resumeTopActivityUncheckedLocked方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ActivityStack.java@GuardedBy(&quot;mService&quot;)boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mInResumeTopActivity) &#123; // Don&#x27;t even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mInResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); // When resuming the top activity, it may be necessary to pause the top activity (for // example, returning to the lock screen. We suppress the normal pause logic in // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here // to ensure any necessary pause logic occurs. In the case where the Activity will be // shown regardless of the lock screen, the call to // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped. final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) &#123; checkReadyForSleep(); &#125; &#125; finally &#123; mInResumeTopActivity = false; &#125; return result;&#125;@GuardedBy(&quot;mService&quot;)private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;... boolean pausing = getDisplay().pauseBackStacks(userLeaving, next, false); if (mResumedActivity != null) &#123; if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); // 暂停上一个Activity pausing |= startPausingLocked(userLeaving, false, next, false); &#125; ... //这里next.attachedToProcess()，只有启动了的Activity才会返回true if (next.attachedToProcess()) &#123; ... try &#123; final ClientTransaction transaction = ClientTransaction.obtain(next.app.getThread(), next.appToken); ... //启动了的Activity就发送ResumeActivityItem事务给客户端了，后面会讲到 transaction.setLifecycleStateRequest( ResumeActivityItem.obtain(next.app.getReportedProcState(), getDisplay().mDisplayContent.isNextTransitionForward())); mService.getLifecycleManager().scheduleTransaction(transaction); .... &#125; catch (Exception e) &#123; .... mStackSupervisor.startSpecificActivityLocked(next, true, false); return true; &#125; .... &#125; else &#123; .... if (SHOW_APP_STARTING_PREVIEW) &#123; //这里就是 冷启动时 出现白屏 的原因了：取根Activity的主题背景 展示StartingWindow next.showStartingWindow(null , false ,false); &#125; // 继续当前Activity，普通Activity的正常启动 关注这里即可 //ActivityStackSupervisor.java mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; 接下来到了ActivityStackSupervisor的startSpecificActivityLocked方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677ActivityStackSupervisor.javavoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity&#x27;s application already running? final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; if (wpc != null &amp;&amp; wpc.hasThread()) &#123; try &#123; realStartActivityLocked(r, wpc, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); &#125; knownToBeDead = true; &#125; ... try &#123; if (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;dispatchingStartProcess:&quot; + r.processName); &#125; // 上面的wpc != null &amp;&amp; wpc.hasThread()不满足的话，说明没有进程，就会去创建进程 final Message msg = PooledLambda.obtainMessage( ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName, r.info.applicationInfo, knownToBeDead, &quot;activity&quot;, r.intent.getComponent()); mService.mH.sendMessage(msg); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125;boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... // Create activity launch transaction. final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.appToken); final DisplayContent dc = r.getDisplay().mDisplayContent; //添加了启动Activity的Item clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(), r.icicle, r.persistentState, results, newIntents, dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(), r.assistToken)); // Set desired final state. final ActivityLifecycleItem lifecycleItem; if (andResume) &#123; lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward()); &#125; else &#123; lifecycleItem = PauseActivityItem.obtain(); &#125; clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. //ActivityTaskManagerService获取ClientLifecycleManager mService.getLifecycleManager().scheduleTransaction(clientTransaction); ... return true;&#125; 由以上代码可知，ClientTransaction包含一系列的待客户端处理的事务的容器，客户端接收后取出事务并执行。其添加了LaunchActivityItem、ResumeActivityItem等。然后运行ClientLifecycleManager的scheduleTransaction 123456789101112131415161718192021ClientLifecycleManager.java/** * Schedule a transaction, which may consist of multiple callbacks and a lifecycle request. * @param transaction A sequence of client transaction items. * @throws RemoteException * * @see ClientTransaction */void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; final IApplicationThread client = transaction.getClient(); //ClientTransaction transaction.schedule(); if (!(client instanceof Binder)) &#123; // If client is not an instance of Binder - it&#x27;s a remote call and at this point it is // safe to recycle the object. All objects used for local calls will be recycled after // the transaction is executed on client in ActivityThread. transaction.recycle(); &#125;&#125; 123456ClientTransaction.javapublic void schedule() throws RemoteException &#123;//ApplicationThread mClient.scheduleTransaction(this);&#125; IApplicationThread是ApplicationThread在系统进程的代理，所以真正执行的地方是客户端的ApplicationThread。 现有流程如下：启动Activity的操作从客户端跨进程转移到ATMS，ATMS通过ActivityStarter、ActivityStack、ActivityStackSupervisor对Activity任务、Activity栈、Activity记录管理后，又用过跨进程把正在启动过程又转移到了客户端。 流程图如下： 线程切换及消息处理接下来看看ApplicationThread的scheduleTransaction scheduleTransaction会发送Message，ActivityThread内部类H处理此消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//ApplicationThread.java@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; ActivityThread.this.scheduleTransaction(transaction);&#125;//ActivityThread.java@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;//会调用sendMessage ActivityThread.this.scheduleTransaction(transaction);&#125;private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);//对应mH会处理消息，H是ActivityThread的内部类&#125;//ClientTransactionHandler.java 是ActivityThread的父类void scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);&#125;//class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; //这里处理消息 //TransactionExecutor mTransactionExecutor.execute(transaction); if (isSystem()) &#123; // Client transactions inside system process are recycled on the client side // instead of ClientLifecycleManager to avoid being cleared before this // message is handled. transaction.recycle(); &#125; // TODO(lifecycler): Recycle locally scheduled transactions. break; case RELAUNCH_ACTIVITY: handleRelaunchActivityLocally((IBinder) msg.obj); break; &#125; &#125;&#125; 最终到了TransactionExecutor的execute方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//TransactionExecutor.javapublic void execute(ClientTransaction transaction) &#123; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;Start resolving transaction&quot;); final IBinder token = transaction.getActivityToken(); if (token != null) &#123; final Map&lt;IBinder, ClientTransactionItem&gt; activitiesToBeDestroyed = mTransactionHandler.getActivitiesToBeDestroyed(); final ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token); if (destroyItem != null) &#123; if (transaction.getLifecycleStateRequest() == destroyItem) &#123; // It is going to execute the transaction that will destroy activity with the // token, so the corresponding to-be-destroyed record can be removed. activitiesToBeDestroyed.remove(token); &#125; if (mTransactionHandler.getActivityClient(token) == null) &#123; // The activity has not been created but has been requested to destroy, so all // transactions for the token are just like being cancelled. Slog.w(TAG, tId(transaction) + &quot;Skip pre-destroyed transaction:\\n&quot; + transactionToString(transaction, mTransactionHandler)); return; &#125; &#125; &#125; if (DEBUG_RESOLVER) Slog.d(TAG, transactionToString(transaction, mTransactionHandler)); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;End resolving transaction&quot;);&#125;public void executeCallbacks(ClientTransaction transaction) &#123; final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null || callbacks.isEmpty()) &#123; // No callbacks to execute, return early. return; &#125; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;Resolving callbacks in transaction&quot;); final IBinder token = transaction.getActivityToken(); ActivityClientRecord r = mTransactionHandler.getActivityClient(token); // In case when post-execution state of the last callback matches the final state requested // for the activity in this transaction, we won&#x27;t do the last transition here and do it when // moving to final state instead (because it may contain additional parameters from server). final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest(); final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState() : UNDEFINED; // Index of the last callback that requests some post-execution state. final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);//遍历callbacks，调用ClientTransactionItem的execute方法//LaunchActivityItem会在这里调用execute final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; final ClientTransactionItem item = callbacks.get(i); ... item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ... &#125;&#125; 继续查看LaunchActivityItem的execute 1234567891011121314LaunchActivityItem.java@Overridepublic void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client, mAssistToken); client.handleLaunchActivity(r, pendingActions, null /* customIntent */); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);&#125; 里面调用了client.handleLaunchActivity方法，client是ClientTransactionHandler的实例，是在TransactionExecutor构造方法传入的，TransactionExecutor创建是在ActivityThread中,所以，client.handleLaunchActivity方法就是ActivityThread的handleLaunchActivity方法。 流程图如下： Activity初始化及生命周期函数回调123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111ActivityThread.javapublic Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; ... final Activity a = performLaunchActivity(r, customIntent); ... return a;&#125;/** activity 启动的核心实现. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //1、从ActivityClientRecord获取待启动的Activity的组件信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //创建ContextImpl对象 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; //2、创建activity实例 java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; .. &#125; try &#123; //3、创建Application对象（如果没有的话） Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); //4、attach方法为activity关联上下文环境 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //5、调用生命周期onCreate if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); &#125; r.activity = activity; &#125; r.setState(ON_CREATE); synchronized (mResourcesManager) &#123; mActivities.put(r.token, r); &#125; &#125; ... return activity;&#125; 由以上代码可知，performLaunchActivity主要完成以下事情： 从ActivityClientRecord获取待启动的Activity的组件信息 通过mInstrumentation.newActivity方法使用类加载器创建activity实例 通过LoadedApk的makeApplication方法创建Application对象，内部也是通过mInstrumentation使用类加载器，创建后就调用了instrumentation.callApplicationOnCreate方法，也就是Application的onCreate方法。 创建ContextImpl对象并通过activity.attach方法对重要数据初始化，关联了Context的具体实现ContextImpl，attach方法内部还完成了window创建，这样Window接收到外部事件后就能传递给Activity了。 调用Activity的onCreate方法，是通过 mInstrumentation.callActivityOnCreate方法完成。 其他生命周期处理也是类似的，先在ActivityStackSupervisor中添加对应的XXXActivityItem，然后在ActivityThread中的handleXXXActivity处理。 总结归纳整体流程图如下： 一些类的介绍： 类名 作用 ActivityThread 应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程） ApplicationThread 是ActivityThread的内部类，继承IApplicationThread.Stub，是一个IBinder，是ActiivtyThread和AMS通信的桥梁，AMS则通过代理调用此App进程的本地方法，运行在Binder线程池 H 继承Handler，在ActivityThread中初始化，即主线程Handler，用于主线程所有消息的处理。本片中主要用于把消息从Binder线程池切换到主线程 Intrumentation 具有跟踪application及activity生命周期的功能，用于监控app和系统的交互 ActivityManagerService Android中最核心的服务之一，负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。 ActivityTaskManagerService 管理activity及其容器（task, stacks, displays）的系统服务（Android10中新增，分担了AMS的部分职责） ActivityStarter 用于解释如何启动活动。该类收集所有逻辑，用于确定Intent和flag应如何转换为活动以及相关的任务和堆栈 ActivityStack 用来管理系统所有的Activity，内部维护了Activity的所有状态和Activity相关的列表等数据 ActivityStackSupervisor 负责所有Activity栈的管理。AMS的stack管理主要有三个类，ActivityStackSupervisor，ActivityStack和TaskRecord ClientLifecycleManager 客户端生命周期执行请求管理 ClientTransaction 是包含一系列的 待客户端处理的事务 的容器，客户端接收后取出事务并执行 LaunchActivityItem、ResumeActivityItem 继承ClientTransactionItem，客户端要执行的事务信息，启动activity 参考 https://juejin.cn/post/6847902222294990862 《Android开发艺术探索》","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"volatile详解二","slug":"Java/并发编程/volatile详解二","date":"2021-06-03T07:09:12.139Z","updated":"2021-06-03T07:09:39.734Z","comments":true,"path":"wiki/Java/并发编程/volatile详解二/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile%E8%AF%A6%E8%A7%A3%E4%BA%8C/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"线程间通讯方式","slug":"Java/并发编程/线程间通讯方式","date":"2021-06-02T13:18:54.990Z","updated":"2021-07-07T09:21:23.097Z","comments":true,"path":"wiki/Java/并发编程/线程间通讯方式/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/","excerpt":"","text":"什么是线程安全？线程的工作原理，jvm有一个main memory，而每个线程有自己的working memory，一个线程对一个variable进行操作时，都要在自己的working memory里面建立一个copy，操作完之后再写入main memory。多个线程同时操作同一个variable，就可能会出现不可预知的结果。 而用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你 认为合适的object比如method，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完load到workingmemory -&gt; use&amp;assign -&gt; store到mainmemory 的过程，才会释放它得到的锁。这样就实现了所谓的线程安全。 线程安全就是说多线程访问同一块内存，不会产生不确定的结果。编写线程安全的代码是依靠线程同步。 CPU时间片轮转机制cpu 给每个进程分配一个“时间段”，这个时间段就叫做这个进程的“时间片”，这个时间片就是这个进程允许运行的时间，如果当这个进程的时间片段结束，操作系统就会把分配给这个进程的 cpu 剥夺，分配给另外一个进程。如果进程在时间片还没结束的情况下阻塞了，或者说进程跑完了，cpu 就会进行切换。cpu 在两个进程之间的切换称为“上下文切换”，上下文切换是需要时间的，大约需要花费 5000~20000(5 毫秒到 20 毫秒，这个花费的时间是由操作系统决定)个时钟周期，尽管我们平时感觉不到。所以在开发过程中要注意上下文切换(两个进程之间的切换)对我们程序性能的影响。 死锁造成死锁的四个条件： 互斥条件：资源只能被一个线程占用,如果其它线程请求获取该资源,则请求者只能等待,直到占用资源的线程释放该资源. 请求并持有条件：指一个线程已经持有了至少一个资源,但又提出了新的资源请求,而新的资源已被其他线程占 用,所以当前线程会被阻塞,但阻塞的同时不释放自己获取的资源. 不可剥夺条件：获取到的资源在自己使用完之前不能被其他线程抢占,只能在使用完之后释放. 环路等待条件：发生死锁的时候必然存在一个线程-资源的环形链,即线程集合{T0,T1,T2,…Tn}中的T0正在等待 一个T1占用的资源,T1正在等待T2占用的资源,…Tn正在等待T1占用的资源 通信方式 共享进程的变量 ThreadLocal 同步锁、信号量（Synchronize、Semaphore、Lock）","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"自定义View","slug":"Android/UI/自定义View","date":"2021-06-02T08:10:33.863Z","updated":"2021-07-20T10:22:42.308Z","comments":true,"path":"wiki/Android/UI/自定义View/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/%E8%87%AA%E5%AE%9A%E4%B9%89View/","excerpt":"","text":"概述自定义属性声明属性使用declare-styleable声明属性 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;attr name=&quot;enableOnPad&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;supportDeviceType&quot; format=&quot;reference&quot;/&gt; &lt;!-- 如果有通用的属性，可以抽离出来 --&gt; &lt;declare-styleable name=&quot;ExTextView&quot;&gt; &lt;attr name=&quot;enableOnPad&quot;/&gt; &lt;attr name=&quot;supportDeviceType&quot;/&gt; &lt;/declare-styleable&gt; &lt;declare-styleable name=&quot;ExEditText&quot;&gt; &lt;attr name=&quot;enableOnPad&quot;/&gt; &lt;attr name=&quot;supportDeviceType&quot;/&gt; &lt;attr name=&quot;line_color&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;line_stroke_height&quot; format=&quot;dimension&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 使用属性1234567891011public class CustomView extends View &#123; public DottedLineView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); // 根据Style拿到TypedArray TypedArray array = getContext().obtainStyledAttributes(attrs, R.styleable.ExEditText); mLineColor = array.getColor(R.styleable.ExEditText_line_color, getResources().getColor(R.color.Red)); mLineStrokeHeight = array.getDimension(R.styleable.ExEditText_line_stroke_height, dp2px(getContext(), 1)); array.recycle(); &#125;&#125; 需要注意的点让View支持wrap_content这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果 如果有必要，让你的View支持padding这是因为直接继承View的控件，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。 尽量不要在View中使用Handler，没必要这是因为View内部本身就提供了post系列的方法，完全可以替代Handler的作用，当然除非你很明确地要使用Handler来发送消息。 View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow如果有线程或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。当包含此View的Activity退出或者当前View被remove时，View的 onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄漏。 View带有滑动嵌套情形时，需要处理好滑动冲突参考 《Android开发艺术探索》 自定义控件进阶:declare-styleable重用attr","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Intent","slug":"Android/基础/Intent","date":"2021-06-02T08:08:23.044Z","updated":"2021-07-08T12:47:26.931Z","comments":true,"path":"wiki/Android/基础/Intent/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Intent/","excerpt":"","text":"介绍Intent是一个消息传递对象，他的作用： 启动Activity。不同的业务场景启动Activity又分为显示调用和隐式调用。 启动Service 传递广播 Intent的属性有:component(组件)、action、category、data、type、extras、flags;所有的属性也是各显神通，满足开发者的各种需要满足不同场景; component: 显然就是设置四大组件的， 将直接使用它指定的组件，借助这一属性可以实现不同应用组件之间通讯; action: 是一个可以 指定目标组件行为的字符串，开发人员可以自定义action通过匹配action实现组件之间的隐式跳转，当然Android系统也已经预定部分String作为系统应用Action，例如打开系统设置页面等等; data: 通常是URI类型或者MIME类型格式定义的操作数据;表示与动作要操纵的数据 Category: 属性用于指定当前动作(Action)被执行的环境; type: 对于data范例的描写; Intent.setFlags(int flags)设置启动模式 FLAG_ACTIVITY_CLEAR_TOP : 等同于mainfest中配置的singleTask FLAG_ACTIVITY_SINGLE_TOP: 同样等同于mainfest中配置的singleTop; FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS: 其对应在AndroidManifest中的属性为android:excludeFromRecents=“true”,当用户按了“最近任务列表”时候,该Task不会出现在最近任务列表中，可达到隐藏应用的目的。 FLAG_ACTIVITY_NO_HISTORY: 对应在AndroidManifest中的属性为:android:noHistory=“true”，这个FLAG启动的Activity，一旦退出，它不会存在于栈中。 FLAG_ACTIVITY_NEW_TASK : 这个属性需要在被start的目标Activity在AndroidManifest.xml文件 配置taskAffinity的值【必须和startActivity发其者Activity的包名不一样，如果是跳转另一个 App的话可以taskAffinity可以省略】，则会在新标记的Affinity所存在的taskAffinity中压入这个Activity。 参考 Intent和Intent过滤器","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"multitype","slug":"Android/开源库/multitype","date":"2021-06-02T06:05:16.123Z","updated":"2021-06-02T06:05:27.305Z","comments":true,"path":"wiki/Android/开源库/multitype/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/multitype/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"RecyclerView之概述","slug":"Android/UI/RecyclerView之概述","date":"2021-06-02T02:29:03.601Z","updated":"2021-07-21T08:28:26.312Z","comments":true,"path":"wiki/Android/UI/RecyclerView之概述/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E4%B9%8B%E6%A6%82%E8%BF%B0/","excerpt":"","text":"目录 RecyclerView之概述 RecyclerView之绘制流程 RecyclerView之Adapter RecyclerView之ItemDecoration RecyclerView之ItemAnimator RecyclerView之DiffUtil RecyclerView之缓存策略 相关类 RecyclerView SmoothScroller(RecyclerView内部类)：平滑的速度处理 LinearSmoothScroller：水平方向的处理，用于LinearSnapHelper中 ItemAnimator(RecyclerView内部类)：元素动画类 DefaultItemAnimator：默认动画类 SimpleItemAnimator：抽象类 Recycler(RecyclerView内部类)：保存缓存的类 RecyclerView.State：测量状态 RecyclerListener：当ViewHolder回收时的监听器 LayoutManager：布局管理器基类 LinearLayoutManager：水平布局管理器 GridLayoutManager：方格布局管理器 StaggeredGridLayoutManager：不规则高度的方格管理器 Adapter：视图和数据绑定的适配器，视图复用 ConcatAdapter ViewHolder：视图容器 AdapterHelper： 管理和执行更新操作的帮助类，RecyclerView将每一次更新操作封装成了一个UpdateOp操作，然后通过AdapterHelper进行管理和执行。 OpReorderer：记录操作指令 ChildHelper：布局管理器和RecyclerView的child的处理器，有Callback接口可以对相应事件进行回调 RecyclerViewPool：缓存池 ItemDecoration：元素隔间，比如绘制分隔符 DividerItemDecoration FastScroller ItemTouchHelper DiffUtil：用于比较前后数据的工具类，提升多个item更新的效率 AsyncListDiffer AsyncListUtil ScrollbarHelper SnapHelper：用于辅助RecyclerView在滚动结束时将Item对齐到某个位置 LinearSnapHelper：水平速率计算的帮助类 PagerSnapHelper：类似ViewPage滑动速率帮助类 StableIdStorage ItemTouchHelper AdapterListUpdateCallback OrientationHelper：LayoutManager用于测量child的一个辅助类，可以根据Layoutmanager的布局方式和布局方向来计算得到ItemView的大小位置等信息。 ViewBoundsCheck ViewInfoStore：存放当前VH和相关的InfoRecord InfoRecord（ViewInfoStore内部类）：VH的状态：出现、消失、预布局、实际布局 概述RecyclerView 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改善应用响应能力并降低功耗。 布局管理 LinearLayoutManager：将各个项排列在一维列表中 GridLayoutManager：将各个项排列在二维网格中，就像棋盘上的方格一样。 StaggeredGridLayoutManager：将各个项排列在二维网格中，每一列都在前一列基础上稍微偏移，就像美国国旗中的星星一样。 Adapter通过Adapter来完成数据和视图的绑定，这里使用了模版方法模式，我们只需要完成具体的实现即可。 onCreateViewHolder()：每当 RecyclerView 需要创建新的 ViewHolder 时，它都会调用此方法。此方法会创建并初始化 ViewHolder 及其关联的 View，但不会填充视图的内容，因为 ViewHolder 此时尚未绑定到具体数据。 onBindViewHolder()：RecyclerView 调用此方法将 ViewHolder 与数据相关联。此方法会提取适当的数据，并使用该数据填充 ViewHolder 的布局。例如，如果 RecyclerView 显示的是一个名称列表，该方法可能会在列表中查找适当的名称，并填充 ViewHolder 的 TextView 微件。 getItemCount()：RecyclerView 调用此方法来获取数据集的大小。例如，在通讯簿应用中，这可能是地址总数。RecyclerView 使用此方法来确定什么时候没有更多的列表项可以显示。 常用APIItemDecoration设置单元格间的布局 ItemAnimatorRecycledViewPool用于多个RecyclerView之间共享View ViewCacheExtensionsetNestedScrollingEnabled禁止滑动 setHasFixedSize数据变化不会导致Item高度变化时，可设置此值。 Header/Footer数据操作API notifyItemChanged(int position) 更新列表position位置上的数据可以调用 notifyItemInserted(int position) 列表position位置添加一条数据时可以调用，伴有动画效果 notifyItemRemoved(int position) 列表position位置移除一条数据时调用，伴有动画效果 notifyItemMoved(int fromPosition, int toPosition) 列表fromPosition位置的数据移到toPosition位置时调用，伴有动画效果 notifyItemRangeChanged(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项进行数据刷新 notifyItemRangeInserted(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量添加数据时调用，伴有动画效果 notifyItemRangeRemoved(int positionStart, int itemCount) 列表从positionStart位置到itemCount数量的列表项批量删除数据时调用，伴有动画效果 notifyDataSetChanged DiffUtils比较两个数据集，找出差异，再调用notifyItemXXX方法进行更新。 缓存机制 Scrap：屏幕内部的ItemView，通过数据集的position来找到对应的Item，可以直接取过来用； Cache：刚移出屏幕的ItemView，放到Cache里，当Cache里的ItemView重新进入屏幕时，也是通过position来找到对应的Item，直接可以使用，不需要走bindViewHolder()。Cache和 Scrap 一样，都是可以直接通过position来找到对应的Item，不需要重新绑定； ViewCacheExtension：自定义缓存，如果有自定义，需要在这里面找，没有的话直接跳过； RecycledViewPool：所有被废弃的ItemView的Pool，该pool里面的Item都是dirty的，需要通过ViewType来找到数据，找到数据的话，需要重新绑定，不走createViewHodler()，走bindViewHolder()。 RecycledViewPool的用法 不同的RecyclerView共用一个RecycledViewPool RecyclerView的布局管理器需要设置recycleChildrenOnDetach setMaxRecycledViews的设置，设置不同类型的ViewHolder的缓存个数 Adapter中getItemViewType的方法设置ViewHolder的类型 优化设置 onBindViewHolder内不要设置监听器 如果在这里设置，会频繁的重复创建监听器。 高度固定时设置onBindViewHolder 共用RecycleViewPool 参考 https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=zh-cn RecycledViewPool使用 一点点有助于巧用RecyclerView的小技巧 RecyclerView的好伴侣：详解DiffUtil Speed up Your Android RecyclerView Using DiffUtil","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://shjlone.github.io/tags/RecyclerView/"}]},{"title":"ViewPager2","slug":"Android/UI/ViewPager2","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-23T07:00:44.086Z","comments":true,"path":"wiki/Android/UI/ViewPager2/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/ViewPager2/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[]},{"title":"ANR问题分析和解决","slug":"Android/性能优化/ANR问题分析和解决","date":"2021-05-31T16:00:00.000Z","updated":"2021-07-21T06:10:16.680Z","comments":true,"path":"wiki/Android/性能优化/ANR问题分析和解决/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ANR%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/","excerpt":"","text":"ANR类型按键或触摸事件在特定时间内无响应1234//ActivityTaskManagerService.java// How long we wait until we timeout on key dispatching.public static final int KEY_DISPATCHING_TIMEOUT_MS = 5 * 1000; BroadcastRecevier超时12345//ActivityManagerService.java// How long we allow a receiver to run before giving up on it.static final int BROADCAST_FG_TIMEOUT = 10*1000;static final int BROADCAST_BG_TIMEOUT = 60*1000; 前台广播超时时间是 10s，后台广播超时是 60s，这类超时没有提示框弹出。 Service超时12345678ActiveServices.java// How long we wait for a service to finish executing.static final int SERVICE_TIMEOUT = 20 * 1000 * Build.HW_TIMEOUT_MULTIPLIER;// How long we wait for a service to finish executing.static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10; 当发生ANR时，会将相应信息记录到/data/anr/traces.txt 降低ANR的一些技巧 将所有耗时操作，比如访问网络，Socket通信，查询大量SQL语句、IO操作、复杂逻辑计算等都放在子线程中去 onCreate 和 onResume 回调中尽量避免耗时的代码 View 的 onOnTouchevent 和 onclick 中避免耗时的代码 AMS系统时间调节原理 程序等待原理分析 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"启动速度优化","slug":"Android/性能优化/启动速度优化","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-30T06:39:48.218Z","comments":true,"path":"wiki/Android/性能优化/启动速度优化/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/","excerpt":"","text":"启动流程应用的启动流程如下： SystemServer 负责应用的启动流程调度、进程的创建和管理、 窗口的创建和管理(StartingWindow 和 AppWindow) 等 应用进程被 SystemServer 创建后，进行一系列的进程初始化、 组件初始化(Activity、Service、ContentProvider、Broadcast)、 主界面的构建、内容填充等 概念冷启动当启动应用时，后台没有该应用的进程，这时系统会重 新创建一个新的进程分配给该应用，然后再根据启动的参数，启 动对应的进程组件，这个启动方式就是冷启动 热启动当启动应用时，后台已有该应用的进程(例:按 back 键、home 键，应用虽然会退出，但是该应用的进程是依然会保 留在后台，可进入任务列表查看)，所以在已有进程的情况下， 这种启动会从已有的进程中来启动对应的进程组件，这个方式叫 热启动 温启动温启动包含了在冷启动期间发生的部分操作；同时，它的开销要比热启动高。 优化方案线程优化线程优化主要是减少 CPU 调度带来的波动，让启动时间更稳定。如果 启动过程中有太多的线程一起启动，会给 CPU 带来非常大的压力，尤 其是比较低端的机器。过多的线程同时跑会让主线程的 Sleep 和 Runnable 状态变多， 增加了应用的启动速度，优化的过程中要注意： 控制线程数量（使用线程池） 检查线程间的锁 ，防止依赖等待 使用合理的启动架构 系统调度优化 启动过程中减少系统调用：避免与 AMS、WMS 竞争锁。启动 过程中本身 AMS 和 WMS 的工作就很多，且 AMS 和 WMS 很多操作都是带锁的，如果此时 App 再有过多的Binder 调用 与 AMS、WMS 通信，SystemServer 就会出现大量的锁等待 启动过程中不要启动子进程，如果好几个进程同时启动，系统负 担则会加倍，SystemServer 也会更繁忙 启动过程中除了 Activity 之外的组件启动要谨慎， 因为四大组 件的启动都是在主线程的，如果组件启动慢，占用了 Message 通 道，也会影响应用的启动速度 Application 和主 Activity 的 onCreate 中异步初始化某些代码 GC的优化尽量减少GC的次数，比如： 避免进行大量的字符串操作，特别是序列化和反序列化 频繁创建的对象需要考虑复用 转移到 Native 实现 IO的优化启动过程中负载比较高，有许多系统 IO 都在此时发生，这时候 IO 的 性能下降会比较快，此时 App 中的 IO 操作会比平时更慢一些，尤其 是在性能比较差的机器上。IO 分网络 IO 和磁盘 IO ，启动过程中不建议进行网络 IO。 布局页面优化 通过减少冗余或者嵌套布局来降低视图层次结构 用 ViewStub 替代在启动过程中不需要显示的 UI 控件 使用自定义 View 替代复杂的 View 叠加 windowBackground开启预览窗口，设置主题背景，则可以让用户看起来舒服些。 参考 https://developer.android.com/topic/performance/vitals/launch-time https://juejin.cn/post/6844904080926572558","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"adb工具","slug":"Android/未分类/adb工具","date":"2021-05-31T16:00:00.000Z","updated":"2021-07-21T02:38:01.529Z","comments":true,"path":"wiki/Android/未分类/adb工具/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/adb%E5%B7%A5%E5%85%B7/","excerpt":"","text":"查询设备 adb devices List of devices attached emulator-5554 device emulator-5556 device emulator-5558 device 将命令发送至特定设备 adb -s serial_number command adb -s emulator-5556 install helloWorld.apk 拉取/推送文件 adb pull remote local adb push local remote adb push foo.txt /sdcard/foo.txt 开启/停止adb服务器 adb start-server adb kill-server 将日志输出到屏幕 adb logcat [option] [filter-specs] 获取实例序列号 adb get-serialno 查看应用版本号 adb shell dumpsys package 包名 | findstr version 调用Activity Manager adb shell am start -a android.intent.action.VIEW 命令 说明 start [options] intent 启动 intent 指定的 Activity。 startservice [options] intent 启动 intent 指定的 Service force-stop package 强行停止与 package（应用的包名称）关联的所有应用。 kill [options] package 终止与 package（应用的包名称）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。 kill-all 终止所有后台进程。 instrument [options] component 使用 Instrumentation 实例启动监控。通常，目标 component 是表单 test_package/runner_class。 profile start process file 启动 process 的分析器，将结果写入 file。 set-debug-app [options] package 将应用 package 设为调试。 clear-debug-app 使用 set-debug-app 清除以前针对调试用途设置的软件包。 monitor [options] 启动对崩溃或 ANR 的监控。 screen-compat {on| off} package 控制 package 的屏幕兼容性模式 display-size [reset|widthxheight] 替换模拟器/设备显示尺寸。此命令对于在不同尺寸的屏幕上测试您的应用非常有用，它支持使用大屏设备模仿小屏幕分辨率（反之亦然）。示例：am display-size 1280x800 display-density dpi 替换模拟器/设备显示密度。此命令对于在不同密度的屏幕上测试您的应用非常有用，它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）。示例：am display-density 480 软件包管理器 adb shell pm uninstall com.example.MyApp 命令 说明 list packages [options] filter 输出所有软件包，或者，仅输出包名称包含 filter 中的文本的软件包。 list permission-groups 输出所有已知的权限组。 list features 输出系统的所有功能。 list libraries 输出当前设备支持的所有库。 install [options] path 将软件包（通过 path 指定）安装到系统。 clear package 删除与软件包关联的所有数据。 set-install-location location 更改默认安装位置。 屏幕截图 adb shell screencap /sdcard/screen.png 录制视频 adb shell screenrecord /sdcard/demo.mp4 其他Shell命令 adb shell ls /sdcard Shell命令 | 说明dumpsys | 将系统数据转储到屏幕dumpstate | 将状态转储到文件dmesg | 将内核调试消息输出到屏幕。start |启动（重启）模拟器/设备实例。stop |停止执行模拟器/设备实例。 adb shell dumpsys activity log anr 2 可以打开anr的messagequeue adb shell dumpsys activity a 查看activity详细信息，如显示大小，布局等等 adb shell dumpsys activity | grep mFocusedActivity adb shell &quot;dumpsys activity top | grep ACTIVITY&quot; 显示当前的Activity adb shell dumpsys activity processes 进程信息 trimmemory adb shell &quot;ps | grep 包名&quot; 查看应用的进程id adb shell dumpsys activity recents adb shell dumpsys activity broadcasts 可以查看前台和后台broadcast详细信息(发送时间， 所有应用处理时间，监听广播的所有列表) adb shell dumpsys activity intents adb shell dumpsys activity oom adb shell dumpsys input | grep Focus 查看焦点窗口 //查看当前activity名字 adb shell dumpsys activity activities | grep mFocusedActivity # 8.0以下 adb shell dumpsys activity activities | grep mResumedActivity # 8.0 adb shell ps | findstr com.xxxx.xxx 查看进程信息 adb shell kill -10 pid 触发垃圾回收 adb kill-server &amp;&amp; adb server &amp;&amp; adb shell 重制adb连接 adb shell dumpsys activity activities 查看当前任务栈 gfxinfo123456789101112131415161718192021222324252627adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt;Applications Graphics Acceleration Info:Uptime: 83871844 Realtime: 83871844** Graphics info for pid 23289 [com.xxx.xxx] **Stats since: 74696703302664nsTotal frames rendered: 0 本次dump搜集了0帧的信息Janky frames: 0 (0.00%) 卡顿率50th percentile: 4950ms90th percentile: 4950ms95th percentile: 4950ms99th percentile: 4950msNumber Missed Vsync: 0 垂直同步失败的帧Number High input latency: 0 处理input时间超时的帧数Number Slow UI thread: 0 因UI线程上的工作导致超时的帧数Number Slow bitmap uploads: 0 因bitmap的加载耗时的帧数Number Slow issue draw commands: 0 因绘制导致耗时的帧数Number Frame deadline missed: 0//Android 6.0版本为gfxinfo提供了一个新的命令——framestats，其作用是可以从最近的帧中获取非常详细的帧耗时信息adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; framestats 模拟用户行为1234567891011发送键盘事件adb shell input keyevent “value”发送鼠标事件(Touch)：adb shell sendevent [device] [type] [code] [value]input text input keyevent input tap input swipe 参考 官方文档 http://blog.hsujee.com/2017/09/25/Android/Framework/2017-09-25-Android%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://shjlone.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"APK打包流程","slug":"Android/进阶知识/APK文件打包流程","date":"2021-05-31T01:33:33.494Z","updated":"2021-07-02T07:49:21.634Z","comments":true,"path":"wiki/Android/进阶知识/APK文件打包流程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/APK%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/","excerpt":"","text":"APK文件的结构 xxx.apk res：未编译的资源文件 anim color drawable layout menu lib assets META-INF CERT.RSA：保存了签名和公钥证书 CERT.SF：对每个文件的头3行进行SHA1 hash MANIFEST.MF：版本号以及每一个文件的哈希值（Base64），包括资源文件。 com classes.dex resources.arsc AndroidManifest.xml 一、资源打包使用aapt来打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样） res目录有9种目录 animator。这类资源以XML文件保存在res/animator目录下，用来描述属性动画。 anim。这类资源以XML文件保存在res/anim目录下，用来描述补间动画。 color。这类资源以XML文件保存在res/color目录下，用描述对象颜色状态选择子。 drawable。这类资源以XML或者Bitmap文件保存在res/drawable目录下，用来描述可绘制对象。例如，我们可以在里面放置一些图片（.png, .9.png, .jpg, .gif），来作为程序界面视图的背景图。注意，保存在这个目录中的Bitmap文件在打包的过程中，可能会被优化的。例如，一个不需要多于256色的真彩色PNG文件可能会被转换成一个只有8位调色板的PNG面板，这样就可以无损地压缩图片，以减少图片所占用的内存资源。 layout。这类资源以XML文件保存在res/layout目录下，用来描述应用程序界面布局。 menu。这类资源以XML文件保存在res/menu目录下，用来描述应用程序菜单。 raw。这类资源以任意格式的文件保存在res/raw目录下，它们和assets类资源一样，都是原装不动地打包在apk文件中的，不过它们会被赋予资源ID，这样我们就可以在程序中通过ID来访问它们。例如，假设在res/raw目录下有一个名称为filename的文件，并且它在编译的过程，被赋予的资源ID为R.raw.filename，那么就可以使用以下代码来访问它： 12Resources res = getResources(); InputStream is = res.openRawResource(R.raw.filename); values。这类资源以XML文件保存在res/values目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值分别保存在名称为arrays.xml、colors.xml、dimens.xml、strings.xml和styles.xml文件中。 xml。这类资源以XML文件保存在res/xml目录下，一般就是用来描述应用程序的配置信息。toc R.java public final class R { public static final class layout &#123; public static int xxx = 0xxxxxx; &#125; ... } resources.arsc记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。 使用资源 程序中通过R.resource_type.resource_name来引用相关资源 xml文件中的使用格式：@[package:]type/name aapt命令 /e/Android/sdk/build-tools/28.0.2/aapt.exe package -f -M src/main/AndroidManifest.xml -I &quot;/e/Android/sdk/platforms/android-28/android.jar&quot; -S src/main/res -J gen -m -f 如果编译出来的文件已经存在，强制覆盖。 -m 使生成的包的目录放在-J参数指定的目录。 -J 指定生成的R.java的输出目录 -S res文件夹路径 -A assert文件夹的路径 -M AndroidManifest.xml的路径 -I 某个版本平台的android.jar的路径 -F 具体指定apk文件的输出 二、aidl阶段处理.aidl文件，生成对应的Java接口文件 aidl命令 三、Java编译阶段编译R.java、Java接口文件、Java源文件，生成.class文件 javac javac -encoding UTF-8 -bootclasspath -d gen/out src/main/java/com/test/MainActivity.java -classpath 四、dex阶段通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex dx命令 dx --dex --output=gen/classes.dex gen/out/java/com/test/ 五、apkbuilder阶段将classes.dex、resources.arsc、res文件夹(res/raw资源被原装不动地打包进APK之外，其它的资源都会被编译或者处理)、Other Resources(assets文件夹)、AndroidManifest.xml打包成apk文件。 注意： res/raw和assets的相同点： 两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 res/raw和assets的不同点： res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 aapt aapt add package/res.apk classes.dex 六、签名阶段对apk进行签名 apksigner 12345678910111213141516171819202122在Android Studio中点击菜单 Build-&gt;Generate signed apk... 打包签名过程中,可以看到两种签名选项 V1(Jar Signature) V2(Full APK Signature),刚开始升级AS看到这个懵了,既然是APK Signature,就放心偷懒选了V2,结果安装失败？？？无奈,只能查资料...从Android 7.0开始, 谷歌增加新签名方案 V2 Scheme (APK Signature);但Android 7.0以下版本, 只能用旧签名方案 V1 scheme (JAR signing)V1签名: 来自JDK(jarsigner), 对zip压缩包的每个文件进行验证, 签名后还能对压缩包修改(移动/重新压缩文件) 对V1签名的apk/jar解压,在META-INF存放签名文件(MANIFEST.MF, CERT.SF, CERT.RSA), 其中MANIFEST.MF文件保存所有文件的SHA1指纹(除了META-INF文件), 由此可知: V1签名是对压缩包中单个文件签名验证 V2签名: 来自Google(apksigner), 对zip压缩包的整个文件验证, 签名后不能修改压缩包(包括zipalign), 对V2签名的apk解压,没有发现签名文件,重新压缩后V2签名就失效, 由此可知: V2签名是对整个APK签名验证 V2签名优点很明显: 签名更安全(不能修改压缩包) 签名验证时间更短(不需要解压验证),因而安装速度加快注意: apksigner工具默认同时使用V1和V2签名,以兼容Android 7.0以下版本 apksigner sign --ks key.jks --out package/app-release.apk package/app-unsigned-aligned.apk //检查签名 apksigner verify app.apk 七、zipalign阶段对apk中未压缩的数据进行4字节对齐，对齐后就可以使用mmap函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。 zipalign zipalign 4 package/res.apk package/app-unsigned-aligned.apk","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"对于服务端开发的理解","slug":"技术开发/服务端/对于服务端开发的理解","date":"2021-05-29T06:50:55.134Z","updated":"2021-05-29T06:50:55.134Z","comments":true,"path":"wiki/技术开发/服务端/对于服务端开发的理解/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%AF%B9%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"最近一段时间，开始了解并完成了一些后端需求。大致的过程如下： 熟悉PHP，看了《PHP核心技术与最佳实践》、《PHP内核剖析》、《深入理解PHP内核》； 熟悉MySQL，看了《MySQL必知必会》，接下来会看《高性能MySQL》； 熟悉Redis，看了《Redis实战》； 阅读Symfony官网文档，了解其基本原理； 由于本地使用docker开发环境，所以对docker相关知识点也进行了一轮复习； 整体来看，想使用PHP相关技术栈进行后端开发，经过上面的学习后，写写业务代码，一点问题都没有。公司使用PHP这一套技术栈，也是基于人力成本、开发效率各方面因素综合考虑而定的。在现有体量下也确实是比较好的选择。因为自己本身有其他语言的底子在，学习的过程中还是蛮顺利的。现在回过头看看，后端的整体架构设计也是根据体量的大小一步步进化来的。 当一个（小）项目刚开始时，使用Nginx+Symfony+MySQL，当业务量有所增长，这个时候需要加上缓存Redis；当业务继续增长，这个时候需要多台机器部署了，需要使用负载均衡，Nginx进行反向代理，将流量分发到不同的机器；当业务继续增长，这个时候需要考虑部署多个数据库，进行主从同步；当业务继续增长，这个时候Redis也要考虑使用集群。随着业务继续增长，数据库表的设计，如何分表。如何分库，业务代码如何写效率高，等等问题都要进行考虑了。当业务还在继续增长，可能有些事情用PHP来干已经不是最优解了！ 除了上面所说的一些技术选择外，为了保证服务器的稳定，还有很多事情要做的，比如要对服务器相关数据进行监控，比如请求数、慢请求数、服务器流量消耗情况等；要有一套完善的日志系统；对数据库的监控；容灾机制等等。 这些知识的获取途径无外乎两种，一是业务增长喜人，给了你机会把这些坑都踩一遍；二是在大公司，现成的解决方案供你学习。所以，刚毕业的小菜鸟们，还是建议能去大公司就尽量去大公司，做大做强的小公司太少了，不一定能被你撞上。 服务端需要用到的技术或软件： 开发框架：Symfony、ThinkPHP等 消息队列：RabbitMQ等 服务器：Nginx、Apache等 缓存：Redis、MemCached等 数据存储：MySQL、PostgreSQL等 代码部署：Walle等 数据监控：Zabbix等 日志分析系统：elk等","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://shjlone.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"《大明王朝1566》经典语录","slug":"随笔/《大明王朝1566》经典语录","date":"2021-05-29T06:50:55.133Z","updated":"2021-05-29T06:50:55.134Z","comments":true,"path":"wiki/随笔/《大明王朝1566》经典语录/","link":"","permalink":"http://shjlone.github.io/wiki/%E9%9A%8F%E7%AC%94/%E3%80%8A%E5%A4%A7%E6%98%8E%E7%8E%8B%E6%9C%9D1566%E3%80%8B%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/","excerpt":"","text":"朝野都知道，我是严阁老提携的人。千秋万代以后，史书上我胡宗宪还会是严阁老的人。可你谭纶，还有朝里那些清流为什么还会看重我？就是我胡某在大事上从来上不误国，下不误民。 孔子说的“知不可为而为之”是什么本意！孔子是告诉世人，做事时不问可不可能，但问应不应该！ 你中有我，我中有你，天下事坏就坏在这里。 事未经历不知难。 官场之中无朋友。 凡事都当作两面想。 你是个刚正的人，敢说话，敢抗上。可真要抗上，你这个七品能抗得过谁？在浙江你能做些事情撼动朝廷，那是因为你背后有人要撼动朝廷。到了江西分宜，凭你一个人又能震动谁？皇上要用的人谁也推不倒，皇上不用的人谁也保不了。 两句话你要记住，一句是文官们说的‘做官要三思’，什么叫三思，三思就是思危、思退、思变。知道了危险就能躲开危险，这就叫思危；躲到人家都不注意到你的地方，这就叫思退；退了下来就有了机会，再慢慢看、慢慢想，自己以前哪儿错了，往后该怎么做，这就叫思变。我再教你武官们说的那一句‘置之死地而后生’，看我大明朝的气数，这皇位迟早有一天是裕王的，到了那一天你才真是个死呢。 文官的衣服上绣的是禽，武官的衣服上绣的是兽。披上了这身皮，我们哪一个不是衣冠禽兽。 任何人答应你的事都不算数，只有自己能做主的才算数。 这个世上，真靠得住的就两种人，一种是笨人，一种是直人。笨人没有心眼，直人不使心眼。 世间万事万物都只有一个理，各人站的位置不同，看法不同而已。 历来造反的都是种田的人，没听说商人能闹翻了天。 裕王: 大明朝谁是贤臣? 嘉靖: 没有谁是真正的贤臣,贤时用之,不贤黜之。","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://shjlone.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"火车票黄牛","slug":"随笔/火车票黄牛","date":"2021-05-29T06:50:55.133Z","updated":"2021-06-08T08:12:52.520Z","comments":true,"path":"wiki/随笔/火车票黄牛/","link":"","permalink":"http://shjlone.github.io/wiki/%E9%9A%8F%E7%AC%94/%E7%81%AB%E8%BD%A6%E7%A5%A8%E9%BB%84%E7%89%9B/","excerpt":"","text":"今天“长见识”了。 开始以为回广州的高铁票应该很容易买到，所以，并没有提前买票。然而，在家用某行火车票刷票到7点也没买到票。明天可还要上班呢。想着要不去人工售票处碰碰运气。然后来到了高铁站。先去了人工售票窗口，售票的这个小姐姐用非常冷淡的表情回答说没有，然后我就再次问了一次，请问今晚往广州方向的车的票有没有，只要能上车的都行？结果是她再次肯定的说了一句没有！哎，既然这样说了… 然后，我想去售票机上碰碰运气。当我到了一台售票机前，打算查询的时候，旁边来了一位小哥，跟我说：兄Dai，需要票吗？一个小时以内的都可以搞定。我当时就有点懵逼了，黄牛难道可以变出票来？想着还是要回去的，于是说：我需要的。他说：你跟我来这边吧，这边的机器快一些。然后我们来到了旁边的一台机器旁，只见他迅速的在售票机前点击。操作也就是查询是否有余票，然后一下子就出现了，请刷身份证的提示。然后跟我说：快把身份证放上来。我一下子看傻了，然后迅速冷静下来，问他需要给他多少钱。结果，等了十几秒吧，票就没了。他表现的有点懊恼。想想还是要回去的，于是跟他谈价钱，然后又看他操作了一遍，太神奇了。不到一分钟，他又刷出来一张，然后我拿出身份证支付了。 事后想想，难道这是售票机的漏洞吗？难道售票机上的查询接口跟人工售票厅里的不一样？黄牛的这个钱也太好赚了吧。","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://shjlone.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"《Kotlin实战》读书笔记","slug":"读书笔记/Kotlin实战","date":"2021-05-29T06:50:55.130Z","updated":"2021-05-29T06:50:55.130Z","comments":true,"path":"wiki/读书笔记/Kotlin实战/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Kotlin%E5%AE%9E%E6%88%98/","excerpt":"","text":"基本规则 不需要分号 函数 fun声明函数 函数可以定义在文件的最外层 123fun max(a: Int, b: Int): Int &#123; return if(a&gt;b) a else b&#125; 表达式函数体 fun max(a: Int, b: Int): Int = if(a&gt;b) a else b 表达式函数体可以省略返回类型，Kotlin会进行类型推导 fun max(a: Int, b: Int)= if(a&gt;b) a else b 数组就是类 变量 var表示可写属性 val表示只读属性 1234567val answer = 42 //这个变量永不为nullvar answer1:Int? = 40 // 这个变量可以为nullval answer:Int = 42val表示不可变引用，使用val声明的变量不能在初始化之后再次赋值。var可变引用，可以改变值，但不能改变类型。var answer = 13answer = &quot;no &quot; 这样是错误的 字符串模板 $name $&#123;name&#125; 类 class Person(val name:String) class Person(val name:String, var isMarried:Boolean) 自定义访问器 class Rectangle(val height:Int, val width:Int) &#123; val isSquare:Boolean get() &#123; return height == width &#125; //或者 get() = height == width &#125; 包层级结构不需要遵守目录层级结构 枚举 enum class Color(val r:Int, val g:Int, val b:Int) &#123; RED(255,0,0),GREEN(0,255,0); fun rgb() = (r*256 + g)*256 + b &#125; println(Color.GREEN.rgb()) fun getMnumonic(color: Color) = when(color) &#123; Color.RED -&gt; &quot;Richard&quot; Color.GREEN -&gt; &quot;Gave&quot; &#125; @JvmOverloads， 会生成Java重载函数 顶层属性和函数 扩展函数不能被重写 扩展属性vararg 修饰符 可变参数 中缀调用局部函数 kotlin类声明默认是final和public，要想声明不是final的，将其标记为open open、final、abstract lateinit object 定义一个类并同事创建一个实例，使用场景： 对象声明是定义单例的一种方式 伴生对象可以持有工厂方法和其他与整个类相关，但在调用时并不依赖类实例的方法。 对象表达式用来替代Java的匿名内部类 1234567object DataProviderManager &#123; fun registarDataProvider(provider: DataProvider) &#123; ... &#125;&#125;DataProviderManager.registarDataProvider(...) 伴生对象companion 1234567891011121314class MyClaa &#123; companion object Factory&#123; fun create():MyClass = MyClass() &#125;&#125;//该伴生对象的成员可通过只使用类名作为限定符来调用val instance = MyClass.create()//可以省略伴生对象的名称，在这种情况下将使用名称 Companionclass MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段 直接通过容器类名来访问整个对象的方法和属性的能力 匿名对象可以实现多个接口或者不实现接口 lamdba表达式始终用花括号包围 val sum = &#123;x: Int, y: Int -&gt; x+y&#125; println(sum(1,2)) 允许lamdba内部访问非final变量甚至修改它们 成员引用 val getAge = Person::age all any count find 对集合应用判断式 with函数apply 类型系统 可空性 fun strLen(s:String) = s.length fun strLen(s:String?) = s.length 安全调用运算符 ?.，只要链式中一个值为null，则整个表达式都返回null s?.toUpperCase() val testStr : String? = null val result = testStr?.length?.plus(5)?.minus(10) println(result) ?: 当一个函数有返回值时，如果方法中的代码使用?.去返回一个值，那么方法的返回值的类型后面也要加上?符号 fun funNullMethod() : Int? &#123; val str : String? = &quot;123456&quot; return str?.length &#125; as? 非空断言 “!!” 显示地抛出异常 let函数作用：使用符号?.验证的时候忽略掉null 用法：变量?.let{…} val arrTest : Array&lt;Int?&gt; = arrayOf(1,2,null,3,null,5,6,null) // 传统写法 for (index in arrTest) &#123; if (index == null)&#123; continue &#125; println(&quot;index =&gt; $index&quot;) &#125; // let写法 for (index in arrTest) &#123; index?.let &#123; println(&quot;index =&gt; $it&quot;) &#125; &#125; Evils操作符?: 判断一个可空类型时，会返回一个我们自己设定好的默认值 val testStr : String? = null var length = 0 // ?: 写法 length = testStr?.length ?: -1 println(length) !! 判断一个可空类型时，会显示的抛出空引用异常 val testStr : String? = null println(testStr!!.length) as? 安全的类型转换 val num2 : Int? = &quot;Koltin&quot; as? Int println(&quot;nun2 = $num2) 基本类型、包装类型的转换需要通过API Any kotlin基类Unit kotlin中的voidNothing 这个函数永不返回 List listOf mutableListOf、arrayListOfSet setOf mutableSetOf、hashSetOf、linkedSetOf、sortedSetOfMap mapOf mutableMapOf、hashMapOf、linkedMapOf、sortedMapOf 重载二元算术运算operator 委托属性 by lazy() kotlin允许使用对应名称的函数来重载一些标准的数学运算，但不能定义自己的运算符。 函数类型 内联函数 注解@JvmName@JvmStatic@JvmOverloads@JvmField 注解类：用来定义关联到声明和表达式的元数据的结构，它们不能包含任何代码 元注解@Retention 说明你声明的注解是否会存储到.class文件，以及在运行时是否可以通过反射来访问它。 kotlin反射API invoke","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"收集的电子书","slug":"读书笔记/收集的电子书","date":"2021-05-29T06:50:55.130Z","updated":"2021-05-29T06:50:55.130Z","comments":true,"path":"wiki/读书笔记/收集的电子书/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%94%B6%E9%9B%86%E7%9A%84%E7%94%B5%E5%AD%90%E4%B9%A6/","excerpt":"","text":"如何阅读一本书 ActionScript、Flex Actionscript 3 image effects ActionScript 3 ActionScript Graphing Cookbook ActionScript ActionScript大型网页游戏开发 AdvancED ActionScript Animation动画高级编程 AdvancED Game Design with Flash air_buildingapps Flash Cinematic Techniques Flash Game Development by Example Flex4权威指南 FLEX企业应用开发实战 Foundation Game Design with Flash FriendsofED The Essential Guide to Flash Games(flash游戏编程指南) 优化Flash性能 AIR_Android应用开发实战 Developing Android Applications with Flex 4 Flash+Flex+Air移动开发入门经典 mobile-encoding-android-v2_7 Packt Publishing Flash Development for Android Cookbook (2011) 使用Flex4 ABCStructure amf0_spec_121207 amf3_spec_121207 avm2overview swf_file_format_spec_v10 video_file_format_spec_v10_1 Android Android 4高级编程(第3版) Android Developer Tools Essentials Android Native Development Kit Cookbook Android内核剖析(完整版) Android多媒体开发高级编程 Android应用开发详解 Android开发精要 ANDROID框架揭秘 Android系统源代码情景分析 Android软件安全与逆向分析 Dalvik-Bytecode embedded_android Fragments for All Presentation Google Android SDK开发范例大全(第3版) Groovy in Action Groovy中文教程 Kotlin in Action kotlin-for-android-developers-zh Kotlin官方参考文档中文版 Practical practical_android_4_games_development Smashing_Android_UI The Busy Coder’s Guide to Android Development, Version 4 [Gradle [www 深入理解Android(卷2) 深入理解android 疯狂Android讲义 精通Android3 C# C#入门经典第5版中文高清版 C#高级编程(中文第七版) C、C++ Accelerated C++中文版 Andrew Koenig：C 陷阱与缺陷@2002 (扫描版) An_Introduction_to_GCC_中文 c++ Primer 第5版 C+++GUI+QT3编程_11774607 C++STL标准程序库开发指南 PDF电子书下载 带书签目录 C++标准程序库 C++模板元编程 C++沉思录(Ruminations on C++)中文第2版 C++程序设计原理与实践(中文完整版) C++编程规范-101条规则准则与最佳实践 C++语言的设计和演化 C专家编程 C和指针(第二版)高清全版469页 C程序设计(第四版)谭浩强 C程序设计语言(第2版_新版) C程序设计语言(第2版_新版)习题解答 C程序设计语言(第2版_新版)非扫描版&amp;详细书签版 C语言入门经典(第四版) C语言范例开发大全 Effective C 中文版第三版 高清PDF Effective STL 中文版 Essential C++中文版 Head STL源码剖析简体中文完整版(清晰扫描带目录) 你必须知道的495个C语言问题 像计算机科学家一样思考C++ 嗨翻C语言_13421426(jb51 易学C++ English 无敌初中必考语法 新编英语语法教程+学生用书+第5版_PDF 无敌英语语法：全范围 History 乔治·奥威尔：一九八四 何清涟：现代化的陷阱 吴思：潜规则——中国历史中的真实游戏 吴思：血酬定律——中国历史中的生存游戏 威廉·夏伊勒：第三帝国的兴亡 (上) 威廉·夏伊勒：第三帝国的兴亡 (下) 威廉·夏伊勒：第三帝国的兴亡 (中) 学会提问-批判性思维指南 弗洛伊德：梦的解析 弗洛伊德：精神分析引论 徐中约《中国近代史》（PDF-港版完整无删减）上 徐中约《中国近代史》（PDF-港版完整无删减）下 斯科特·派克：少有人走的路 罗伯特·西奥迪尼：影响力 金观涛 &amp; 刘青峰：兴盛与危机——论中国社会超稳定结构 阿利安：亚历山大远征记 高华：在历史的风陵渡口 黄仁宇：中国大历史 剑桥中国历史 中华人民共和国史 (上卷 扫描版) 明史 (扫描版) 晚清史 (上卷 扫描版) 晚清史 (下卷 扫描版) 民国史 (上卷 扫描版) 民国史 (下卷 扫描版) 秦汉史 (扫描版) 辽西夏金元史 (扫描版) 隋唐史 (扫描版) iOS AppDistributionGuide Effective Objective-C 2 iOS应用逆向工程 分析与实战 iOS编程+第4版 Objective C 编程之道 Objective C程序设计 Objective-C编程全解 第3版 Objective-C高级编程 iOS与OS X多线程和内存管理 OSX与iOS内核编程 Java advancedservletsjsp Effective Enterprise Java(Chinese) Head First Servlets and JSP 中文版 第2版 Head First Servlets and JSP 2nd Head First Web设计 (中文版) JAVA并发编程实践（中文） Java并发编程实践（英文版） Java本地接口(JNI)编程指南和规范2 JAVA案例开发集锦 Java编程思想_第4版_中文完整版 Java虚拟机规范中文版 Java迷题 JAVA面试题解惑系列 servlet-2_5-mrel2-spec Think In Java 4完美高清中文版 《Java网络编程(第4版)》 深入浅出数据分析（美）米尔顿著 Effective Java（第2版） Javascript HTML5高级程序设计 javascript dom 编程艺术 JavaScript权威指南(第6版)(中文版) JavaScript高级程序设计(中文)-第3版 kinect 51CTO下载-kinect应用开发实战（全书） Kinect人机交互开发实践 Linux bash Cookbook Solutions and Examples for bash Users Linux Shell Scripting Cookbook 2nd Edition May 2013 Linux 与 UNIX Shell 编程指南 Linux linux内核源代码情景分析(上) linux内核源代码情景分析(下) Linux命令行与Shell脚本编程大全 第2版 Understanding The Linux Kernel UNIX操作系统基础使用手册 精通UNIXShell脚本编程 高级Bash脚本编程指南(Advanced Bash-Scripting 鸟哥的Linux私房菜服务器架设篇(第三版) Music 五线谱入门 基本乐理 PHP PHP和MySQL PHP开发实战1200例 symfony权威指南 深入PHP面向对象模式与实践 白帽子讲 Web 安全 高性能mysql第三版 PHP核心技术与最佳实践 PHP内核剖析 深入理解PHP内核 Python Beginning Game Development with Python and Pygame Dive into Python Effective Expert Python Programming(2nd) make game with python &amp; pyGame Python 3 Python Cookbook Python参考手册(第4版) Python基础教程(第2版) python标准库中文版PDF(带章节书签) Python核心编程第二版-习题答案 Python源码剖析 Python灰帽子 黑客与逆向工程师的Python编程之道 Python灰帽子：黑客与逆向工程师的Python编程之道(英文版) The Django Book 2 The Python Standard Library by Example 深入学习Python 3 编写高质量代码 改善Python程序的91个建议 Qt C++ Qt设计模式（第2版） QmlBook-In-Chinese Qt Creator快速入门 Qt Quick核心编程 13678855 Qt5开发及实例 Qt及Qt Quick开发实战精解 QT学习之路(全) QT高级编程_chs the_art_of_building_qt_applications 《C++设计模式–基于Qt4开源跨平台开发框架》 PyQt pyqt-book PyQt5 tutorial pyqt5__pythonGui入门教程 PyQt5入门 Rapid GUI Programming with Python and Qt Temp 51CTO下载-ffmpeg教程 CMake Practice design-patterns FFMPEG教程完美排版 GarageBand使用指南 growth全栈增长工程师指南 InstallationGuide kotlin-in-action-in-chinese OpenSL_ES_Specification_1 SDL+GUIDE+中文译本 SWIGDocumentation TCP-IP详解(卷一、二、三) Wireshark 数据包分析实战(第2版)最新中文版 Wireshark 数据包分析实战详解 《图解TCP IP(第5版)》 图解设计模式 程序是怎样跑起来的_PDF电子书下载 带书签目录 高清完整版 网络是怎样连接的 计算机是怎样跑起来的 设计模式 设计模式之禅(完整高清版) Java加密与解密的艺术 一个证券分析师的醒悟 张化桥的股市真话 游戏之旅-我的编程感悟 游戏设计-原理与实践 荣辱二十年-我的股市人生 计算机程序的构造和解释 产品、设计、思想 A Pattern Language Head First 设计模式 Java与模式 Java夜未眠 java设计模式 人件（原书第3版） 人月神话 代码之美 你的灯亮着吗 启示录：打造用户喜爱的产品（英文） 大话设计模式 学会提问-批判性思维指南 建筑的永恒之道 数据结构经典问题和算法分析 浪潮之巅 漫谈设计模式 编码的奥秘 设计心理学 设计模式-可复用面向对象软件的基础 设计模式精解 设计模式：Java语言中的应用 高效程序的奥秘 黑客与画家 硅谷创业之父Paul Graham文集 产品经理 互联网产品经理改变世界 产品经理手册 第3版 产品经理方法论 区块链将如何改变世界 用户体验要素 用户体验面面观-方法、工具与实践 德州扑克 let there be range(中文) 加注的优势：当今锦标赛激进策略 哈灵顿在现金上2中文版 扑克蓝图 摄影 数码单反摄影从入门到精通第一卷 美国纽约摄影学院摄影教材 服务端 docker_practice Docker从入门到实践 PHP-Debug-Manual-public Redis开发运维实践指南 Redis源代码分析 云计算架构技术与实践 亿级流量网站架构核心技术 伊甸园之河 大型网站技术架构核心原理与案例分析 实用负载均衡技术网站性能优化攻略 极客与团队 深入分布式缓存从原理到实践 精通正则表达式 软件架构设计 高扩展性网站的50条原则 算法、数据结构 《大话数据结构》 程杰 程序员实用算法 算法之道 算法导论(第二版)习题答案(英文版) 算法导论 管理 MBA教不了的创富课 股票 与庄共舞（股票实战操作） 从零开始学炒股 价值投资系列之25《上市公司财报解读》 你不知道的中国股事那些事(高清) 投资正途 日本蜡烛图技术 江恩投资几何学原理 江恩测市法则（经典之作） 海龟交易法则 看盘细节(精选) 看盘细节 短线炒股就这几招（操盘必读） 短线点金：揭开市场的底牌 短线点金：破解股价的运行轨迹 短线点金：道破股价涨跌之玄机 缠中说禅《教你炒股票》1-108课图文全版 缠论解析 缠中说禅技术理论图解(清晰版) 聪明的投资者（高质量） 胡立阳股票投资100招（清晰） 证券市场基础知识 【投资艺术】作者：查尔斯 艾里斯 巴菲特教你读财报 股票作手回忆录 超越金融 索罗斯的哲学 (美)乔治·索罗斯 2 金融炼金术(高质量） 高胜算操盘 股市操练大全12345 计算机基础 深入理解计算机系统(原书第2版) 编译、链接、装载 程序员的自我修养—链接、装载与库 linker and loader 现代编译原理：Ｃ语言描述 编译原理及实践 编译原理基础 编译原理（龙书）中文版 编译原理及实践 音视频相关 FFmpeg Tutorial FFmpegBasics ffmpeg基础库编程开发 OpenCV 2 计算机视觉编程手册_中文版 学习OpenCV 项目管理 Project 2016项目管理自学经典_王菁_清华大学_2016","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《网络是如何连接的》读书笔记","slug":"读书笔记/网络是如何连接的","date":"2021-05-29T06:50:55.129Z","updated":"2021-05-29T06:50:55.129Z","comments":true,"path":"wiki/读书笔记/网络是如何连接的/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"动态规划","slug":"算法/动态规划","date":"2021-05-29T06:50:55.127Z","updated":"2021-05-29T06:50:55.127Z","comments":true,"path":"wiki/算法/动态规划/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"回溯算法","slug":"算法/回溯算法","date":"2021-05-29T06:50:55.127Z","updated":"2021-05-29T06:50:55.127Z","comments":true,"path":"wiki/算法/回溯算法/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"回溯法（Back Tracking Method）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 参考 https://my.oschina.net/u/3024426/blog/4689026","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"开始学习iOS","slug":"程序语言/iOS/开始学习iOS","date":"2021-05-29T06:50:55.126Z","updated":"2021-05-29T06:50:55.126Z","comments":true,"path":"wiki/程序语言/iOS/开始学习iOS/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0iOS/","excerpt":"","text":"由于种种原因，有机会全面接触iOS、Mac、OS X了。这里记录下自己的学习过程。 首先是了解下苹果操作系统的历史，推荐看深入解析Mac OS X &amp; iOS操作系统。要想开发iOS应用，ObjectiveC是一定要学的，Objective-C基础教程、Objective-C编程全解、Objective-C高级编程。对OC有了一定的了解后，就需要开始熟悉iOS系统和开发了，iOS编程（第4版）。 入门之后，就需要掌握更具体的知识点了。 Block绘制机制GCD","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://shjlone.github.io/tags/iOS/"}]},{"title":"理解打包流程","slug":"程序语言/iOS/理解打包流程","date":"2021-05-29T06:50:55.126Z","updated":"2021-05-29T06:50:55.126Z","comments":true,"path":"wiki/程序语言/iOS/理解打包流程/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/%E7%90%86%E8%A7%A3%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/","excerpt":"","text":"首先理解一下基本的概念 https://help.apple.com/developer-account CertificatesIdentifiersDevicesProfilesKeys编译脚本 1234567891011121314151617181920MWProjectName=&quot;Loneqd&quot;#scheme名字MWScheme=&quot;Loneqd_appstore&quot;#Release还是DebugMWConfiguration=&quot;Release&quot;#日期MWDate=`date +%Y%m%d_%H%M`#工程路径MWWorkspace=&quot;$&#123;WORKSPACE&#125;/src&quot;#build路径MWBuildDir=&quot;/Users/loneqd/alone/Loneqd-for-iOS/build&quot;#导出ipa的配置文件MBPlistName=&quot;/Users/loneqd/alone/Loneqd-for-iOS/lieyou_appstore.plist&quot;xcodebuild archive -workspace &quot;$&#123;WORKSPACE&#125;/src/$MWProjectName.xcworkspace&quot; -scheme &quot;$MWScheme&quot; -configuration &quot;$MWConfiguration&quot; -archivePath &quot;$MWBuildDir/$MWProjectName$MWDate&quot; -quietxcodebuild -exportArchive -archivePath &quot;$MWBuildDir/$MWProjectName$MWDate.xcarchive&quot; -exportPath &quot;$MWBuildDir/$MWProjectName$MWDate&quot; -exportOptionsPlist &quot;$MBPlistName&quot; -quietecho &quot;结束了======&quot;","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://shjlone.github.io/tags/iOS/"}]},{"title":"Windows下Charles支持HTTPS","slug":"技术开发/杂项/Charles SSL证书","date":"2021-05-29T06:50:55.113Z","updated":"2021-07-02T07:03:04.579Z","comments":true,"path":"wiki/技术开发/杂项/Charles SSL证书/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Charles%20SSL%E8%AF%81%E4%B9%A6/","excerpt":"","text":"SSL握手过程客户端发出加密通信请求提供： 协议版本(如 TSL1.0) 随机数 1(用于生成对话密钥) 支持的加密方法(如 RSA 公钥加密) 支持的压缩方法 服务器回应回应内容: 确认使用的加密通信协议版本(TSL1.0) 随机数 2(用于生成对话密钥) 确认加密方法(RSA) 服务器证书(包含非对称加密的公钥) (可选)要求客户端提供证书的请求 客户端验证证书如果证书不是可信机构颁布，或证书域名与实际域名不符，或者证书已经过期，就会向访问者显示一个警告，是否继续通信 客户端回应证书没有问题，就会取出证书中的服务器公钥然后发送: 随机数 3(pre-master key，此随机数用服务器公钥加密，防止被窃听) 编码改变通知(表示随后的信息都将用双方商定的方法和密钥发送) 客户端握手结束通知 双方生成会话密钥双方同时有了三个随机数，接着就用事先商定的加密方法，各自生成同一把“会 话密钥” 服务器端用自己的私钥(非对称加密的)获取第三个随机数，会计算生成本次所 用的会话密钥(对称加密的密钥)，如果前一步要求客户端证书，会在这一步验证。 服务器最后响应服务器生成会话密钥后，向客户端发送: 编码改变通知(后面的信息都用双方的加密方法和密钥来发送) 服务器握手结束通知 Charles 设置SSL设置点击 Proxy -&gt; SSL Proxy Settings -&gt; SSLProxy -&gt; Add 添加SSL代理规则 Host:* Port:443 证书配置点击 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 安装证书 选择将所有的证书都放入受信任的根证书颁发机构 Mac需要在钥匙链中将证书设置为永久信任 手机配置连接跟电脑一样的网络，配置代理连接charles。浏览器访问chls.pro/ssl，下载安装证书 注意事项Android7及以上无法抓取https，因为”Network Security Configuration”的新安全功能。这个功能运行开发人员在不修改应用程序的情况下自定义他们的网络安全设置。如果应用程序运行的系统版本高于或等于24，并且targetSdkVersion&gt;=24，则只有系统证书才被信任。 参考 https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/ https://juejin.im/post/5b4f005ae51d45191c7e534a","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"charles","slug":"charles","permalink":"http://shjlone.github.io/tags/charles/"}]},{"title":"Synchronized","slug":"Java/并发编程/Synchronized","date":"2021-05-29T06:50:55.105Z","updated":"2021-05-29T09:08:06.419Z","comments":true,"path":"wiki/Java/并发编程/Synchronized/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Synchronized/","excerpt":"","text":"前言在学习synchronized之前，应该先了解多线程的机制和锁的概念，请先阅读以下文章： Java锁 Java多线程 使用方式 同步普通方法，锁的是当前对象this。 1234567891011121314151617181920public class SynchronizedTest &#123; public synchronized void sayHello()&#123; &#125;&#125;//对应字节码 Compiled from &quot;SynchronizedTest.java&quot; public class com.myth.SynchronizedTest &#123; public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public synchronized void sayHello(); Code: 0: return &#125; 同步静态方法，锁的是当前 Class 对象。 12345678910111213141516171819public class SynchronizedTest &#123; public synchronized static void sayHello()&#123; &#125;&#125;//对应字节码public class com.myth.SynchronizedTest &#123;public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: returnpublic static synchronized void sayHello(); Code: 0: return&#125; 同步块，锁的是 () 中的对象。 12345678910111213141516171819202122232425262728293031323334353637383940public class SynchronizedTest &#123; private String words; public void sayHello()&#123; synchronized(words)&#123; &#125; &#125;&#125;//对应字节码 Compiled from &quot;SynchronizedTest.java&quot; public class com.myth.SynchronizedTest &#123; public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public void sayHello(); Code: 0: aload_0 1: getfield #2 // Field words:Ljava/lang/String; 4: dup 5: astore_1 6: monitorenter 7: aload_1 8: monitorexit 9: goto 17 12: astore_2 13: aload_1 14: monitorexit 15: aload_2 16: athrow 17: return Exception table: from to target type 7 9 12 any 12 15 12 any &#125; 通过查阅字节码（javap -c XXX.class）可知，synchronized修饰对象时，使用monitorenter、monitorexit来实现同步操作，修饰方法时网络上很多资源都说使用ACC_SYNCHRONIZED来实现同步，ACC_SYNCHRONIZED内部隐式的调用monitorenter、monitorexit，可自己查看的字节码却没有看到，不知道啥原因，🤷‍ 底层原理对象头我们编写一个Java类，编译后会生成.class文件，当类加载器将class文件加载到jvm时，会生成一个Klass类型的对象(c++)，称为类描述元数据，存储在方法区中，即jdk1.8之后的元数据区。当使用new创建对象时，就是根据类描述元数据Klass创建的对象oop，存储在堆中。每个java对象都有相同的组成部分，称为对象头。 对象头 Mark Word（标记字段）：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 MarkWord在64位JVM中的结构： MarkWord在32位JVM中的结构： Klass Point（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据 这部分主要是存放类的数据信息，父类的信息。 对其填充 由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。 查看对象占用内存通过jol-core可以分析出内存占用情况和锁的情况 12345678910111213141516171819202122232425262728//添加依赖&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt;//使用public class App &#123; public static void main(String[] args) &#123; System.out.println(ClassLayout.parseInstance(new MyObject()).toPrintable()); &#125;&#125;class MyObject &#123; public int age;&#125;//结果 OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 41 c1 00 f8 (01000001 11000001 00000000 11111000) (-134168255) 12 4 (loss due to the next object alignment)Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 锁升级JDK 1.6之前，synchronized 是一个重量级锁，是一个效率比较低下的锁，但是在JDK 1.6后，Jvm为了提高锁的获取与释放效率对（synchronized ）进行了优化，引入了”偏向锁”和”轻量级锁”，从此以后锁的状态就有了四种（无锁、偏向锁、轻量级锁、重量级锁），并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程。 关于锁的概念，参考Java锁 参考 https://juejin.cn/post/6844904069845221384","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"volatile","slug":"Java/并发编程/volatile","date":"2021-05-29T06:50:55.105Z","updated":"2021-07-07T09:22:22.773Z","comments":true,"path":"wiki/Java/并发编程/volatile/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile/","excerpt":"","text":"volatile作用在Java并发编程中，volatile 是经常用到的一个关键字，它可以用于保证不同的线程共享一个变量时每次都能获取最新的值。volatile具有锁的部分功能并且性能比锁更好，所以也被称为轻量级锁。 一个变量被volatile修饰，则： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 一些基本概念CPU缓存CPU的计算速度相比内存的读写是非常快的，为了能充分利用CPU的计算能力，这个时候缓存的概念出现了。CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。 按照读取顺序与CPU结合的紧密程度，CPU缓存可分为： 一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存 二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半 三级缓存：简称L3 Cache，部分高端CPU才有 当系统运行时，CPU执行计算的过程如下： 程序以及数据被加载到主内存 指令和数据被加载到CPU缓存 CPU执行指令，把结果写到高速缓存 高速缓存中的数据写回主内存 原子性即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 可见性指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 volatile是如何实现可见性的呢？ 在线程和主内存之间添加了一条总线，当线程中的变量发生变化时，会将值复制到主内存，这个时候这个值会通过总线，总线就会通知其他线程做修改。 指令重排处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 比如： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 使用场景修饰boolean变量123456789volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; 双重锁校验123456789101112131415class Singleton &#123; private static volatile Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 其实问题出在 instance = new Singleton(); 这一行，这里是创建 Singleton 对象的地方，其实这里可以看成三个步骤： 123memory = allocate(); //1: 分配对象的内存空间ctorInstance(memory); //2: 初始化对象instance = memory； //3: 设置 instance 指向刚分配的内存地址 上面的伪代码可能会被重排序。什么是重排序？编译器以及处理器有时候会为了执行的效率改变代码的执行顺序，这个被称为重排序。上面的三个步骤可能会被重排序为下面的步骤： 1234memory = allocate(); //1: 分配对象的内存空间instance = memory； //2: 设置 instance 指向刚分配的内存地址// 注意：此时对象还没有被初始化ctorInstance(memory); //3: 初始化对象 在这种情况下，当一个线程执行到 instance = memory; 的时候，对象还没有被初始化，另一个线程也调用了 getInstance 方法，发现 instance 引用不为 null，就会认为这个对象已经创建好了，从而使用了未初始化的对象。 为什么 volatile 可以避免上面的问题？其实是因为 volatile 会禁止重排序，方法是插入了内存屏障。 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。 lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他CPU中对应的缓存行无效。 参考 https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg https://www.cnblogs.com/dolphin0520/p/3920373.html https://github.com/AdoptOpenJDK/jitwatch volatile与lock前缀指令","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java中的HashMap","slug":"Java/集合/HashMap","date":"2021-05-29T06:50:55.105Z","updated":"2021-07-08T04:11:28.123Z","comments":true,"path":"wiki/Java/集合/HashMap/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/HashMap/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java锁","slug":"Java/并发编程/Java锁","date":"2021-05-29T06:50:55.104Z","updated":"2021-06-22T10:17:30.489Z","comments":true,"path":"wiki/Java/并发编程/Java锁/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E9%94%81/","excerpt":"","text":"锁的基本概念从广义上来定义： 悲观锁： 比如线程A对某个变量进行修改，在这个修改期间，它持悲观心理，认为其他线程在这个期间，也有可能去修改这个变量，所以它就给变量加个锁，保证在它修改期间，别的线程没法去访问这个变量。这个锁就是悲观锁。悲观锁是重量级锁，代表对象synchronized和Lock。悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁： 比如线程A对某个变量进行修改，在这个修改期间，它持乐观心理，认为其他线程在这个期间，不会去修改这个变量，所以不会加锁。 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁是轻量级锁，代表对象CAS。Java原子类中的递增操作就通过CAS自旋实现的。乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 悲观锁和乐观锁的基本用法12345678910111213141516// ------------------------- 悲观锁的调用方式 -------------------------// synchronizedpublic synchronized void testMethod() &#123; // 操作同步资源&#125;// ReentrantLockprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123; lock.lock(); // 操作同步资源 lock.unlock();&#125;// ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger = new AtomicInteger(); // 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); //执行自增1 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。这四种锁是指锁的状态，专门针对synchronized的。 Java头对象synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？ 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。 Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。 如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。 无锁： 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。 偏向锁： 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁： 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁 重量级锁是依赖对象内部的monitor锁来实现。当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，需要从用户态转换到内核态，而转换状态是需要消耗很多时间。 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 CASCAS锁：（Compare And Swap） 乐观锁的一种实现方式。 CAS算法涉及到三个操作数： 需要读写的内存值 V。 进行比较的值 A。 要写入的新值 B。 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 123456789101112131415161718192021222324// ------------------------- JDK 8 -------------------------// AtomicInteger 自增方法public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// ------------------------- OpenJDK 8 -------------------------// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; 根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。 后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。 CAS虽然很高效，但是它也存在三大问题，这里也简单说一下： ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。 JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 公平锁和非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。 如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： ReentrantLock中公平锁和非公平锁的实现如下： 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。 可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析： 12345678910public class Widget &#123; public synchronized void doSomething() &#123; System.out.println(&quot;方法1执行...&quot;); doOthers(); &#125; public synchronized void doOthers() &#123; System.out.println(&quot;方法2执行...&quot;); &#125;&#125; 在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。 还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。 独享锁 VS 共享锁独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。 那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。 在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); // 取到当前锁的个数 int w = exclusiveCount(c); // 取写锁的个数w if (c != 0) &#123; // 如果已经有线程持有了锁(c!=0) // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败 return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 throw new Error(&quot;Maximum lock count exceeded&quot;); // Reentrant acquire setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。 return false; setExclusiveOwnerThread(current); // 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者 return true;&#125; 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。 如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！ tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。 因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。 接着是读锁的代码： 123456789101112131415161718192021222324252627protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。 此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码： 我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。 参考 volatile和synchronized的区别 https://stackoverflow.com/questions/9851133/when-to-use-volatile-and-synchronized https://tech.meituan.com/2018/11/15/java-lock.html","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java容器","slug":"Java/集合/Java_Collections","date":"2021-05-29T06:50:55.104Z","updated":"2021-07-05T05:56:34.795Z","comments":true,"path":"wiki/Java/集合/Java_Collections/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/Java_Collections/","excerpt":"","text":"容器类图 Java 中常用的存储容器就是数组和容器，二者有以下区别： 存储大小是否固定 数组的长度固定； 容器的长度可变。 数据类型 数组可以存储基本数据类型，也可以存储引用数据类型； 容器只能存储引用数据类型，基本数据类型的变量要转换成对应的包装类才能放入容器类中。 Java 容器框架主要分为 Collection 和 Map 两种。其中，Collection 又分为 List、Set 以及 Queue。 Collection - 一个独立元素的序列，这些元素都服从一条或者多条规则。 List - 必须按照插入的顺序保存元素。 Set - 不能有重复的元素。 Queue - 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。 Map - 一组成对的“键值对”对象，允许你使用键来查找值。 基础接口Iterator、IterableIterator：可迭代接口，迭代对象Iterable：Collection 接口扩展了 Iterable 接口 123456789101112131415public class IteratorDemo &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); Iterator it = list.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; Comparable 和 ComparatorComparable：排序接口。若一个类实现了 Comparable 接口，表示该类的实例可以比较，也就意味着支持排序。实现了 Comparable 接口的类的对象的列表或数组可以通过 Collections.sort 或 Arrays.sort 进行自动排序。 Comparator：比较接口。在 Java 容器中，一些可以排序的容器，如 TreeMap、TreeSet，都可以通过传入 Comparator，来定义内部元素的排序规则。 CloneableJava 中 一个类要实现 clone 功能 必须实现 Cloneable 接口，否则在调用 clone() 时会报 CloneNotSupportedException 异常。Java 中所有类都默认继承 java.lang.Object 类，在 java.lang.Object 类中有一个方法 clone()，这个方法将返回 Object 对象的一个拷贝。Object 类里的 clone() 方法仅仅用于浅拷贝（拷贝基本成员属性，对于引用类型仅返回指向改地址的引用）。如果 Java 类需要深拷贝，需要覆写 clone() 方法。 fail-fast机制Java 容器的一种错误检测机制。例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历容器 A 中的元素，在某个时候线程 2 修改了容器 A 的结构（是结构上面的修改，而不是简单的修改容器元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 List特征 元素可重复 常用List ArrayList：数组实现，随机访问速度快，插入删除较慢 LinkedList：链表实现，插入、删除较快，但查找需要遍历整个链表，速度较慢 Vector：和 ArrayList 类似，但它是线程安全的 Set特征 元素不能重复 常用Set HashSet：基于哈希实现，支持快速查找，但不支持有序性操作，例如根据一个范围查找元素的操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator遍历 HashSet 得到的结果是不确定的。 TreeSet：底层使用红黑树，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logn)； LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。 Map特征 使用键值对存储 键值对都可以为null 常用Map HashMap：在JDK1.8中，基于数组+链表+红黑树。需要自动装箱，有hash碰撞问题 HashTable：哈希表实现，本身是同步的，put操作直接锁住，不支持null键和值。 ConcurrentHashMap：线程安全的HashMap，使用synchronized锁住了链表，性能强于HashTable LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 SortedMap： TreeMap：基于红黑树的一种提供顺序访问的Map SparseArray：Android平台专有，避免自动装箱，k、v都使用数组实现，k为整型。使用二分查找。删除时将v设置为DELETE。 Queue LinkedList：可以用它来支持双向队列； PriorityQueue 是基于堆结构实现，可以用它来实现优先级队列。 常见面试题ArrayList与LinkedList的实现和区别？ ArrayList由动态数组实现，LinkedList由链表实现 ArrayList随机访问快，LinkedList插入删除快","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"ConstraintLayout","slug":"Android/UI/ConstraintLayout","date":"2021-05-29T06:50:55.103Z","updated":"2021-07-01T06:02:40.762Z","comments":true,"path":"wiki/Android/UI/ConstraintLayout/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/ConstraintLayout/","excerpt":"","text":"layout_constraintLeft_toRightOf的理解constraintXXX表示约束View自己，XXX分别表示上下左右等位置，toXXXOf表示约束依赖等对象，可以是同级的View，也可以是parent。 layout_constraintBaseline_toBaselineOf对于TextView，可以使用基线对齐，这样文字就能对齐了。 边距不同方位的边距 android:layout_marginStart android:layout_marginEnd android:layout_marginLeft android:layout_marginTop android:layout_marginRight android:layout_marginBottom 目标View隐藏时，以下属性生效 layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom 水平居中 layout_constraintLeft_toLeftOf &amp; layout_constraintRight_toRightOf垂直居中 layout_constraintTop_toTopOf &amp; layout_constraintBottom_toBottomOf layout_constraintHorizontal_bias 水平偏移layout_constraintVertical_bias 垂直偏移 两个属性的取值范围在0-1。在水平偏移中，0表示最左，1表示最右；在垂直偏移，0表示最上，1表示最下；0.5表示中间。 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ContentProvider","slug":"Android/基础/ContentProvider","date":"2021-05-29T06:50:55.103Z","updated":"2021-07-09T06:46:58.897Z","comments":true,"path":"wiki/Android/基础/ContentProvider/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/ContentProvider/","excerpt":"","text":"概述ContentProvider是一种数据共享型组件，可以在应用之间共享数据。所以与BroadcastReceiver一样，其可以脱离Activity实现。在实现ContentProvider时，需要继承ContentProvider抽象类，然后在AndroidManifest.xml中注册类名和ContentProvider的域名。同样的，不需要重写onCreat()方法，而是实现CRUD操作，所以ContentProvider没有启动和停止的概念，更像是一个系统级的监听器。与前三个组件不同的是，ContentProvider并没有使用intent，而是使用URI来判定能否为ContentResolver提供数据共享。 关于ContentProvider，用来提供其他地方（包括其他App）调用的一种全局（系统级）方式。有了ContentProvider，我们就能方便的调用相册的东西、进行文件选择，在我们自己的App中，也可以提供一个数据中心。 当数据量比较大的时候，继续用Parcel做容器效率会比较低，因此它还使用了匿名共享内存的方式。 但是有一个问题是，ContentProvider的提供者进程不再存活时，其他进程通过Provider读一个非 常简单的数据时，都需要先把提供者进程启动起来(除非指定multiprocess=true)，这对用户是 相当不友好的。又因为其是间接通过db进行数据操作，所以效率也远不如直接操作db。因此在用户app中，不是很建议经常使用ContentProvider。不过对于系统级的app，它统一了数据操作的规范，利是远大于弊的。 在很多开源库中，也运用了ContentProvider的特性来进行初始化。 一些注意点 对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。 因为Android7的变化，所以在使用FileProvider时需要做一些处理，关于如何处理，网上一大把资料，总结出来需要以下步骤： 配置Manifest文件，添加provider 对于Android7以上，在FileProvider.getUriForFile时使用配置的authority 参考 官方使用手册 https://blog.csdn.net/lmj623565791/article/details/72859156 https://developer.android.com/topic/libraries/app-startup","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ThreadLocal原理","slug":"Java/并发编程/ThreadLocal原理","date":"2021-05-29T06:50:55.103Z","updated":"2021-06-08T08:37:58.566Z","comments":true,"path":"wiki/Java/并发编程/ThreadLocal原理/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E5%8E%9F%E7%90%86/","excerpt":"","text":"ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。 源码分析Thread中有一个成员变量： 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal的set方法中，如果当前Thread的threadLocals有值，则设置，没有则创建一个新的ThreadLocalMap。 123456789101112131415161718/** * Sets the current thread&#x27;s copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&#x27;s copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; ThreadLocal的get方法中，从当前线程的threadLocals拿map，如果有则返回，没有则初始化值。 12345678910111213141516171819202122/** * Returns the value in the current thread&#x27;s copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&#x27;s value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 值的修改都是在自己线程中操作的，所以是线程安全的。 使用场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享 Android中Hander 1234567static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 参考 http://www.jasongj.com/java/threadlocal/ https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Android测试实践","slug":"Android/未分类/Android测试实践","date":"2021-05-29T06:50:55.102Z","updated":"2021-06-04T02:37:27.134Z","comments":true,"path":"wiki/Android/未分类/Android测试实践/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/Android%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"为什么要做测试？很多公司为了节省成本，基本上是不会要求开发写单元测试的。自己做完的功能，动手点点看看基本流程是否通畅就丢给测试了。项目小的时候这样也不会有啥问题。随着项目的复杂度越来越高，人员越来越多，不同的人员改动到同一块代码，但彼此对原来的逻辑不是很清楚（因为代码量实在太多，想要一个人弄清楚所有细节已经不太可能）。这也是为什么大家宁肯写新的代码也不愿意改旧的代码的原因。而如果每个功能在开发的同时配置了单元测试，那么理论上新的功能 开发完之后，所有的单元测试应该都是可以跑通的。这样就能自动帮我们检查出来一些难以发现的bug。 Android如何进行单元测试 androidTest目录：应包含在实际或虚拟设备上运行的测试。此类测试包括集成测试，端到端测试以及仅JVM无法验证应用程序功能的其他测试。 test目录：应包含在本地计算机上运行的测试，例如单元测试 测试常用库 JUnit Mockito PowerMock Espresso JUnitTestCase TestResult TestSuite 测试套件 在实际项目中，随着项目进度的开展，单元测试类会越来越多，可是直到现在我们还只会一个一个的单独运行测试类，这在实际项目实践中肯定是不可行的。 为了解决这个问题，JUnit 提供了一种批量运行测试类的方法，叫做测试套件。 断言： Assert 标注： 标注|描述|—|—|@Test|该方法是一个测试用例@Before|每个测试方法执行之前执行@After|每个测试方法执行后执行@BeforeClass|一个测试文件只执行一次@AfterClass|一个测试文件最后执行一次@Ignore|这个注解是用来忽略有关不需要执行的测试的。 Mockito模拟被测对象依赖的对象 参考 https://dunwu.github.io/javatech/test/mockito.html PowerMock模拟被测对象依赖的静态方法 RobolectricAndroid SDK测试框架 Config配置参考 https://maxwell-nc.github.io/android/robolectricTest.html https://www.jianshu.com/p/6c23f2681105 Espresso","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://shjlone.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"如何提升Android应用的安全","slug":"Android/逆向/如何提升Android应用的安全","date":"2021-05-29T06:50:55.102Z","updated":"2021-07-14T10:14:30.642Z","comments":true,"path":"wiki/Android/逆向/如何提升Android应用的安全/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87Android%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8/","excerpt":"","text":"权限设置 尽量使用更少的权限，动态获取权限。 release版本中设置日志输出等级 危险代码检测确认代码中是否使用插件化技术，hook技术 源文件安全 Java代码混淆 底层代码加固 密钥等信息是否存在暴露风险 启动时进行签名检查（防止二次打包） 数据存储安全 是否明文存储配置信息 数据库存储的安全 是否暴露不必要的组件，检查exported属性 数据传输安全 是否存在网络数据被拦截的风险 是否使用Https 参考 https://blog.csdn.net/u013107656/category_6257625.html","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android客户端经验谈","slug":"Android/未分类/Android客户端经验谈","date":"2021-05-29T06:50:55.101Z","updated":"2021-07-21T03:55:19.672Z","comments":true,"path":"wiki/Android/未分类/Android客户端经验谈/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/Android%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%8F%E9%AA%8C%E8%B0%88/","excerpt":"","text":"一些技巧 异步线程应该在Activity、Fragment的生命周期结束时停止掉 减少不必要的线程切换 主线程中throw的异常要catch 不要在主线程做耗时的操作 关于隐私策略由于政策要求，隐私策略需要放到运行时就弹出并由用户确认。这里有个点需要注意，只有当用户确认后才可进行后续的数据请求。 参考 https://developer.android.com/training/articles/perf-tips?hl=zh-cn","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://shjlone.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"JNI笔记","slug":"Android/NDK/JNI笔记","date":"2021-05-29T06:50:55.100Z","updated":"2021-06-22T03:48:22.721Z","comments":true,"path":"wiki/Android/NDK/JNI笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Android/NDK/JNI%E7%AC%94%E8%AE%B0/","excerpt":"","text":"JNI开发流程 编写声明了native方法的Java类 将Java源代码编译成class字节码文件 用javah -jni 命令生成.h头文件（javah 是 jdk 自带的一个命令，-jni 参数表示将 class 中用native 声明的函数生成 JNI 规则的函数） 用本地代码实现.h头文件中的函数 将本地代码编译成动态库（Windows：*.dll，linux/unix：*.so，mac os x：*.jnilib） 拷贝动态库至 java.library.path 本地库搜索目录下，并运行 Java 程序 JVM查找native方法的规则JNI数据类型与Java数据类型的映射关系字符串处理访问数组C/C++访问Java实例方法和静态方法C/C++访问Java实例变量和静态变量JNI调用构造方法和父类实例方法参考 https://developer.android.com/training/articles/perf-jni wiki.jikexueyuan.com/project/jni-ndk-developer-guide/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://shjlone.github.io/categories/Android/NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"CoordinatorLayout","slug":"Android/UI/CoordinatorLayout","date":"2021-05-29T06:50:55.100Z","updated":"2021-06-08T08:00:38.250Z","comments":true,"path":"wiki/Android/UI/CoordinatorLayout/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/CoordinatorLayout/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"JEB使用笔记","slug":"Android/逆向/JEB使用笔记","date":"2021-05-29T06:50:55.100Z","updated":"2021-05-29T06:50:55.100Z","comments":true,"path":"wiki/Android/逆向/JEB使用笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/JEB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"https://www.pnfsoftware.com/jeb/manual/ 在使用Jeb的时候，关闭Android Studio。 如何debug 对于一个release包，是无法进行debug的，需要apktool进行反编译，自行打包并签名。 command+b：打开关闭断点","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Handler原理","slug":"Android/基础/Handler原理","date":"2021-05-29T06:50:55.099Z","updated":"2021-07-09T07:24:30.801Z","comments":true,"path":"wiki/Android/基础/Handler原理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%8E%9F%E7%90%86/","excerpt":"","text":"Hanlder系列目录： Handler基本用法 Handler原理 概要Handler是Android子线程和主线程之间通信的一种机制。 使用Handler的原因是多个线程并发更新UI的同时保证线程安全。 概念 定义 作用 主线程 当应用程序第一次启动时，会同时自动开启一条主线程 处理UI相关 子线程 人为手动创建的线程 执行耗时操作 消息（Message） 线程间通讯的数据单元 存储需要操作的信息 消息队列（MessageQueue） 一种数据结构 存储Handler发送过来的信息（Message） 处理者（Handler） 主线程与子线程的通信媒介，线程消息的主要处理者 添加消息到消息队列，处理Looper分派过来的消息 循环器（Looper） 消息队列与处理器的通信媒介 消息获取：循环取出消息队列的消息，消息分发：将取出的消息发送给对应的处理者 ThreadLocal 用于不同线程保存自己的信息 工作流程 异步通信准备 在主线程中创建 处理器对象Looper 消息队列对象MessageQueue，Looper自动进入消息循环 Handler对象，自动绑定主线程的Looper、MessageQueue 消息发送 消息循环 消息处理 注意 每个线程只有一个Looper 一个Looper可以绑定多个线程的Handler（实现线程间通信） 源码分析按照我们的使用顺序，先看看Handler的构造函数 123456789101112131415161718192021222324252627//接受Looper参数，绑定线程public Handler(@NonNull Looper looper) &#123; this(looper, null, false);&#125; public Handler(@Nullable Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125;//绑定线程，在使用的时候，如果不设置Looper，则使用当前线程的Looper。//Looper.myLooper()作用：获取当前线程的Looper对象；若线程无Looper对象则抛出异常 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 那么Looper是在什么时候构造的呢？我们可以先看看主线程的初始化是如何做的，以下是ActivityThread的入口函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper();//构造了Looper // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//looper进入循环，正常情况下下面的代码是不会执行的 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 那么Looper内部又做了什么呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125;private static void prepare(boolean quitAllowed) &#123;//判断looper是否是null如果是，就创建，并将其存到ThreadLocal中，上面说的handler中的looper就是从ThreadLocal中取出来的；//这里可知，每个线程只有一个Looper if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); //这里大家不用管，我个人理解是对进程的校验，有知道的同学也可以留言告诉我。 final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); //分发消息，这里的target就是handler &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); //消息的回收 &#125;&#125; 至此，我们知道一个线程中只有一个Looper，Looper进行循环后，会不停的从消息队列中拿到消息进行处理。 然后就是消息的发送和接收，我们先看看消息是如何发送的 123456789101112131415161718192021222324252627282930313233343536Handler.java//发送消息public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //消息被添加到消息队列中，loop中处理 return queue.enqueueMessage(msg, uptimeMillis);&#125; 从loop方法中可知，dispatchMessage会最终处理消息 123456789101112131415Handler.javapublic void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 判断msg.callback是不是null，如果不是，那么就给这个callback处理，这个callback是message中的一个Runnable；Message.obtain()其实是有其他参数的方法的，其中有一个是obtain(Handler h, Runnable callback)；如果你用了这个，那么消息就会在你实现的Runnable中接收到处理的回调； 第二个是判断handler内部的callback是不是null，如果不是null，就让他去处理，这里的Callback可不是Runnable了，他是一个interface，里面定义了一个handleMessage(Message msg);方法，这个怎么实现呢？handler类里同样有Handler(Callback callback)构造方法 最后才轮到handler类里的方法handleMessage来处理消息。 底层原理 采用管道的方式完成线程间通信 Handler引起的内存泄露原因以及最佳解决方案Handler允许我们发送延时消息，如果在延时期间用户关闭了Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。 将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并在Acitivity的onDestroy()中调用handler.removeCallbacksAndMessages(null)及时移除所有消息。具体用法可以参考Handler基本用法 参考 https://www.jianshu.com/p/03d29cfe85cc https://www.jianshu.com/p/b4d745c7ff7a","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"OkHttp","slug":"Android/开源库/OkHttp","date":"2021-05-29T06:50:55.099Z","updated":"2021-07-12T05:46:31.279Z","comments":true,"path":"wiki/Android/开源库/OkHttp/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/OkHttp/","excerpt":"","text":"流程图 同步请求 异步请求 判断当前 call 是否只执行了一次，否则抛出异常 创建一个 AsyncCall 对象，它其实是一个 Runable 对象 通过 client.dispatcher().enqueue() 传入 AsyncCall 对象执行异步请求，如果当前运行的异步任务队列(runningAsyncCalls)元素个数小于maxRequests 并且当前请求的 Host 个数小于 maxRequestsPerHost 则直接放进运行对象并执行当前的任务，否则放进准备队列中 (readyAsyncCalls) 如果第 3 步可以执行，则会调用 AsyncCall 的 execute 方法，之后调用 getResponseWithInterceptorChain() 获取 Response，执行onResponse 或 onFailure。这也 印证了上面提到的异步任务回调是在子线程中 execute 方法末尾会必调 client.dispatcher().finished(this) 方法 finished 方法中会做三件事: 从 runningAsyncCalls 中清除当前任务 通过 promoteCalls方法调整整个异步任务队列，主要工作是判断准备队列 readyAsyncCalls 中的任务是否可以执行 重新计算正在执行的任务数量，为 0 则执行 idleCallback 拦截器 拦截器可以添加、移除或者替换请求的头信息，也可以改变传输的主体部分。 应用拦截器发送前进行拦截 网络拦截器对响应的数据进行拦截 内部拦截器RetryAndFollowUpInterceptor重定向拦截器：客户端向服务器发送一个请求，获取对应的资源，服务器收到请求后，发现请求的这个资源实际放在另一个位置，于是服务器在返回的响应头的Location字段中写入那个请求资源的正确的URL，并设置reponse的状态码为30x 。 工作流程 创建一个 StreamAllocation。 调用下一个chain 。 判断是否重定向。重定向会对 request做一些修改，返回新的request，否则会返回null。 followUp == null 无重定向，释放资源，直接返回response。 比较重定向前后的 host、port、scheme是否一致，一致的话复用， 否则重新创建 StreamAllocation。 通过 while (true) ，重复步骤 BridgeInterceptor桥接拦截器：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应。 工作流程 发起请求前： 如果这个请求有请求体，就添加 Content-Type, Content-Length等。 如果这个请求没有 Host，就通过 url 来获取 Host 值添加到 Header中。 如果这个请求没有接收的数据类型 Accept-Encoding，且没指定接收的数据范围，就添加默认接受格式为 gzip。 去 CookieJar 中 根据 url 查询 Cookie 添加到 Header。 如果当前没有，就添加 User-Agent 信息。 发起请求后: 解析响应 Header 中的 Cookie 如果想要数据的格式是 gzip，就创建 GzipSource 进行解压， 同时移除 Content-Encoding 和 Content-Length CacheInterceptor缓存拦截器：最快的请求就是不请求，直接用缓存。 根据Request和之前缓存的Response得到CacheStrategy 根据 CacheStrategy决定是请求网络还是直接返回缓存 如果 step 2中决定请求网络，则在这一步将返回的网络响应和本地缓存对比，对本地缓存进行改增删操作 ConnectInterceptor连接拦截器：部维护了可以重复使用的 Socket 连接池，减少握手次数，加快请求响应 连接 RealConnection 是对 Socket 的封装。 OkHttp 的连接复用主要是通过 StreamAllocation 来实现的，每个连接上持有一个。 StreamAllocation 引用的列表，以此来标识当前连接是否空闲。它里面维护了List的引用。List中StreamAllocation的数量也就是socket被引用的计数，如果计数为0的话，说明此连接没有被使用就是空闲的，需要通过下文的 算法实现回收;如果计数不为0，则表示上层代码仍然引用，就不需要关闭连接。 判断连接是否可以重用，除了比较连接当前的 host，也可以比较路由信息。 连接池在添加新连接时会运行清理任务，默认最多空闲连接为5，最长空闲时间为5分钟。 CallServerInterceptor读写拦截器：它负责实现网络 IO，所有拦截器都要依赖它才能拿到响应数据。 CallServerInterceptor 首先会将请求中的 header 写给服务器。 如果有请求体的话，会再将 body 发送给服务器。 最后通过httpCodec.finishRequest() 结束 http 请求的发送。 然后从连接中读取服务器的响应，并构造 Response。 如果请求的 header或服务器 响应的 header 中，Connection 的值为 close，就关闭连接。 最后返回 Response。 Get到的知识点 责任链模式、建造者模式的运用 线程池的运用 参考 https://juejin.cn/post/6898145227765186567","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android逆向记录","slug":"Android/逆向/Android逆向记录","date":"2021-05-29T06:50:55.099Z","updated":"2021-05-29T06:50:55.099Z","comments":true,"path":"wiki/Android/逆向/Android逆向记录/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/Android%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"12345678910111213#反编译apk文件apktool d app-release.apk如果出现编译assets文件夹中的dex文件失败，则使用--only-main-classes参数。#编译修改后的应用apktool b app-release -o output.apk#对编译好的apk进行签名apksigner sign --ks keystore文件路径 output.apk~/Android/sdk/build-tools/29.0.3/apksigner sign --ks ~/Android/tools/keys/test_keystore lizhi_output.apk 签名参考：https://developer.android.com/studio/command-line/apksigner?hl=zh-cn META-INF文件夹的内容 MINFEST.MF：声明了资源，与CERT.SF文件相似。CERT.RSA：公钥证书。keytool -printcert -file CERT.RSA 输出证书内容 1234567891011所有者: CN=Bbcallen, OU=danmaku.tv, O=danmaku.tv, L=Zhuhai, ST=Guangdong, C=CN发布者: CN=Bbcallen, OU=danmaku.tv, O=danmaku.tv, L=Zhuhai, ST=Guangdong, C=CN序列号: 4f3bb0ec有效期为 Wed Feb 15 21:19:40 CST 2012 至 Thu Nov 18 21:19:40 CST 2066证书指纹: MD5: 71:94:D5:31:CB:E7:96:0A:22:00:7B:9F:6B:DA:A3:8B SHA1: 96:DC:60:5B:95:19:BA:B9:4E:DD:BE:AA:A0:59:A6:69:FB:A2:C2:11 SHA256: 93:BA:27:0F:55:21:13:9E:CA:FE:4B:B6:38:AC:5B:11:98:BC:54:8F:62:D9:FD:8F:85:80:A0:79:FA:F5:91:0E签名算法名称: SHA1withRSA主体公共密钥算法: 1024 位 RSA 密钥版本: 3 CERT.SF：包含了app的所有资源文件，负责对app进行签名， Android Studio动态调试12345678910111213141516171819202122232425262728反编译apk文件，添加debug属性，打包、签名新的可debug的apk。安装。安装Android Studio插件smalideahttps://bitbucket.org/JesusFreke/smali/downloads/使用baksmali反编译apk文件java -jar baksmali -o myapp/src先启动应用，查看主activityadb shell &quot;dumpsys activity top | grep ACTIVITY&quot;然后以debug模式启动appadb shell am start -D -n androiddemo.han.com.myapplication/.MainActivity查看进程adb shell &quot;ps | grep 包名&quot;端口转发adb forward tcp:8787 jdwp:app_pidadb shell am set-debug-app -w --persistent 包名 一直使用debug模式启动应用adb shell am clear-debug-app 取消使用debug启动应用","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android sdk目录结构","slug":"Android/基础/Android sdk目录结构","date":"2021-05-29T06:50:55.098Z","updated":"2021-06-10T10:15:06.848Z","comments":true,"path":"wiki/Android/基础/Android sdk目录结构/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Android%20sdk%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"sdk add-ons：第三方公司为Android平台开发的附加功能系统 build-tools：构建工具 28.0.3： aapt.exe：打包res资源文件，生成R.java、resources.arsc和res aapt2.exe aidl.exe apksigner.bat bcc_compat.exe d8.bat dexdump.exe dx.bat llvm-rs-cc.exe mainDexClasses.bat split-select.exe zipalign.exe cmake docs：API文档 emulator extras：存放Android support v4、v7、v13、v17包 fonts licenses lldb：C/C++调试器，它与LLVM编译器一起使用，提供了丰富的流程控制和数据检测 ndk-bundle ndk-build.cmd ndk-depends.cmd ndk-gdb.cmd ndk-stack.cmd ndk-which.cmd patcher platforms：根据API level存放不同版本的Android系统 android-28：28表示版本 data：系统资源 optional skin：Android模拟器的皮肤 android.jar uiautomator.jar platform-tools：Android平台通用工具 adb.exe dmtracedump.exe etc1tool.exe：PNG图像压缩为etc1标准 fastboot.exe：刷机工具 hprof-conv.exe：hprof文件转换命令，将Android Studio工具生成的hprof文件转换成一个标准格式 make_f2fs.exe mke2fs.exe：建立ext2文件系统 sqlite3.exe：数据库工具 sources system-images：模拟器映像文件 tools：Android开发和调试工具 bin archquery.bat avdmanager.bat jobb.bat：处理APK扩展文件的工具 lint.bat：代码检测 monkeyrunner.bat：测试工具 sdkmanager.bat:SDK管理器 uiautomatorviewer.bat：测试工具 android.bat emulator.exe emulator-check.exe mksdcard.exe：使用模拟器时，用来创建sd卡 monitor.bat compileSdkVersion：告诉Gradle用哪个Android SDK版本编译你的应用，使用任何新添加的API都需要对应等级的Android SDK。修改compileSdkVersion不会改变运行时的行为。如果使用Support Library，那么使用最新发布的 Support Library 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 Support Library ，compileSdkVersion 就必需至少是 23 （大版本号要一致！）。 minSdkVersion：设置应用可以运行的最低版本要求 targetSdkVersion：系统会根据这个值来应用最新的行为变化。比如API 23会把你的应用转换到运行时权限模型。当设置targetSdkVersion小于23时，在6.0的机器上不会动态申请权限。 buildToolsVersion：构建工具的版本，其中包括aapt、dx等，这个工具的目录在Android sdk/build-tools/ 参考 https://medium.com/androiddevelopers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd#.tz5zzucma","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android中support的使用","slug":"Android/基础/Android support包","date":"2021-05-29T06:50:55.098Z","updated":"2021-06-10T10:15:06.844Z","comments":true,"path":"wiki/Android/基础/Android support包/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Android%20support%E5%8C%85/","excerpt":"","text":"使用support-vX包的原因 向后兼容 提供不适合打包进framework的功能 支持不同形态的设备 support-v4implemention: &quot;com.android.support:support-v4:27.1.1&quot; v4名称是最开始支持api level4的库，官方在Support Library 24.2.0版本的时候移除了对Android 2.2(API Level 8)及以下版本的支持，所以从Android Support Library 24.2.0开始，V4包支持的最低版本是Android 2.3即API Level 9)，并且把v4库拆分成5个部分，可以在项目中按需要引用，但是必要性不是很大，一是因为这5个部分有依赖关系，二是compat库占了v4库的一半大小，v4库的依赖关系图： Fragment:一个专为解决Android碎片化的类，通过它可以让同一个程序适配不同的屏幕。NotificationCompat:支持更丰富的通知形式；LocalBroadcastManager:适合于应用内的消息传递。ViewPager:一个可以管理子view的viewgroup，用户可以在各个view之间自由切换，这个在很多应用中都有使用到； support-v7V7和V4一样，同样包含多个依赖包，但和V4不同的是，V7下的多个子包并不是后面拆分开来的，而是最初发布时就以各个独立库的形式发布的。它是针对Android 2.3(API Level 9)及以上的版本谷歌提供了一系列的support包（和V4包的命名一样，V7最初支持的最低版本是Android 2.1即API Level 7，所以称其为V7，同样在Android Support Library 24.2.0将V7支持的最低版本改为Android 2.3即API Level 9了），这些support包各自对应着特定的功能，每一个都可以单独地被引用。 implemention: &quot;com.android.support:appcompat-v7:27.1.1&quot;, implemention: &quot;com.android.support:design:27.1.1&quot;, implemention: &quot;com.android.support:recyclerview-v7:27.1.1&quot;, implemention: &quot;com.android.support:cardview-v7:27.1.1&quot;, implemention: &quot;com.android.support:support-annotations:27.1.1&quot;, implemention: &quot;com.android.support:support-vector-drawable:27.1.1&quot;, implemention: &quot;com.android.support:mediarouter-v7:27.1.1&quot;, implemention: &quot;com.android.support:gridlayout-v7:27.1.1&quot;, implemention: &quot;com.android.support:preference-v7:27.1.1&quot;, implemention: &quot;com.android.support:palette-v7:27.1.1&quot;, appcompat-v7：这个包支持对Action Bar接口的设计模式、Material Design接口的实现等，核心类有ActionBar、AppCompatActivity、AppCompatDialog、ShareActionProvider等。当使用依赖这个包后，会自动引入v4包 design： recyclerview-v7：核心类是RecyclerView，用于替换ListView、GridView cardview-v7：支持cardview控件，使用Material Design语言设计，卡片式的信息展示，在电视App中有广泛的使用 support-annotations：支持标注 support-vector-drawable： mediarouter-v7：用于设备间音频、视频交换显示的support包 gridlayout-v7：支持Grid Layout布局的包 preference-v7：支持存储配置数据的包，比如CheckBoxPreference和ListPreference palette-v7：页面的颜色动态变换 support-v13这个包的作用主要是为Android3.2（API Level 13）及以上的系统提供更多地Framgnet特性支持，使用它的原因在于，android-support-v4.jar中虽然也对Fragment做了支持，由于要兼容低版本，导致他是自行实现的 Fragment 效果，在高版本的Fragment的一些特性丢失了，而对于v13以上的sdk版本，我们可以使用更加有效，特性更多的代码。 implemention: &quot;com.android.support:support-v13:27.1.1&quot;, support-v14support-v17支持电视设备 implemention &quot;com.android.support:leanback-v17:27.1.1&quot; AndroidX配置 properties.gradle中配置 //启用AndroidX android.useAndroidX=true //将依赖包也迁移到AndroidX android.enableJetifier=true Android Studio中设置 Refactor -&gt; Migrate to AndroidX 解决依赖冲突的一些方法保持版本统一 强制设置使用某一个版本 android &#123; configurations.all &#123; resolutionStrategy.force &quot;com.squareup.okhttp3:okhttp:3.12.1&quot; &#125; &#125; 依赖的时候使用exclude implementation(&#39;me.drakeet.multitype:multitype:3.4.4&#39;, &#123; exclude group: &#39;com.android.support&#39; &#125;) 参考 https://developer.android.com/jetpack/androidx https://developer.android.com/jetpack/androidx/migrate","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"AndroidManifest描述文件","slug":"Android/基础/AndroidManifest","date":"2021-05-29T06:50:55.096Z","updated":"2021-06-04T10:10:42.047Z","comments":true,"path":"wiki/Android/基础/AndroidManifest/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/AndroidManifest/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?xml version=&quot;1.0&quot; encoding=&quot;uft-8&quot; ?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/red/android&quot; package=&quot;com.example.android&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt; &lt;uses-permission /&gt; &lt;permission /&gt; &lt;permission-tree /&gt; 权限配置 &lt;permission-group /&gt; &lt;instrumentation android:functionalTest=[&quot;true&quot; | &quot;false&quot;] android:handleProfiling=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:name=&quot;string&quot; android:targetPackage=&quot;string&quot; /&gt; &lt;uses-sdk /&gt; &lt;uses-configuration /&gt; &lt;uses-feature /&gt; 环境配置 &lt;supports-screens /&gt; &lt;compatible-screens /&gt; &lt;supports-gl-texture /&gt; 应用基本配置 &lt;application android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:allowBackup=[&quot;true&quot; | &quot;false&quot;] android:backupAgent=&quot;string&quot; android:debuggable=[&quot;true&quot; | &quot;false&quot;] android:description=&quot;string resource&quot; android:enabled=[&quot;true&quot; | &quot;false&quot;] android:hasCode=[&quot;true&quot; | &quot;false&quot;] android:hardwareAccelerated=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:killAfterRestore=[&quot;true&quot; | &quot;false&quot;] android:largeHeap=[&quot;true&quot; | &quot;false&quot;] android:label=&quot;string resource&quot; android:logo=&quot;drawable resource&quot; android:manageSpaceActivity=&quot;string&quot; android:name=&quot;string&quot; android:permission=&quot;string&quot; android:persistent=[&quot;true&quot; | &quot;false&quot;] android:process=&quot;string&quot; android:restoreAnyVersion=[&quot;true&quot; | &quot;false&quot;] android:requiredAccountType=&quot;string&quot; android:restrictedAccountType=&quot;string&quot; android:supportsRtl=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:testOnly=[&quot;true&quot; | &quot;false&quot;] android:theme=&quot;resource or theme&quot; android:uiOptions=[&quot;none&quot; | &quot;splitActionBarWhenNarrow&quot;] android:vmSafeMode=[&quot;true&quot; | &quot;false&quot;] &gt; //界面组件配置 &lt;activity android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;] android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;] android:configChanges=[&quot;mcc&quot;, &quot;mnc&quot;, &quot;locale&quot;, &quot;touchscreen&quot;, &quot;keyboard&quot;, &quot;keyboardHidden&quot;, &quot;navigation&quot;, &quot;screenLayout&quot;, &quot;fontScale&quot;, &quot;uiMode&quot;, &quot;orientation&quot;, &quot;screenSize&quot;, &quot;smallestScreenSize&quot;] android:enabled=[&quot;true&quot; | &quot;false&quot;] android:excludeFromRecents=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;] android:hardwareAccelerated=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:launchMode=[&quot;multiple&quot; | &quot;singleTop&quot; | &quot;singleTask&quot; | &quot;singleInstance&quot;] android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:noHistory=[&quot;true&quot; | &quot;false&quot;] android:parentActivityName=&quot;string&quot; android:permission=&quot;string&quot; android:process=&quot;string&quot; android:screenOrientation=[&quot;unspecified&quot; | &quot;behind&quot; | &quot;landscape&quot; | &quot;portrait&quot; | &quot;reverseLandscape&quot; | &quot;reversePortrait&quot; | &quot;sensorLandscape&quot; | &quot;sensorPortrait&quot; | &quot;userLandscape&quot; | &quot;userPortrait&quot; | &quot;sensor&quot; | &quot;fullSensor&quot; | &quot;nosensor&quot; | &quot;user&quot; | &quot;fullUser&quot; | &quot;locked&quot;] android:stateNotNeeded=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:theme=&quot;resource or theme&quot; android:uiOptions=[&quot;none&quot; | &quot;splitActionBarWhenNarrow&quot;] android:windowSoftInputMode=[&quot;stateUnspecified&quot;, &quot;stateUnchanged&quot;, &quot;stateHidden&quot;, &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;, &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;, &quot;adjustResize&quot;, &quot;adjustPan&quot;] &gt; . . . &lt;/activity&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action /&gt; &lt;category /&gt; &lt;data /&gt; &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data/&gt; 服务组件配置 &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; 触发器组件配置 &lt;meta-data /&gt; &lt;/receiver&gt; 数据源组件配置 &lt;provider android:authorities=&quot;list&quot; android:enabled=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:grantUriPermissions=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:initOrder=&quot;integer&quot; android:label=&quot;string resource&quot; android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:permission=&quot;string&quot; android:process=&quot;string&quot; android:readPermission=&quot;string&quot; android:syncable=[&quot;true&quot; | &quot;false&quot;] android:writePermission=&quot;string&quot; &gt; . . . &lt;/provider&gt;------------------------------------------------------------------------------------------------------------------------------------------- &lt;uses-library /&gt; 依赖库配置------------------------------------------------------------------------------------------------------------------------------------------- &lt;/application&gt;&lt;/manifest&gt; manifest标签 属性 描述 android:installLocation 设置应用的安装环境，如preferExternal表示安装到外部存储设备中；但运行时产生的数据还是会在/data/data目录下 uses-permission标签请求应用使用到的权限 属性 描述 android:name 使用的权限名字 permission标签限定权限来限制第三方应用的访问 属性 描述 android:name android:permissionGroup 权限的分组，如android.permission-group.COST_MONEY提示用户该应用可能会消耗通信费用，如果没有预定义该权限的分组，也可以通过配置项定义 android:label 标签 android:description 描述 instrumentation标签这个元素声明了一个Instrumentation类，这个类能够监视应用程序跟系统的交互。Instrumentation对象会在应用的其他所有组件被实例化之前实例化。 属性 描述 android:functionalTest 这个属性用于指定Instrumentation类是否应该作为一个功能性的测试来运行，如果设置为true，这要运行，否则不应该运行。默认值是false。 android:handleProfiling 这个属性用于指定Instrumentation对象是否会开启和关闭分析功能。如果设置为true，那么由Instrumentation对象来决定分析功能的启动和终止时机，如果设置为false，则分析功能会持续到Instrumentation对象整个运行周期。如果设置为true，会使Instrumentation对象针对一组特定的操作来进行分析。默认值是false。 android:targetPackage 制定Intrumentation对象所监视的应用程序。 uses-feature标签声明应用所依赖的外设或Android的特色功能。比如，一款主打拍照功能的应用需要声明所安装的设备需要有相机 supports-screens标签 属性 描述 android:resizeable 指明应用程序是否根据不同的屏幕尺寸进行缩放。如果设为否，则在较大屏幕上系统将以屏幕兼容模式运行应用程序。本属性已过时。为了帮助程序从Android 1.5升级为1.6才引入本属性，当时第一次引入了对多种屏幕的支持。不应再使用本属性。 android:smallScreens 指明应用程序是否支持较小屏幕。较小的屏幕是指小于“normal”（传统的HVGA）大小的屏幕。不支持小屏幕的应用程序将在外部服务（比如Android Market）中禁止用于小屏幕设备，因为只有很少一部分平台能让程序运行在小屏幕上。缺省值是“true”。 android:normalScreens 指明应用程序是否支持“normal”屏幕尺寸。传统意义上指的是中等密度的HVGA 屏幕，但低密度的WQVGA和高密度的WVGA一般也被视为是正常尺寸。缺省属性是“true”。 android:largeScreens 指明应用程序是否支持大屏幕尺寸。大屏幕是指明显比“normal”手持设备屏幕更大的尺寸。虽然依赖于系统的缩放也能全屏显示，但为了更好的用户体验可能需要对程序组件进行特定的处理。本属性的缺省值依版本而各不相同，因此最好是一直都明确声明这个属性。注意设为“false”将总是启用屏幕兼容模式。 android:xlargeScreens 指明应用程序是否支持超大屏幕尺寸。超大屏幕是指明显比“large”屏幕更大的尺寸，比如平板设备（或更大），虽然依赖于系统的缩放也能全屏显示，但为了更好的用户体验可能需要对程序组件进行特定的处理。本属性的缺省值依版本而各不相同，因此最好是一直都明确声明这个属性。注意设为“false”将总是启用屏幕兼容模式。本属性自API level 9引入。 android:anyDensity 指明应用程序是否包含适用于任何屏幕密度的资源。对于支持Android 1.6 (API level 4)以上版本的应用程序而言，本属性缺省值是“true”。除非绝对确认程序必须要能运行，不应设为“false”。只有应用程序要直接操作位图时（详情参阅支持多种屏幕文档），才可能需要禁用此选项。 android:requiresSmallestWidthDp 指定程序所需的smallestWidth最小值。smallestWidth是指可被程序用户界面使用的屏幕可用空间的最小值（单位为dp）——指可用屏幕两边中最短的那条边长。为了保证与应用程序兼容，设备的smallestWidth必须大于等于本属性值。（通常此值对应于布局layout所支持的“最小宽度”，而与屏幕当前的方向无关。）例如，典型的手持设备的最小宽度是320dp，7英寸的平板设备的最小宽度是600dp，10英寸的平板设备的最小宽度是720dp。因为这些值即为屏幕可用空间的最小值，所以一般也即是smallestWidth的值。在计算屏幕上的组件排列和系统用户界面大小时会与本属性值进行比较。例如，如果设备屏幕上需要显示一些永久性的用户界面元素，这些元素占用的屏幕位置对于其它用户界面元素是不可用的，通过对这些元素尺寸进行计算，系统声明的设备smallestWidth会比实际屏幕尺寸要小些。因此，应该用layout所需的最小宽度来设置此值，而与屏幕的方向无关。如果应用程序能在小屏幕上正确缩放（最低是small尺寸或最小宽度320dp），那就不需要用到本属性。否则，就应该为最小屏幕宽度标识符设置本属性来匹配应用程序所需的最小尺寸。警告：Android系统并不关心本属性，因此它不会影响程序运行时的表现。它是用于为诸如Android Market之类的服务启用过滤功能。不过，Android Market 当前还不支持对这个属性的过滤（Android 3.2），因此如程序不支持小屏幕的话还应继续使用其它屏幕尺寸的属性来进行限制。本属性自API level 13引入。 android:compatibleWidthLimitDp 通过指定程序支持的“最小屏幕宽度”的最大值，本属性可启用屏幕兼容模式作为用户可选项。如果设备可用屏幕的最小边长大于在此设置的值，用户将仍可以安装程序，但会运行在屏幕兼容模式。缺省情况下，屏幕兼容模式将被关闭，layout将如常缩放至全屏显示，但系统状态栏中会出现一个按钮，用户可以用此按钮来开关屏幕兼容模式。如果应用程序能兼容所有的屏幕尺寸，layout也能正确缩放，那就不需要用到本属性。注意：目前屏幕兼容模式只能在手持设备上仿真320dp宽度的屏幕，因此ndroid:compatibleWidthLimitDp大于320时屏幕兼容模式将不会生效。本属性自API level 13引入。 android:largestWidthLimitDp 通过指定程序支持的“最小屏幕宽度”的最大值，本属性可强制开启屏幕兼容模式。如果设备屏幕的最小边长大于本属性值，应用程序将运行在屏幕兼容模式，且用户无法将其关闭。如果应用程序能兼容所有的屏幕尺寸，layout也能正确缩放，那就不需要用到本属性。不然也应优先考虑使用android:compatibleWidthLimitDp属性。仅当应用程序缩放到大屏幕时会崩溃，屏幕兼容模式是用户使用的唯一方式，才会用到android:largestWidthLimitDp属性。注意：目前屏幕兼容模式只能在手持设备上仿真320dp宽度的屏幕，因此android:largestWidthLimitDp大于320时屏幕兼容模式将不会生效。本属性自API level 13引入。 uses-sdk标签 属性 描述 targetSdkVersion minSdkVersion application 属性 描述 android:uiOptions “none” 默认值”splitActionBarWhenNarrow”，分裂ActionBar用来分开action item，在屏幕底部出现一个actionbar来显示顶部显示不完的items android:backupAgent 云端存储组件声明，该组件一个应用只有一个。其值为BackupAgent的子类 android:allowbackup 是否允许备份 android:allowClearUserData 用户是否能选择自行清除数据，默认为true，程序管理器包含一个选择允许用户清除数据。当为true时，用户可自己清理用户数据，反之亦然 android:testOnly 用于判断该应用是否用于测试 android:largeHeap 可以给程序分配大内存。 getMemoryClass() 或getLargeMemoryClass()查询可用内存 activity 属性 描述 android:launchMode 运行模式 android:configChanges 当配置变化时，activity将会重启，但声明了这个属性会阻止activity重新启动，而调用onConfigurationChanged() android:screenOrientation activity在设别中的显示方向 android:parentActivityName 指定父级的activity。系统根据这个属性来决定当使用actionbar的向上按钮时那个activity响应 android:taskAffinity 表示当前activity进入的task adnroid:finishOnTaskLanuch 离开这个Task栈, 则系统会马上清除这个Activity,不管这个Activity在堆栈的任何位置. android:allowTaskReparenting 允许当前Activity可以在任务栈中移动 android:alwaysRetaainTaskState android:excludeFromRecents android:stateNotNeeded android:exported 是否可以导出，是否可以被外部访问 android:clearTaskOnLaunch 当值为true, 只要你一离开这个Task栈, 则系统会马上清理除了Root Activity的全部Activity. android:windowSoftInputMode android:permission android:alwaysRetainTaskState intent-filtermeta-dataactivity-aliastargetActivity属性所指activity的别名。别名会作为一个独立的实体来代表目标Activity。它能够有自己的Intent过滤器。该标签的其他属性是属性的一个子集，对于子集中的属性，不会把目标Activity中所设置的任何值转交给别名Activity，但对于子集中所没有的属性，则目标Activity所设置的值有会应用到别名Activity。 属性 描述 android:enabled android:exported servicereceiverprovider声明内容存储组件 属性 描述 android:authorities android:enabled 是否可以被实例化。只有当application和provider中的enabled都为true时，provider才可以 android:name uses-library引用类库 属性 描述 android:name 指定类库的名称 android:required 是否一定要找个库，true的时候，如果机器上没有这个库则不能安装","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Dagger2学习笔记","slug":"Android/开源库/Dagger2","date":"2021-05-29T06:50:55.096Z","updated":"2021-06-02T06:05:07.610Z","comments":true,"path":"wiki/Android/开源库/Dagger2/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Dagger2/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[]},{"title":"Android常见问题整理","slug":"Android/未分类/Android常见问题整理","date":"2021-05-29T06:50:55.095Z","updated":"2021-06-04T02:36:58.643Z","comments":true,"path":"wiki/Android/未分类/Android常见问题整理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/Android%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"","text":"问题描述12345678!SESSION 2017-08-29 15:27:40.107 ----------------------------------------------- eclipse.buildId=unknown java.version=1.8.0_112-release java.vendor=JetBrains s.r.o BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN Command-line arguments: -os win32 -ws win32 -arch x86_64 -data @noDefault... !ENTRY org.eclipse.osgi 4 0 2017-08-29 15:27:41.441 !MESSAGE Application error !STACK 1 java.lang.NullPointerException at org.eclipse.core.runtime.URIUtil.toURI(URIUtil.java:280) at org.eclipse.e4.ui.internal.workbench.ResourceHandler.loadMostRecentModel(ResourceHandler.java:127)... 解决办法 进程管理器中杀死monitor.exe进程； 删除$HOME/.android/monitor-workspace目录 参考 https://tutel.me/c/programming/questions/26052849/unexpected+error+while+parsing+input+invalid+uiautomator+hierarchy+file 问题描述12345* What went wrong:Execution failed for task &#x27;:app:transformDexArchiveWithExternalLibsDexMergerForDebug&#x27;.&gt; com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives: Program type already present: org.intellij.lang.annotations.Identifier Learn how to resolve the issue at https://developer.android.com/studio/build/dependencies#duplicate_classes. 解决办法android &#123; configurations &#123; cleanedAnnotations compile.exclude group: &#39;org.jetbrains&#39; , module:&#39;annotations&#39; &#125; &#125; 参考 https://stackoverflow.com/questions/49811851/program-type-already-present-org-intellij-lang-annotations-flow 问题描述1Error:Execution failed for task &#x27;:app:javaPreCompilePreProductDebug&#x27;. &gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. 解决办法android &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath true &#125; &#125; &#125; 参考 问题描述1234567FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project &#x27;:myProject&#x27;.&gt; Could not resolve all files for configuration &#x27;:myProject:classpath&#x27;.&gt; Could not find org.jetbrains.trove4j:trove4j:20160824. Searched in the following locations: 解决办法找不到依赖，添加仓库地址。 buildscript &#123; repositories &#123; google() jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; mavenCentral() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.3.2&#39; &#125; &#125; allprojects &#123; repositories &#123; google() jcenter() mavenCentral() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; &#125; 参考 https://blog.csdn.net/rooney8/article/details/86065188 问题描述1Android-SDK/ndk-bundle/build/core/add-application.mk:178: ### * Android NDK: APP_STL gnustl_shared is no longer supported. Please switch to either c++_static or c++_shared. See https://developer.android.com/ndk/guides/cpp-support.html for more information. . Stop. 解决办法修改项目中Application.mk文件，将其中的APP_STL := gnustl_static改成APP_STL := c++_static 参考 https://stackoverflow.com/questions/52475177/android-ndk-app-stl-gnustl-shared-is-no-longer-supported 问题描述1This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_SUPPORT_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead. 解决办法修改主题属性 参考 https://my.oschina.net/ocean870227/blog/738442","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"未分类","slug":"Android/未分类","permalink":"http://shjlone.github.io/categories/Android/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"观察者模式","slug":"设计模式/行为型模式/观察者模式","date":"2021-05-29T06:50:55.093Z","updated":"2021-07-13T01:44:42.809Z","comments":true,"path":"wiki/设计模式/行为型模式/观察者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义Observer Pattern：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 类图 角色 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 优缺点 满足开闭原则 设计原则 多用组合，少用继承 针对接口编程 为交互对象之间的松耦合努力 使用场景 java.util包中 在Java中，GUI的按钮等UI的事件响应 Java中提供了Observable，给我们快速实现观察者模式。但由于单继承的原因，使用这个类还是会有些限制 参考 《Head First 设计模式》","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"AsyncTask原理解析","slug":"Android/基础/AsyncTask原理解析","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-15T01:50:53.762Z","comments":true,"path":"wiki/Android/基础/AsyncTask原理解析/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/AsyncTask%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"IO","slug":"Java/基础/IO","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-07T08:00:44.585Z","comments":true,"path":"wiki/Java/基础/IO/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/IO/","excerpt":"","text":"BIO：BlockIO，同步阻塞IO。发起请求 –&gt;一直阻塞–&gt;处理完成 NIO：New IO Non-Block IO，同步非阻塞IO。 Selector主动轮询channel–&gt;处理请求–&gt;处理完成 AIO：异步非阻塞IO。发起请求–&gt; 通知回调 NIO主要有三大核心部分:Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件(比如:连接打开，数据到 达)。因此，单个线程可以监听多个数据通道。 NIO和传统IO(一下简称IO)之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何 地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓 存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时 可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包 含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处 理的数据。 IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一 些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。NIO的非阻塞模式，使 一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用 时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继 续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完 全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执 行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道(channel)。 基于字节的IO操作 基于字符的IO操作 常用类节点流FileInputStream/FileOutputStream， FileReader/FileWriter 这四个类是专门操作文件流的，用法高度相似，区别在于前面两个是操作字节流， 后面两个是操作字符流。它们都会直接操作文件流，直接与 OS 底层交互。因此他们也被称为节点流。 包装流PrintStream/PrintWriter/Scanner PrintStream 可以封装(包装)直接与文件交互的节点流对象 OutputStream, 使 得编程人员可以忽略设备底层的差异，进行一致的 IO 操作。因此这种流也称为处理流或者包装流。 PrintWriter 除了可以包装字节流 OutputStream 之外，还能包装字符流 Writer Scanner 可以包装键盘输入，方便地将键盘输入的内容转换成我们想要的数据类 型。 字符串流StringReader/StringWriter 这两个操作的是专门操作 String 字符串的流，其中 StringReader 能从 String 中 方便地读取数据并保存到 char 数组，而 StringWriter 则将字符串类型的数据写 入到 StringBuffer 中(因为 String 不可写)。 转换流InputStreamReader/OutputStreamReader 这两个类可以将字节流转换成字符流，被称为字节流与字符流之间的桥梁。我们 经常在读取键盘输入(System.in)或网络通信的时候，需要使用这两个类 缓冲流BufferedReader/BufferedWriter ， BufferedInputStream/BufferedOutputStream 总结 FileInputStream/FileOutputStream 需要逐个字节处理原始二进制流的时 候使用，效率低下 FileReader/FileWriter 需要组个字符处理的时候使用 StringReader/StringWriter 需要处理字符串的时候，可以将字符串保存为 字符数组 PrintStream/PrintWriter 用来包装 FileOutputStream 对象，方便直接将 String 字符串写入文件 Scanner 用来包装 System.in 流，很方便地将输入的 String 字符串转换 成需要的数据类型 InputStreamReader/OutputStreamReader , 字节和字符的转换桥梁，在网 络通信或者处理键盘输入的时候用 BufferedReader/BufferedWriter ， BufferedInputStream/BufferedOutputStream ， 缓冲流用来包装字节流后者 字符流，提升 IO 性能，BufferedReader 还可以方便地读取一行，简化编程。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java中的异常","slug":"Java/基础/Java中的异常","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-07T07:53:26.342Z","comments":true,"path":"wiki/Java/基础/Java中的异常/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/","excerpt":"","text":"Java语言是编译型语言，Java代码编译成字节码，然后由JVM解释成目标代码由CPU执行;这里包含我们常说的两个过程，即编译时和运行时;Java语言把编译时可能产生的异常称为受检查异常，把运行时可能产生的异常称为不受检查异常(比如NullPointException和ClassNotFoundException)。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"String","slug":"Java/基础/String","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-29T10:17:01.183Z","comments":true,"path":"wiki/Java/基础/String/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/String/","excerpt":"","text":"StringBuilder和StringBuffer 和String类不同的是，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 类在Java5中被提出，它和StringBuffer之间的最大不同在于StringBuilder的方法不是线程安全的","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"AQS解析","slug":"Java/并发编程/AQS解析","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-15T01:50:53.769Z","comments":true,"path":"wiki/Java/并发编程/AQS解析/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"CountDownLatch","slug":"Java/并发编程/CountDownLatch","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-29T01:42:44.689Z","comments":true,"path":"wiki/Java/并发编程/CountDownLatch/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CountDownLatch/","excerpt":"","text":"说明CountDownLatch是在java1.5被引入，使一个线程等待其他线程各自执行完毕后再执行。 CountDownLatch是通过共享锁实现的。在创建CountDownLatch中时，会传递一个int类型参数count，该参数是“锁计数器”的初始状态。当某线程调用该CountDownLatch对象的await()方法时，该线程会等待“共享锁”可用时，才能获取共享锁进而继续运行。而“共享锁”可用的条件，就是锁计数器的值为0！而锁计数器的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，锁计数器减1；直到锁计数器为0时，前面的等待线程才能继续运行！ 使用场景 让多个线程等待：比如模拟多线程并发 让单个线程等待：等待其他线程都处理完后，再执行某个操作 实现原理参考 https://www.cnblogs.com/skywang12345/p/3533887.html https://zhuanlan.zhihu.com/p/148231820","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"ReentrantLock","slug":"Java/并发编程/ReentrantLock","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-07T09:37:24.072Z","comments":true,"path":"wiki/Java/并发编程/ReentrantLock/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock/","excerpt":"","text":"概述ReentrantLock是重入锁。它实现了Lock接口，是基于AQS(一种用于构建同步器的框架)构造出来的一种同步器。 与synchronized相比增加了一些高级功能， 主要有以下三项:等待可中断、可实现公平锁、锁可以绑定多个条件。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"内存分配策略","slug":"Java/虚拟机/内存分配策略","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-08T10:13:03.002Z","comments":true,"path":"wiki/Java/虚拟机/内存分配策略/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","excerpt":"","text":"JVM栈帧及方法调用详解 JMM、Java Memory Model 对象优先在Edenf分配大对象直接进入老年代长期存活的对象将进入老年代动态对象年龄判定空间分配担保","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://shjlone.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://shjlone.github.io/tags/JVM/"}]},{"title":"垃圾回收机制","slug":"Java/虚拟机/垃圾回收机制","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-08T10:13:07.425Z","comments":true,"path":"wiki/Java/虚拟机/垃圾回收机制/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"对象存活 GC算法 运行时数据区 可达性分析与引用计数引用计数法给对象增加一个引用计数器，每当有一个地方引用它时，计数器就+1;当引用失效时，计数器就-1;任何时刻计数器为 0 的对象就是不能再被使用的，即对象已“死”。在主流的 JVM 中没有选用引用计数法来管理内存，最主要的原因是引用计数法无法解决对象的循环引用问题。 可达性分析算法通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任 何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。以下图为例: 对象 Object5 —Object7 之间虽然彼此还有联系，但是它们到 GC Roots 是不可 达的，因此它们会被判定为可回收对象。 在 Java 语言中，可作为 GC Roots 的对象包含以下几种: 虚拟机栈(栈帧中的本地变量表)中引用的对象。 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中(Native 方法)引用的对象 在 JDK1.2 之后，Java 对引用的概念做了扩充，将引用分为强引用(StrongReference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用 (Phantom Reference)四种，这四种引用的强度依次递减。 即使在可达性分析算法中不可达的对象，也并非”非死不可”的，这时候他们暂时处在”缓刑”阶段。要宣告一个对象的真正死亡，至少要经历两次标记过程: 如果对象在进行可达性分析之后发现没有与 GC Roots 相连接的引用链，那它 将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已经被 JVM 调 用过，虚拟机会将这两种情况都视为”没有必要执行”，此时的对象才是真正” 死”的对象。 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在 一个叫做 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer 线程去执行它(这里所说的执行指的是虚拟机会触发finalize() 方法)。finalize()方法是对象逃脱死亡的最后一次机会，稍后 GC 将对 F-Queue中的对象进行第二次小规模标记，如果对象在finalize()中成功拯救自己(只需 要重新与引用链上的任何一个对象建立起关联关系即可)，那在第二次标记时它将会被移除出”即将回收”的集合;如果对象这时候还是没有逃脱，那基本上它就是真的被回收了。 回收方法区方法区(永久代)的垃圾回收主要收集两部分内容:废弃常量和无用类。回收废弃常量和回收 Java 堆中的对象十分类似。以常量池中字面量(直接量)的回 收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个 String 对象引用常量池中的”abc”常量，也没有其他地方引用这个字面量，如果此时发生 GC 并且有必要的话，这个”abc”常量会被系统清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。 判定一个类是否是”无用类”则相对复杂很多。类需要同时满足下面三个条件才会 被算是”无用的类”。 该类的所有实例都已经被回收(即在 Java 堆中不存在任何该类的实例) 加载该类的 ClassLoader 已被回收 该类对应的 Class 对象没有任何其他地方被引用，无法在任何地方通过反射访问该类的方法 垃圾回收算法标记-清除算法复制算法（新生代回收算法）标记整理算法（老年代回收算法）分代收集算法","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"虚拟机","slug":"Java/虚拟机","permalink":"http://shjlone.github.io/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://shjlone.github.io/tags/JVM/"}]},{"title":"内存模型","slug":"Java/进阶/内存模型","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-08T08:07:24.305Z","comments":true,"path":"wiki/Java/进阶/内存模型/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"概述Java 内存模型 (Java Memory Model) 定义了 JVM 如何正确访问计算机主内存。JMM 指定了不同线程如何以及何时可以看到其他线程写入到共享变量的值，以及如何在必要时同步访问共享变量。 Java 多线程之间通信一般有两种方式: 共享内存和消息传递。Java 的并发采用共享内存的方式，共享内存通信方式对于程序员而言总是透明隐式进行的。 JMM 关键技术点都是围绕着多线程的原子性、可见性、有序来讨论的。JMM 解决了可见性和有序性的问题，而锁解决了原子性的问题。 Java 内存模型的可见性问题的底层实现是通过内存屏障 (memory barriers) 实现。 现代计算机内存模型： Java内存模型： 具体操作 read 读取，作用于主内存把变量从主内存中读取到本本地内存。 load 加载，主要作用本地内存，把从主内存中读取的变量加载到本地内存的变量副本中use 使用，主要作用本地内存，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到 一个需要使用变量的值的字节码指令时将会执行这个操作。 assign 赋值 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变 量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store 存储 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随 后的write的操作。 write 写入 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的 变量中。 lock 锁定 :作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock 解锁:作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 规则 不允许read和load、store和write的操作单独出现。 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存 中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或 assign)的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 如果对 一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要 重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作;也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操作) 内存结构JVM运行时内存结构 程序计数器：程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。 Java栈(虚拟机栈)：栈描述的是Java方法执行的内存模型。每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 栈分为3个部分:基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 堆区:堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。 存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 方法区: 又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 在JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。 线程栈JVM 内存结构中有一个非常重要的内存区域叫做线程栈 , 每个线程的栈大小可以通过设置 JVM 参 数-Xss, -Xss128k 表示每个线程堆栈大小为 128K，JDK1.5 默认值为 1M。(Android也是，每当新建一个线程，native就会划分1M左右空间出来) 线程栈内存存储了基本类型变量和对象引用，当访问了对象的某一实例变量时，通过在栈中获得对象引用再获取变量的值，然后将变量的值拷贝至线程的工作内存。 每个线程 (处理器) 都有工作内存，工作内存存了该线程以读写共享变量的副本。工作内存是 JMM 抽象概念 , 并不真实存在。 read and load 从主存复制变量到当前工作内存; use and assign 执行代码，改变共享变量值; store and write 用工作内存数据刷新主存相关内容; 其中 use and assign 可以多次出现。 但是这一些操作并不是原子性，也就是在 read load 之后，如果主内存 count 变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。 可见性可见性指的是一个线程对变量的写操作对其他线程后续的读操作可见。 由于现代 CPU 都有多级缓存，CPU 的操作都是基于高速缓存的，而线程通信是基于内存的，这中间有一个Gap, 可见性的关键还是在对变量的写操作之后能够在某个时间点显示地写回到主内存， 这样其他线程就能从主内存中看到最新的写的值。 volatile，synchronized(隐式锁), Lock（显式锁），Atomic（原子变量）这些同步手段都可以保证可见性。可见性底层的实现是通过加内存屏障实现的: 写变量后加写屏障，保证 CPU 写缓冲区的值强制刷新回主内存; 读变量之前加读屏障，使缓存失效，从而强制从主内存读取变量最新值。 指令重排序对于处理器而言，一条汇编指令的执行时分为很多步骤的。在多处理器下，一个汇编指令不一定是原子操作的。为提高CPU利用率，加快执行速度，将指令分为若干个阶段，可并行执行不同指令的不同阶段，从而多个指令可以同时执行。 数据依赖性 上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。前面提到过，编译 器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和 处理器不会改变存在数据依赖关系的两个操作的执行顺序。这里所说的数据依赖性仅针对单个处 理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性 不被编译器和处理器考虑。 as-if-serial不管怎么重排序，(单线程)程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。 为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。 happens-before 原则happen 与 before 规则阐述操作之间的内存可见性，目的都是为了在不改变程序的语义情况下提 高程序的并行度。在 JMM 中，如果一个操作执行的结果需要对另一个操作线程，那么这两个操作之间必须存在 happen-before 关系。 程序次序规则:一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作; 锁定规则:一个 unLock 操作先行发生于后面对同一个锁的 lock 操作; volatile 变量规则:对一个变量的写操作先行发生于后面对这个变量的读操作; 传递规则:如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C; 线程启动规则:Thread 对象的 start() 方法先行发生于此线程的每个一个动作; 线程中断规则:对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生; 线程终结规则:线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行; 对象终结规则:一个对象的初始化完成先行发生于他的 finalize() 方法的开始; 程序顺序规则:一个线程中的每个操作，happen-before 于该线程中的任意后续操作; 监视器锁规则:对一个锁的解锁，happens-before 于随后对这个锁的加锁; Volatile 变量规则:对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读; 传递性:如果 A happens-beforeB , 且 B happens-before C, 那么 A happens-before C; Start 规则: 如果线程 A 执行操作 ThreadB.start()(启动线程 B), 那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作。 参考 《Time，Clocks and the Ordering of Events in a Distributed System》","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[]},{"title":"动态代理","slug":"Java/进阶/动态代理","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-02T03:27:07.621Z","comments":true,"path":"wiki/Java/进阶/动态代理/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.shjlone.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 动态代理demo */public class ProxyClient &#123; public static void main(String[] args) &#123; Shape realSubject = new Circle(); InvocationHandler handler = new DynamicProxy(realSubject); Shape subject = (Shape) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); subject.draw(); &#125;&#125;interface Shape &#123; void draw();&#125;class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;draw cicle&quot;); &#125;&#125;class DynamicProxy implements InvocationHandler &#123; private Object subject; public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(subject, args); &#125;&#125; 参考 https://allenwu.itscoder.com/use-of-proxy","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[]},{"title":"反射","slug":"Java/进阶/反射","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-08T09:30:26.642Z","comments":true,"path":"wiki/Java/进阶/反射/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射（Reflection）的作用： 反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。 反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。 测试时可以利用反射API访问类的私有成员，以保证测试代码覆盖率。 API 获取Class对象12345678910//获取Class的方法Class clz = Class.forName(&quot;java.lang.String&quot;);Class clz = String.class;String str = new String(&quot;Hello&quot;);Class clz = str.getClass(); 创建对象如果默认无参构造函数是public，则可以直接使用class.newInstance()，而如果没有，则需要使用getDeclaredConstructor。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Rectangle &#123; public int x; public int y;&#125;class User &#123; private String name; private int age; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class TestPerformance &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; Class c1 = Rectangle.class; c1.newInstance(); Class user = User.class; //需要填充参数 user.getDeclaredConstructor(String.class, int.class).newInstance(&quot;zhangsan&quot;, 19); &#125;&#125; 获取属性、方法123456789101112131415161718//获取方法Method[] methods = user.getDeclaredMethods();for (Method method : methods) &#123; System.out.println(method.getName());&#125;//获取属性Field[] fields = user.getDeclaredFields();for (Field field : fields) &#123; System.out.println(field.getName());&#125;//调用方法User user1 = new User(&quot;lisi&quot;, 20);Method method = user1.getClass().getMethod(&quot;setAge&quot;, int.class);method.setAccessible(true); //如果是私有方法，需要执行这样语句method.invoke(user1, 88);System.out.println(user1); 这里需要注意的是，getDeclaredFields方法可以拿到私有属性，而getFields不行。 性能分析虽然反射功能很强大，但在使用过程中要注意效率问题。因为： 因为接口的通用性，Java的invoke方法是传object和object[]数组的。基本类型参数需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC。 编译器难以对动态调用的代码提前做优化，比如方法内联。 反射需要按名检索类和方法，有一定的时间开销。 我们可以进行简单的测试： 123456789101112131415Class c1 = User.class;long duration = 0;duration = System.currentTimeMillis();for(int i=0; i&lt;999999999;i++) &#123; c1.newInstance();&#125;long current = System.currentTimeMillis();System.out.println(current - duration);for(int i=0; i&lt;999999999;i++) &#123; new User(&quot;zhangsan&quot;, 20);&#125;System.out.println(System.currentTimeMillis() - current); 以上代码的输出结果，两者差距有近千倍！！！ 参考 https://www.jianshu.com/p/356e1d7a9d11","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[]},{"title":"引用类型","slug":"Java/进阶/引用类型","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-01T13:03:30.178Z","comments":true,"path":"wiki/Java/进阶/引用类型/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"概要介绍Java中的几种引用类型： 强引用: 强引用指的是在程序代码之中普遍存在的，类似于”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象实例。 软引用: 软引用是用来描述一些还有用但是不是必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围 之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢 出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用: 弱引用也是用来描述非必需对象的。但是它的强度要弱于软引用。被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾回收 器开始进行工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的 对象。在 JDK1.2 之后提供了 WeakReference 类来实现弱引用。 虚引用: 虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是 能在这个对象被收集器回收时收到一个系统通知。在 JDK1.2 之后，提供了PhantomReference 类来实现虚引用。 参考资料","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[]},{"title":"泛型","slug":"Java/进阶/泛型","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-08T09:29:03.281Z","comments":true,"path":"wiki/Java/进阶/泛型/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"概述范型的设计参考了C++中的模版，目的是写出更加通用的代码。泛型将代码安全性检查提前到编译期。添加了范型特性后，解决了Java中容器的类型安全问题。 泛型的本质是参数化类型。也就是说，泛型就是将所操作的数据类型作为参数的一种语法。 Java泛型为了向前兼容，采取运行期类型擦出泛型参数的方式来实现。这就意味着，你在使用泛型的时候，任何具体的类型都已经被擦除。 12345public class Paly&lt;T&gt;&#123; T play()&#123;&#125;&#125;Play&lt;Integer&gt; playInteger=new Play&lt;&gt;();//这里 T 就会被实例化为 Integer 泛型类型自定义泛型接口1interface Observer&lt;T&gt; 泛型类1class ImplObserver&lt;T&gt; implements Observer&lt;T&gt; 泛型方法 泛型作用域 如果将泛型声明放在泛型接口,泛型类上,则该泛型在该类中就是确定的了。 如果将泛型声明放在了泛型方法上,则该泛型只在该方法中有效。 如果泛型方法上声明的泛型类型和类或接口中声明的泛型一致,则会在该方法中隐藏类或接口上的泛型。 通配符与嵌套通配符?:表示类型不确定，只能用于声明变量或者形参上，不能用在创建泛型类，泛型方法和接口上 123456public static void main(String[] args) &#123; List&lt;?&gt; list=new ArrayList&lt;Integer&gt;(); list=new ArrayList&lt;String&gt;(); test(list);&#125;public static void test(List&lt;?&gt; list)&#123; &#125; 泛型嵌套1234567891011121314151617181920212223242526272829303132class Student&lt;T&gt;&#123; private T score; public T getScore()&#123; return score; &#125; public void setScore(T score)&#123; this.score=score; &#125;&#125;class MyClass&lt;T&gt; &#123; private T cls; public T getCls() &#123; return cls; &#125; public void setCls(T cls) &#123; this.cls = cls; &#125;&#125;public static void main(String[] args) &#123; Student&lt;String&gt; stu = new Student&lt;String&gt;(); stu.setScore(&quot;great&quot;); //泛型嵌套 MyClass&lt;Student&lt;String&gt;&gt; cls = new MyClass&lt;Student&lt;String&gt;&gt;(); cls.setCls(stu); Student&lt;String&gt; stu2 = new Student&lt;String&gt;(); stu2 = cls.getCls(); System.out.println(stu2.getScore());//great&#125; 定义两个泛型类 ，Myclass类的泛型就是Student类 ，而Student类的泛型是String类 泛型上下边界? extends E 是泛型的上边界List &lt; ? extends A &gt;表示这个 list 里面存的是 A 的子类，具体是啥不知道，只知道范围! ? super T 是泛型的下边界List &lt; ? super C &gt; 表示 list 里面存的是 C 和其父类，具体是啥不确定，只知道范围。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[]},{"title":"注解","slug":"Java/进阶/注解","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-01T07:31:43.278Z","comments":true,"path":"wiki/Java/进阶/注解/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Java从1.5引入了注解(Annotation)，使得Java具有动态语言的特性。 Java中常用的注解有： @Override @Deprecated @SuppressWarnings 元注解用来修饰注解的注解 @Documented @Retention @Target @Inherited @Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。 @Retention SOURCE:源文件保留，在编译器进行编译时它将被丢弃忽视； CLASS:class保留，并不会被加载到 JVM 中； RUNTIME:运行时保留； @Target CONSTRUCTOR:构造器； FIELD:实例； LOCAL_VARIABLE:局部变量； METHOD:方法； PACKAGE:包； PARAMETER:参数; TYPE:类、接口(包括注解类型) 或enum声明。 @Inherited用于描述某个被标注的类型是可被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 自定义注解注意事项12345678910111213141516171819202122package com.shjlone.anno;enum Lamp &#123; RED, GREEN, YELLOW&#125;public @interface MyAnno &#123;//基本数据类型 int num() default 1; //String类型 String value(); //枚举类型 Lamp lamp(); //注解类型 MyAnno2 myAnno2(); //以上类型的数组 String[] values(); Lamp[] lamps(); MyAnno2[] myAnno2s(); int[] nums();&#125; 注解属性的返回值类型必须是以下几种： 基本数据类型 String类型 枚举类型 注解 以上类型的数组 如果返回值没有默认值，则在使用注解时必须显示设置 APTAPT 即为 Annotation Processing Tool，它是 javac 的一个工具，中文意思为编译 时注解处理器。APT 可以用来在编译时扫描和处理注解。获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT 的核心是 AbstractProcessor 类。 参考 https://bbs.huaweicloud.com/blogs/173996 https://www.jianshu.com/p/5cac4cb9be54 Java进阶–编译时注解处理器（APT）详解","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[]},{"title":"类加载","slug":"Java/进阶/类加载","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-05T01:44:10.242Z","comments":true,"path":"wiki/Java/进阶/类加载/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E8%BF%9B%E9%98%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"类加载过程加载，验证，准备，解析，初始化，使用，卸载 加载 使用 new 关键字实例化对象，读取或者设置一个类的静态变量(被 final修饰的除外，已经在编译器被加入常量池)，以及调用一个类的静态方法的 时候 对类进行反射调用的时候 当初始化一个类时，如果其父类没有被加载，则先对其父类进行加载 当虚拟机启动的时候，用户指定的(包含 main 方法)的类会被加载 在类的加载阶段，虚拟机会完成以下三件事情: 通过一个类的全限定名获取定义类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在 Java 堆中生成一个代表这个类的 Class 对象，作为方法区这些数据的访问入口。 验证这一阶段是为了确保 class 文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要包括以下几个过程: 文件格式验证 元数据验证 字节码验证 符号引用验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在 方法区中进行分配。这个阶段中进行内存分配的变量只有被 static 修饰的变量，并将其设置为默认值，而真正的赋值则在初始化阶段。另外，被 final static 字段 修饰的常量在编译器就已经被赋值。 解析解析阶段主要是虚拟机将常量池内的符号引用替换为直接引用的过程。 初始化初始化阶段是执行类构造器&lt;cinit&gt;()方法的过程。 &lt;cinit&gt;()与类的构造方法不同，&lt;cinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并而成的。编译器收集的顺序是按语句在源文件中出现的顺序决定的，静态语句块中只能访问定义在它之前的静态变 量，定义在它之后的静态变量，只可以赋值，不可以访问。 虚拟机会保证子类的&lt;cinit&gt;()方法执行之前，其父类的&lt;cinit&gt;()方法一定被执行 (父类先与子类完成加载过程)","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://shjlone.github.io/categories/Java/%E8%BF%9B%E9%98%B6/"}],"tags":[]},{"title":"集合知识点总结","slug":"Java/集合/集合知识点总结","date":"2021-05-28T16:00:00.000Z","updated":"2021-07-08T05:50:36.866Z","comments":true,"path":"wiki/Java/集合/集合知识点总结/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"通过迭代器fail-fast属性，你明白了什么? 每次我们尝试获取下一个元素的时候，Iterator fail- fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出 ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的(ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外) fail-fast与fail-safe有什么区别? Iterator的fail-fast属性与当前的集合共同起作用，因此它不会 受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而 java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出 ConcurrentModificationException，而 fail-safe 迭 代 器 从 不 抛 出 ConcurrentModificationException。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[]},{"title":"作用域函数","slug":"程序语言/Kotlin/作用域函数","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-29T10:36:14.375Z","comments":true,"path":"wiki/程序语言/Kotlin/作用域函数/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Kotlin/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Kotlin","slug":"程序语言/Kotlin","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Kotlin/"}],"tags":[]},{"title":"Fragment","slug":"Android/基础/Fragment","date":"2021-05-01T02:01:01.000Z","updated":"2021-06-23T07:00:44.052Z","comments":true,"path":"wiki/Android/基础/Fragment/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Fragment/","excerpt":"","text":"来源Fragment的概念来源于Android3.0，主要目的是为大屏幕（如平板电脑）上更加动态和灵活的界面设计提供支持。他可添加到Activity中，所以多个Activity可添加同一个Fragment，提高了代码复用性。 生命周期 Fragment跟Activity的生命周期类似，不过只有在显示调用addToBackStack()时，系统才会将片段放入由宿主 Activity 管理的返回栈。 生命周期方法onCreate() 系统会在创建片段时调用此方法。当片段经历暂停或停止状态继而恢复后， onCreateView() 系统会在片段首次绘制其界面时调用此方法。如要为片段绘制界面，从此方法中返回的 View 必须是片段布局的根视图。如果片段未提供界面，可以返回 null。 onPause() 系统会将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。 onAttach() 在片段已与 Activity 关联时进行调用（Activity 传递到此方法内）。 onCreateView() 调用它可创建与片段关联的视图层次结构。 onActivityCreated() 当 Activity 的 onCreate() 方法已返回时进行调用。 onDestroyView() 在移除与片段关联的视图层次结构时进行调用。 onDetach() 在取消片段与 Activity 的关联时进行调用。 事务为什么Fragment需要事务呢？我的理解是，由于需要对Fragment进行添加、移除、替换等操作，那么FragmentManager的出现是合适的，而FragmentManager内部使用事务的方式来进行管理，就能保证各种操作的原子性了。 基本用法 123456789101112// 1.获取FragmentManager，在活动中可以直接通过调用getFragmentManager()方法得到 fragmentManager = getSupportFragmentManager();// fragmentManager = getFragmentManager(); // 2.开启一个事务，通过调用beginTransaction()方法开启 transaction = fragmentManager.beginTransaction(); // 3.向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例 transaction.replace(R.id.testFragment, fragment); //fr_container不能为fragment布局，可使用线性布局相对布局等。 // 4.使用addToBackStack()方法，将事务添加到返回栈中，填入的是用于描述返回栈的一个名字 transaction.addToBackStack(null); // 5.提交事物,调用commit()方法来完成 transaction.commit(); 有几个注意点： FragmentActivity和Fragment都有自己的FragmentManager 事务的操作如何通信可通过以下一些方式进行通信： Framgnet中直接获取Activity的引用 Activity中通过FragmentManager获取对应Fragment的引用 通过函数回调 setArguments将参数传递给Fragment 共享ViewModel Fragment Result API 直接获取引用123456//Fragment中获取Activity中的控件View listView = getActivity().findViewById(R.id.list);//Activity中获取某个FragmentExampleFragment fragment = (ExampleFragment) getSupportFragmentManager().findFragmentById(R.id.example_fragment); 这种方式虽然能方便的获取，但从代码设计的角度看是不合适的，耦合性太高了 函数回调1234567891011121314151617181920212223242526272829303132333435363738public static class FragmentA extends ListFragment &#123; ... // Container Activity must implement this interface //定义回调接口 public interface OnArticleSelectedListener &#123; public void onArticleSelected(Uri articleUri); &#125; ...&#125;public static class FragmentA extends ListFragment &#123; OnArticleSelectedListener listener; ... @Override public void onAttach(Context context) &#123; super.onAttach(context); try &#123; //宿主实现该接口，context就是宿主Activity listener = (OnArticleSelectedListener) context; &#125; catch (ClassCastException e) &#123; throw new ClassCastException(context.toString() + &quot; must implement OnArticleSelectedListener&quot;); &#125; &#125; @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; // Append the clicked item&#x27;s row ID with the content provider Uri Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id); // Send the event and Uri to the host activity // 将数据传给Activity，宿主中操作其他Fragment listener.onArticleSelected(noteUri); &#125; ...&#125; 共享ViewModel与宿主Activity通信123456789101112131415161718192021222324252627282930313233343536373839404142public class ItemViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selectedItem = new MutableLiveData&lt;Item&gt;(); public void selectItem(Item item) &#123; selectedItem.setValue(item); &#125; public LiveData&lt;Item&gt; getSelectedItem() &#123; return selectedItem; &#125;&#125;public class MainActivity extends AppCompatActivity &#123; private ItemViewModel viewModel; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //注意ViewModelProvider的参数 viewModel = new ViewModelProvider(this).get(ItemViewModel.class); viewModel.getSelectedItem().observe(this, item -&gt; &#123; // Perform an action with the latest item data &#125;); &#125;&#125;public class ListFragment extends Fragment &#123; private ItemViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); //注意requireActivity viewModel = new ViewModelProvider(requireActivity()).get(ItemViewModel.class); ... items.setOnClickListener(item -&gt; &#123; // Set a new item viewModel.select(item); &#125;); &#125;&#125; 将ViewModel放到同一范围，这样返回的是同一个ViewModel。 与其他Fragment通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ListViewModel extends ViewModel &#123; private final MutableLiveData&lt;Set&lt;Filter&gt;&gt; filters = new MutableLiveData&lt;&gt;(); private final LiveData&lt;List&lt;Item&gt;&gt; originalList = ...; private final LiveData&lt;List&lt;Item&gt;&gt; filteredList = ...; public LiveData&lt;List&lt;Item&gt;&gt; getFilteredList() &#123; return filteredList; &#125; public LiveData&lt;Set&lt;Filter&gt;&gt; getFilters() &#123; return filters; &#125; public void addFilter(Filter filter) &#123; ... &#125; public void removeFilter(Filter filter) &#123; ... &#125;&#125;public class ListFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); //保证在同一个范围 viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class); viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -&gt; &#123; // Update the list UI &#125;); &#125;&#125;public class FilterFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; //保证在同一个范围 viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class); viewModel.getFilters().observe(getViewLifecycleOwner(), set -&gt; &#123; // Update the selected filters UI &#125;); &#125; public void onFilterSelected(Filter filter) &#123; viewModel.addFilter(filter); &#125; public void onFilterDeselected(Filter filter) &#123; viewModel.removeFilter(filter); &#125;&#125; 父子Fragment通信12345678910111213141516171819202122public class ListFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; viewModel = new ViewModelProvider(this).get(ListViewModel.class); viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -&gt; &#123; // Update the list UI &#125; &#125;&#125;public class ChildFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; //注意参数 viewModel = new ViewModelProvider(requireParentFragment()).get(ListViewModel.class); ... &#125;&#125; Fragment Result API在某些情况下，您可能要在 Fragment 之间或 Fragment 与其宿主 Activity 之间传递一次性值。则可以使用setFragmentResultListener。它的原理是在getParentFragmentManager实现了观察者模式。 与其他Fragment通信 一旦 Fragment A 处于 STARTED 状态，它就会收到结果并执行监听器回调。 对于给定的键，只能有一个监听器和结果。如果您对同一个键多次调用 setFragmentResult()，并且监听器未处于 STARTED 状态，则系统会将所有待处理的结果替换为更新后的结果。如果您设置的结果没有相应的监听器来接收，则结果会存储在 FragmentManager 中，直到您设置一个具有相同键的监听器。监听器收到结果并触发 onFragmentResult() 回调后，结果会被清除。这种行为有两个主要影响： 返回堆栈上的 Fragment 只有在被弹出且处于 STARTED 状态之后才会收到结果。 如果在设置结果时监听结果的 Fragment 处于 STARTED 状态，则会立即触发监听器的回调。 123456789101112131415161718192021222324@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //监听某个事件 getParentFragmentManager().setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; // We use a String here, but any type that can be put in a Bundle is supported String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;);&#125;//在Fragment中触发该事件button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle result = new Bundle(); result.putString(&quot;bundleKey&quot;, &quot;result&quot;); getParentFragmentManager().setFragmentResult(&quot;requestKey&quot;, result); &#125;&#125;); 父子Fragment通信 12345678910111213141516171819202122232425@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // We set the listener on the child fragmentManager getChildFragmentManager() .setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;);&#125;button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle result = new Bundle(); result.putString(&quot;bundleKey&quot;, &quot;result&quot;); // The child fragment needs to still set the result on its parent fragment manager getParentFragmentManager().setFragmentResult(&quot;requestKey&quot;, result); &#125;&#125;); 与宿主Activity通信123456789101112131415class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getSupportFragmentManager().setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; // We use a String here, but any type that can be put in a Bundle is supported String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;); &#125;&#125; 参考资料 https://developer.android.com/guide/components/fragments?hl=zh-cn https://developer.android.com/guide/fragments?hl=zh-cn","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"原型模式","slug":"设计模式/创建型模式/原型模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.793Z","comments":true,"path":"wiki/设计模式/创建型模式/原型模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 有时候当你想复制一个对象时，先会想到用new，但有时候你拿到的只是抽象类，亦或者这个对象内部有一些私有属性你是拿不到的。还有时候，如果对象没有实现clone方法来实现克隆，则这个时候通过clone获取的是浅克隆，如果里面有其他对象，则返回的是引用。 原型模式是一种另类的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。 类图 角色 客户（Client）：客户类提出创建对象的请求。 抽象原型（Prototype）：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。 具体原型（Concrete Prototype）：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。 在进行克隆的时候，分为浅拷贝和深拷贝。我们的实际业务场景中大部分情况下需要深拷贝，深拷贝可以通过序列化或者直接new的方式实现。 优缺点优点 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 使用场景 Android中的Intent 12345678public class Intent implements Parcelable, Cloneable &#123;... @Override public Object clone() &#123; return new Intent(this); &#125;...&#125; 参考 https://refactoringguru.cn/design-patterns/prototype https://test-design-patterns.readthedocs.io/zh/latest/creational_patterns/prototype.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法模式","slug":"设计模式/创建型模式/工厂方法模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-24T08:01:01.556Z","comments":true,"path":"wiki/设计模式/创建型模式/工厂方法模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 结构图 角色 抽象工厂：实现了所有操纵产品的方法，但不实现工厂方法。factoryMethod是抽象方法。 具体工厂：必须实现抽象的抽象方法，以实际制造出产品。 抽象产品：所有产品的抽象。 具体产品：不同的具体产品。 优缺点优点： 符合开闭原则，具有很强的的扩展性、弹性和可维护性。扩展时只要添加一个ConcreteCreator，而无须修改原有的ConcreteCreator，因此维护性也好。解决了简单工厂对修改开放的问题。 使用了依赖倒置原则，依赖抽象而不是具体，使用（客户）和实现（具体类）松耦合。 客户只需要知道所需产品的具体工厂，而无须知道具体工厂的创建产品的过程，甚至不需要知道具体产品的类名。 缺点： 代码量增加 设计原则依赖倒置原则：要依赖抽象，不要依赖具体类。 我们写代码的时候应该尽量达到以下原则： 变量不可以持有具体类的引用 不要让类派生自具体类 不要覆盖基类中已实现的方法 使用场景 当需要一个对象时，我们不需要知道该对象所对应的具体类，只要知道哪个具体工厂可以生成该对象，实例化这个具体工厂即可创建该对象。 类的数目不固定，随时有新的子类增加进来，或者是还不知道将来需要实例化哪些具体类。 定义一个创建对象接口，由子类决定要实例化的类是哪一个；客户端可以动态地指定工厂子。 参考 《Head First设计模式》 https://blog.csdn.net/qq_39588630/article/details/80478349","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"建造者模式","slug":"设计模式/创建型模式/建造者模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.791Z","comments":true,"path":"wiki/设计模式/创建型模式/建造者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 类图 角色 Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 优缺点优点 产品本身与产品的创建过程解耦，结构更清晰 使用场景 多个参数初始化时，使用静态内部类Builder。比如Android中的NotificationCompat 链式调用，RxJava 参考 https://refactoringguru.cn/design-patterns/builder https://test-design-patterns.readthedocs.io/zh/latest/creational_patterns/builder.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂模式","slug":"设计模式/创建型模式/抽象工厂模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.759Z","comments":true,"path":"wiki/设计模式/创建型模式/抽象工厂模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 它是工厂方法模式的扩展。工厂方法模式只能生产一种产品，而抽象工厂模式则扩展为多个。 结构图 角色 AbstractFactory：抽象工厂角色，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品，如上述类图中的AbstractFactory就定义了两个方法，分别创建产品A和产品B ConcreteFactory：具体工厂角色，它实现了在抽象工厂中定义的创建产品的方法，生产一组具体产品，这饿产品构件成了一个产品种类，每一个产品都位于某个产品等级结构中，如上述类图中的ConcreteFactoryA和ConcreteFactoryB AbstractProduct：抽象产品角色，为每种产品声明接口，如图中AbstractProductA、AbstractProductB ConcreteProduct：具体产品角色，定义了工厂生产的具体产品对象，实现抽象产品接口声明的业务方法，如图中ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2 参考 《Head First设计模式》","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"享元模式","slug":"设计模式/结构型模式/享元模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.802Z","comments":true,"path":"wiki/设计模式/结构型模式/享元模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义享元模式（Flyweight Pattern）：减少创建对象的数量，以减少内存占用和提高性能。 类图 角色 Flyweight: 抽象享元类 ConcreteFlyweight: 具体享元类 UnsharedConcreteFlyweight: 非共享具体享元类 FlyweightFactory: 享元工厂类 使用场景 Java中的字符串池 Integer对象，当值在-128~+128时，返回的是缓存对象 参考 https://refactoringguru.cn/design-patterns/flyweight https://test-design-patterns.readthedocs.io/zh/latest/structural_patterns/flyweight.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"设计模式/结构型模式/代理模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.786Z","comments":true,"path":"wiki/设计模式/结构型模式/代理模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。它是一种对象结构型模式。 类图 角色 Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色 优缺点优点 封装了一层，高扩展 如果需要在真实对象执行操作的前后执行一些工作，则非常方便 缺点 代码会变多 比直接调用性能上会差些 使用场景 电脑中的快捷方式 商店是商品厂家的代理 中介 Java中的InvocationHandler 参考 https://refactoringguru.cn/design-patterns/proxy https://blog.csdn.net/carson_ho/article/details/54910472","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","slug":"设计模式/结构型模式/外观模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.779Z","comments":true,"path":"wiki/设计模式/结构型模式/外观模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 结构图 外观模式中的角色： 门面角色（Facade）:这是外观模式的核心。它被客户角色调用，因此它熟悉子系统的功能。它内部根据客户角色已有的需求预定了几种功能组合。 子系统角色（SystemA、SystemB、SystemC）:实现了子系统的功能。对子系统角色来说，facade角色与客户角色一样，是未知的，它没有任何facade角色的信息和链接。 客户角色（Client）：调用facade角色来完成要得到的功能。 优缺点优点： 降低了Client的使用难度，子系统对其是黑盒的。隐藏了内部细节 降低了耦合性 设计原则迪米特原则（LOW OF DEMETER）：也叫最少知识原则。只和你的密友谈话。 当你设计一个系统，不管是任何对象，都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。 使用场景 遥控器：一个按钮就能帮我们完成多件事情。 第三方库的启动封装：一般调用init方法就能完成初始化，其内部会做许多工作。 参考 《Head First设计模式》 https://www.cnblogs.com/jimoer/p/9463698.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"设计模式/结构型模式/桥接模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.768Z","comments":true,"path":"wiki/设计模式/结构型模式/桥接模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 类图 角色 Abstraction：抽象类，保存一个对实现化对象（Implementor）的引用 RefinedAbstraction：扩充抽象类，改变和修正父类对抽象化的定义 Implementor：角色给出实现化角色的接口，但不给出具体的实现 ConcreteImplementor：具体实现类 优缺点优点 抽象和实现分离，扩展性高。 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。 缺点 增加系统的理解与设计难度 使用场景参考 https://test-design-patterns.readthedocs.io/zh/latest/structural_patterns/bridge.html https://refactoringguru.cn/design-patterns/bridge https://zhuanlan.zhihu.com/p/58903776","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"设计模式/结构型模式/组合模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.777Z","comments":true,"path":"wiki/设计模式/结构型模式/组合模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 类图 角色 Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。 Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。 Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。 优缺点优点 满足开闭原则，在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改 使用场景 树形结构，比如文件夹的管理 参考 https://refactoringguru.cn/design-patterns/composite https://www.cnblogs.com/chenssy/p/3299719.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰模式","slug":"设计模式/结构型模式/装饰模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.807Z","comments":true,"path":"wiki/设计模式/结构型模式/装饰模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义装饰器模式（Decorator Pattern）：在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）。 类图 角色 抽象构件(Component)角色：给出一个抽象接口，已规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 优缺点优点 符合开闭原则，单一职责原则 使用场景 Java中的IO相关API 参考 https://refactoringguru.cn/design-patterns/decorator https://test-design-patterns.readthedocs.io/zh/latest/structural_patterns/decorator.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"设计模式/结构型模式/适配器模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-07-13T01:44:42.789Z","comments":true,"path":"wiki/设计模式/结构型模式/适配器模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义适配器模式（Adapter Pattern）：将一个类的接口转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以相互合作。适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 适配器模式优点 复用且不修改类 : 不改变现有类的基础上 , 提高类的复用性 , 透明性 ; 让现有类与目标类接口匹配 ; 降低耦合 : 目标类 ( 用户调用的接口所在类 ) 和 现有类 ( 被适配者 ) 解除耦合 , 降低了系统的耦合性 , 易于扩展维护; 符合开闭原则 : 用户调用适配器接口 , 只与适配器类进行交互 , 如果需要修改扩展 , 只需要修改适配器类即可 , 目标类和现有类各自都是相互独立的 , 互不影响 ; 适配器模式缺点 增加复杂性 : 编写适配器类时 , 需要考虑全面 , 包括被适配者 和 目标类 , 系统复杂性会增加; 降低可读性 : 系统代码可读性降低 , 可维护性降低 ; 对象适配器在对象适配器模式中，适配器与适配者之间是关联关系（适配者是适配器的成员变量）。 结构图 Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承(或者实现)Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.shjlone.designpattern.adapter.objectadapter;/** * 对象适配器模式 */public class ObjectAdapterTest &#123; public static void main(String[] args) &#123; TypeC typeC = new Phone(); MicroUsb microUsb = new Adapter(typeC); microUsb.microUsb(); &#125;&#125;// 供应接口interface MicroUsb &#123; public void microUsb();&#125;// 需求接口interface TypeC &#123; public void typeC();&#125;// 需求实现类class Phone implements TypeC &#123; public void typeC() &#123; System.out.println(&quot;Type-C接口&quot;); &#125;&#125;// 适配器class Adapter implements MicroUsb &#123; private TypeC typeC; public Adapter(TypeC typeC) &#123; this.typeC = typeC; &#125; @Override public void microUsb() &#123; typeC.typeC(); &#125;&#125; 类适配器在类适配器模式中，适配器与适配者之间是继承关系。 123456789101112131415161718192021222324252627282930313233343536package com.shjlone.designpattern.adapter.classadapter;/** * 类适配器 */public class ClassAdapterTest &#123; public static void main(String[] args) &#123; MicroUsb microUsb = new Adapter(); microUsb.microUsb(); &#125;&#125;//供应接口interface MicroUsb &#123; public void microUsb();&#125;//需求接口interface TypeC &#123; public void typeC();&#125;//需求实现类class Phone implements TypeC &#123; public void typeC() &#123; System.out.println(&quot;Type-C接口&quot;); &#125;&#125;//适配器class Adapter extends Phone implements MicroUsb &#123; public void microUsb() &#123; typeC(); &#125;&#125; 缺省适配器模式(Default Adapter Pattern)当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.shjlone.designpattern.adapter.defaultadapter;/** * 默认适配器，用于隐藏一些实现细节 */public class DefaultAdapterTest &#123; public static void main(String[] args) &#123; TypecToVGA typecToVGA = new TypecToVGA(); typecToVGA.isTypeC(); typecToVGA.isVGA(); &#125;&#125;// 接口类interface AllPorts &#123; public void isTypeC(); public void isVGA(); public void isHdmi();&#125;// 适配器的框架abstract class Adapter implements AllPorts &#123; @Override public void isTypeC() &#123; &#125; @Override public void isVGA() &#123; &#125; @Override public void isHdmi() &#123; &#125;&#125;// 适配器类class TypecToVGA extends Adapter &#123; @Override public void isTypeC() &#123; System.out.println(&quot;信号从TypeC接口进入&quot;); &#125; @Override public void isVGA() &#123; System.out.println(&quot;信号从VGA接口出&quot;); &#125;&#125; 使用场景 Java连接数据的JDBC工具 List Arrays.asList(T[]) InputStreamReader StringReader 123456789101112131415161718192021222324252627282930313233/*** 对象适配器* StringReader相当于Adapter，Reader相当于Target，String相当于Adaptee***/public class StringReader extends Reader &#123; // 维持对adaptee对象的引用 private String str; private int length; private int next = 0; private int mark = 0; /** * 构造注入一个String用于之后的read操作 */ public StringReader(String s) &#123; this.str = s; this.length = s.length(); &#125; // 这里相当于是在做适配操作，转为目标对象所期望的请求 public int read() throws IOException &#123; synchronized (lock) &#123; ensureOpen(); if (next &gt;= length) return -1; return str.charAt(next++); &#125; &#125;&#125; 参考 https://www.liaoxuefeng.com/wiki/1252599548343744/1281319245971489 https://www.cnblogs.com/bytesfly/p/adapter-pattern.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"《干就对了：业绩增长九大关键》读书笔记","slug":"读书笔记/干就对了","date":"2017-03-11T16:00:00.000Z","updated":"2021-05-29T08:44:05.169Z","comments":true,"path":"wiki/读书笔记/干就对了/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%B9%B2%E5%B0%B1%E5%AF%B9%E4%BA%86/","excerpt":"","text":"摘要1 宁愿要三流的战略加上一流的组织，也不要一流的战略、三流的组织。 感悟： 好的团队很重要，一群优秀的人，目的明确，团结一致，想不成功都难。在团队建设过程中，一定要尽量留下优秀的人才。 摘要2组织架构的设计原则： 1.自上而下和自下而上要结合。 2.组织架构设计要保持弹性，也就是要跳出KPI做正确的事。 摘要3中台建设原则： 客户第一 赋能而非管控 前线要有授权 总部要有看板 善用双线汇报 摘要4岗位职责的设计注意点： 切忌“大而全” 要有颗力度和明确的比重 人事部门不能包揽岗位职责编写工作 岗位职责不能一成不变 岗位职责再纵深层次上不能一样 感悟： 每个岗位都应该有明确的职责要求，实际工作当中，很多人会把模棱两可的任务推来推去。 摘要5如何扣动员工的心灵扳机： 寻找心动点 寻找成就点 生理需求和安全需求 情感和归属需求 尊重需求 自我实现需求 管理者不要站在自己的角度思考员工的原动力 管理者要看到目标实现的可能性，不能画大饼 感悟： 说到底还是要关注”人”本身，关注他的真实需求，尽量在现有框架下满足他的需求，他才能给团队带来更多的价值。 摘要6 “No Surprise”：管理者在日常过程中发现问题没有及时提醒 当员工犯错的时候，不要急于批评，因为大多数批评解决不了问题。正确的步骤是判断这些错误会产生什么影响，然后再做处理。一般从两个维度判断——业绩和价值观。 感悟： 自己在实际工作中就出现过类似的问题，在问题刚刚出现时没有及时去处理，最终那个团队成员离职了。回过头想，其实在问题刚出现的时候，就处理的话，他应该在近期是不会离职的。 摘要6设计KPI时要关注的6个要素： 目标值； 权重； 计算方式； 评分标准； 评估周期。 摘要7 裸心会，真正的关心员工，而不是流于形式。 感悟： 阿里所谓但裸心会，说到底还是要真正但关心团队成员的内心真实想法，流于表面的生日会、聚餐，并不能跟大家交心。想要交心，是要真正的去了解对方，把对方当成好哥们，哥们家人生病了，你是要关怀的。","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Welcome Shjlone's Blog","slug":"index","date":"2017-01-21T17:55:57.000Z","updated":"2021-05-29T06:50:55.106Z","comments":true,"path":"wiki/index/","link":"","permalink":"http://shjlone.github.io/wiki/index/","excerpt":"","text":"这是我的个人博客，用于记录自己的点点滴滴！","raw":null,"content":null,"categories":[],"tags":[]}]}